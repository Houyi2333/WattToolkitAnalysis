扫描结果:

发现 Unix 特定路径：../SteamTools\src\AboutAppInfoPopup.cs
/ 验证平台兼容性
                }
                catch
                {
                }
            }
#endif

            b.Append("[memory.usage] ");
#if __ANDROID__
            var activityManager = activity.GetActivityManager();
            ActivityManager.MemoryInfo memoryInfo = new();
            activityManager.GetMemoryInfo(memoryInfo);
            var nativeHeapSize = memoryInfo.TotalMem;
            var nativeHeapFreeSize = memoryInfo.AvailMem;
            var usedMemInBytes = nativeHeapSize - nativeHeapFreeSize;
            var usedMemInPercentage = usedMemInBytes * 100M / nativeHeapSize;
            b.Append($"{IOPath.GetDisplayFileSizeString(usedMemInBytes)} ({usedMemInPercentage:0.00}%)");
#else
            b.Append(IOPath.GetDisplayFileSizeString(Environment.WorkingSet));
#endif
            b.AppendLine();

            b.Append("[deploy.mode] ");
            b.Append(IApplication.Instance.DeploymentMode);
            b.AppendLine();

            b.Append("[arch.os] ");
            b.Append(RuntimeInformation.OSArchitecture);
            b.AppendLine();

            b.Append("[arch.proc] ");
            b.Append(RuntimeInformation.ProcessArchitecture);
            b.AppendLine();

#if MONOANDROID
            b.Append("[clr.ver] ");
            string? clrVersion;
            try
            {
                clrVersion = GetAssemblyVersion(typeof(object).Assembly);
            }
            catch
            {
                clrVersion = null;
            }
            if (string.IsNullOrEmpty(clrVersion))
                b.Append(Environment.Version);
            else
                b.Append(clrVersion);
            b.AppendLine();
#endif

#if __ANDROID__

#if V2RAY
                b.Append("[v2ray.ver] ");
                b.Append(Libv2ray.Libv2ray.CheckVersionX());
                b.AppendLine();
#endif

            
发现与操作系统相关的函数调用：../SteamTools\src\AboutAppInfoPopup.cs
name
发现条件编译指令：../SteamTools\src\AboutAppInfoPopup.cs
IS
WINDOWS
MONOANDROID
V
MONOANDROID
AVALONIA
AVALONIA
发现 Unix 特定路径：../SteamTools\src\AssemblyInfo.Constants.cs
/ </summary>
public static partial class AssemblyInfo
{
    const string Version2 = "3.0";

    
/semver.org/lang/zh-CN/
    
/ </summary>
    public const string Version = $"{Version2}.0";

    
/ </summary>
    const string ver_for_preview = "0";

    
/ </summary>
    const string ver_for_rc = "14";

    public const string FileVersion = $"{Version2}.{ver_for_rc}2{ver_for_preview}.0";

    
/ </summary>
    public static bool IsPreview { get; } = InformationalVersion.Contains("preview", StringComparison.OrdinalIgnoreCase);

    
/ </summary>
    public static bool IsReleaseCandidate { get; } = !IsPreview && InformationalVersion.Contains("rc", StringComparison.OrdinalIgnoreCase);

    
/ </summary>
    public static bool IsGeneralAvailability { get; } = !IsPreview && !IsReleaseCandidate;
#endif

    
/ </summary>
    public const string Trademark = "Watt Toolkit";

    public const string Title =
#if DEBUG
        $"[Debug] {Trademark}";
#else
        Trademark;
#endif

    
/ </summary>
    public const string Product = Trademark;

    
/ </summary>
    public const string Description = $"「{Trademark}」是一个开源跨平台的多功能游戏工具箱。";

    
/ </summary>
    public const string Company = "江苏蒸汽凡星科技有限公司";

    
/ </summary>
    public const string Copyright = $"©️ {Company}. All rights reserved.";

    
/ </summary>
    public const string CultureName_SimplifiedChinese = "zh-Hans";
    public const string CultureName_PRC = "zh-CN";
    public const string CultureName_TraditionalChinese = "zh-Hant";
    public const string CultureName_English = "en";
    public const string CultureName_Korean = "ko";
    public const string CultureName_Japanese = "ja";
    public const string CultureName_Russian = "ru";
    public const string CultureName_Spanish = "es";
    public const string CultureName_Italian = "it";

    public const bool Debuggable =
#if DEBUG
true
#else
false
#endif
        ;

#if !APP_HOST

    public const string APPLICATION_ID = "net.steampp.app";

    
/ <inheritdoc cref="dotnetCampus.Ipc.CompilerServices.Attributes.IpcPublicAttribute.Timeout"/>
    public const int IpcTimeout =
#if DEBUG
        8000000;
#else
        8000;
#endif

#endif

#if !APP_HOST

    #region Modules/Plugins

    public const string Accelerator = "Accelerator";

    public const string GameAccount = "GameAccount";

    public const string GameList = "GameList";

    public const string SteamIdleCard = "SteamIdleCard";

    public const string ArchiSteamFarmPlus = "ArchiSteamFarmPlus";

    public const string Authenticator = "Authenticator";

    public const string GameTools = "GameTools";
    
发现条件编译指令：../SteamTools\src\AssemblyInfo.Constants.cs
DEBUG
DEBUG
DEBUG
发现条件编译指令：../SteamTools\src\AssemblyInfo.cs
WINDOWS
APP
APP
发现 Unix 特定路径：../SteamTools\src\AssemblyInfo.Xaml.cs
/steampp.net/ui", "BD.WTTS.Enums")]
[assembly: XmlnsDefinition("https:
/steampp.net/ui", "BD.WTTS.Models")]
[assembly: XmlnsDefinition("https:
/steampp.net/ui", "BD.WTTS.Models.Abstractions")]
[assembly: XmlnsDefinition("https:
/steampp.net/ui", "BD.WTTS.UI.ViewModels")]
[assembly: XmlnsDefinition("https:
/steampp.net/ui", "BD.WTTS.UI.ViewModels.Abstractions")]
[assembly: XmlnsDefinition("https:
/steampp.net/ui", "BD.WTTS.UI.Views")]
[assembly: XmlnsDefinition("https:
/steampp.net/ui", "BD.WTTS.UI.Styling")]
[assembly: XmlnsDefinition("https:
/steampp.net/ui", "BD.WTTS.UI.Views.Controls")]
[assembly: XmlnsDefinition("https:
/steampp.net/ui", "BD.WTTS.UI.Views.Pages")]
[assembly: XmlnsDefinition("https:
/steampp.net/ui", "BD.WTTS.UI.Views.Windows")]
[assembly: XmlnsDefinition("https:
/steampp.net/ui", "BD.WTTS.Converters")]
[assembly: XmlnsDefinition("https:
/steampp.net/ui", "BD.WTTS.Markup")]
[assembly: XmlnsDefinition("https:
/steampp.net/ui", "BD.WTTS.Client.Resources")]
[assembly: XmlnsDefinition("https:
/steampp.net/ui", "Mobius.Models")]
[assembly: XmlnsDefinition("https:
/steampp.net/ui", "Mobius")]

[assembly: XmlnsDefinition("https:
/steampp.net/services", "BD.WTTS.Services")]
[assembly: XmlnsDefinition("https:
/steampp.net/services", "BD.WTTS.Plugins")]
[assembly: XmlnsDefinition("https:
/steampp.net/services", "BD.WTTS.Plugins.Abstractions")]
[assembly: XmlnsDefinition("https:
/steampp.net/settings", "BD.WTTS.Settings")]

#endif
发现条件编译指令：../SteamTools\src\ImplicitUsings.AspNetCore.cs
NET
发现条件编译指令：../SteamTools\src\ImplicitUsings.BCL.cs
WINDOWS
ANDROID
发现条件编译指令：../SteamTools\src\ImplicitUsings.Common.cs
ANDROID
发现 Windows 特有的库：../SteamTools\src\ImplicitUsings.ReactiveUI.cs
发现条件编译指令：../SteamTools\src\ImplicitUsings.Repositories.cs
ANDROID
发现 Unix 特定路径：../SteamTools\src\Utils.cs
/ </summary>
public static partial class ProjectUtils
{
    
/ </summary>
    public static readonly string ProjPath;

    static ProjectUtils()
    {
        ProjPath = GetProjectPath();
        
/docs.github.com/en/actions/learn-github-actions/variables#default-environment-variables
        isCI = bool.TryParse(Environment.GetEnvironmentVariable("CI"), out var result) && result;
    }

    
/ </summary>
    
/ <param name="path"></param>
    
/ <returns></returns>
    public static string GetProjectPath(string? path = null)
    {
        path ??=
#if NET46_OR_GREATER || NETCOREAPP
        AppContext.BaseDirectory;
#else
        AppDomain.CurrentDomain.BaseDirectory;
#endif
        try
        {
#pragma warning disable IDE0079 
/ </summary>
    public static readonly string tfm =
#pragma warning restore SA1307 
/ </summary>
    public const string tfm_ =
#if WINDOWS
    "-windows10.0.19041";
#elif LINUX
    "";
#elif MACCATALYST
    "-maccatalyst";
#elif MACOS
    "-macos";
#else
    "";
#endif
#endif

    static readonly bool isCI;

    public static bool IsCI() => isCI;
}
发现条件编译指令：../SteamTools\src\Utils.cs
NET
NET
WINDOWS
发现条件编译指令：../SteamTools\src\VisualStudioAppCenterSDK.AppSecret.cs
APP
DEBUG
DEBUG
DEBUG
DEBUG
WINDOWS
WINDOWS
发现 Unix 特定路径：../SteamTools\src\VisualStudioAppCenterSDK.cs
/ <item>将移动开发人员常用的多种服务整合到一个集成的产品中。</item>

/ <item>您可以构建，测试，分发和监控移动应用程序，还可以实施推送通知。</item>

/docs.microsoft.com/zh-cn/appcenter/sdk/getting-started/xamarin</item>

/visualstudio.microsoft.com/zh-hans/app-center</item>

/ </list>

/ </summary>
static partial class VisualStudioAppCenterSDK
{
    internal static void Init()
    {
        if (DateTime.UtcNow >= new DateTime(2025, 3, 31, default, default, default, DateTimeKind.Utc))
        {
            
/learn.microsoft.com/en-us/appcenter/retirement
            return;
        }

        var appSecret = AppSecret;
        if (string.IsNullOrWhiteSpace(appSecret))
            return;
#if WINDOWS || LINUX || MACCATALYST || MACOS || APP_REVERSE_PROXY
        var utils = UtilsImpl.Instance;
        AppCenter.SetDeviceInformationHelper(utils);
        AppCenter.SetPlatformHelper(utils);
#pragma warning disable CS0612 
发现条件编译指令：../SteamTools\src\VisualStudioAppCenterSDK.cs
WINDOWS
DEBUG
WINDOWS
LINUX
发现 Unix 特定路径：../SteamTools\src\Avalonia.Base\Metadata\XmlnsDefinitionAttribute.cs
/github.com/AvaloniaUI/Avalonia/blob/11.0.0-preview6/src/Avalonia.Base/Metadata/XmlnsDefinitionAttribute.cs

namespace Avalonia.Metadata;


/ </summary>
[AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true)]
public sealed class XmlnsDefinitionAttribute : Attribute
{
    
/ Initializes a new instance of the <see cref="XmlnsDefinitionAttribute"/> class.
    
/ </summary>
    
/ <param name="xmlNamespace">The URL of the XML namespace.</param>
    
/ <param name="clrNamespace">The CLR namespace.</param>
    public XmlnsDefinitionAttribute(string xmlNamespace, string clrNamespace)
    {
        XmlNamespace = xmlNamespace;
        ClrNamespace = clrNamespace;
    }

    
/ </summary>
    public string XmlNamespace { get; }

    
/ </summary>
    public string ClrNamespace { get; }
}
发现 Unix 特定路径：../SteamTools\src\Avalonia.Desktop\AppBuilderDesktopExtensions.cs
/github.com/AvaloniaUI/Avalonia/blob/0.10.13/src/Avalonia.Desktop/AppBuilderDesktopExtensions.cs


发现条件编译指令：../SteamTools\src\Avalonia.Desktop\AppBuilderDesktopExtensions.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\Avalonia.Skia.Internals\ClassicDesktopStyleApplicationLifetime.cs
/github.com/AvaloniaUI/Avalonia/blob/e1138f2cb6a393802b235a073d28e85a64690ffe/src/Avalonia.Controls/ApplicationLifetimes/ClassicDesktopStyleApplicationLifetime.cs

using Avalonia.Controls;
using Avalonia.Controls.ApplicationLifetimes;
using Avalonia.Interactivity;
using Avalonia.Platform;
using Avalonia.Threading;

namespace Avalonia.Controls.ApplicationLifetimes
{
    sealed class ClassicDesktopStyleApplicationLifetime2 : IClassicDesktopStyleApplicationLifetime, IDisposable
    {
        int _exitCode;
        CancellationTokenSource? _cts;
        bool _isShuttingDown;
        readonly HashSet<Window> _windows = new();

#pragma warning disable SA1308 
/ <inheritdoc/>
        public event EventHandler<ControlledApplicationLifetimeStartupEventArgs>? Startup;

        
/ <inheritdoc/>
        public event EventHandler<ShutdownRequestedEventArgs>? ShutdownRequested;

        
/ <inheritdoc/>
        public event EventHandler<ControlledApplicationLifetimeExitEventArgs>? Exit;

        
/ </summary>
        public string[]? Args { get; set; }

        
/ <inheritdoc/>
        public ShutdownMode ShutdownMode { get; set; }

        
/ <inheritdoc/>
        public Window? MainWindow { get; set; }

        
/ <inheritdoc />
        public IReadOnlyList<Window> Windows => _windows.ToArray();

        void HandleWindowClosed(Window? window)
        {
            if (window == null)
                return;

            if (_isShuttingDown)
                return;

            if (ShutdownMode == ShutdownMode.OnLastWindowClose && _windows.Count == 0)
                TryShutdown();
            else if (ShutdownMode == ShutdownMode.OnMainWindowClose && ReferenceEquals(window, MainWindow))
                TryShutdown();
        }

        public void Shutdown(int exitCode = 0)
        {
            DoShutdown(new ShutdownRequestedEventArgs(), true, true, exitCode);
        }

        public bool TryShutdown(int exitCode = 0)
        {
            return DoShutdown(new ShutdownRequestedEventArgs(), true, false, exitCode);
        }

        public int Start(string[] args)
        {
            Startup?.Invoke(this, new ControlledApplicationLifetimeStartupEventArgs(args));

            var options = AvaloniaLocator.Current.GetService<ClassicDesktopStyleApplicationLifetimeOptions>();

            if (options != null && options.ProcessUrlActivationCommandLine && args.Length > 0)
            {
                if (Application.Current is IApplicationPlatformEvents events)
                {
                    events.RaiseUrlsOpened(args);
                }
            }

            var lifetimeEvents = AvaloniaLocator.Current.GetService<IPlatformLifetimeEventsImpl>();

            if (lifetimeEvents != null)
                lifetimeEvents.SetShutdownRequested(OnShutdownRequested);

            _cts = new CancellationTokenSource();

            
/appcenter.ms/orgs/BeyondDimension/apps/Steam/crashes/errors/3780037517u/overview
                
/ ClassicDesktopStyleApplicationLifetime.DoShutdown (ShutdownRequestedEventArgs e, Boolean force, Int32 exitCode) /_/src/Avalonia.Controls/ApplicationLifetimes/ClassicDesktopStyleApplicationLifetime.cs, line 147
                
/   at Avalonia.Controls.ApplicationLifetimes.ClassicDesktopStyleApplicationLifetime.DoShutdown(ShutdownRequestedEventArgs e, Boolean force, Int32 exitCode) in /_/src/Avalonia.Controls/ApplicationLifetimes/ClassicDesktopStyleApplicationLifetime.cs:line 147
                
/   at Avalonia.Controls.ApplicationLifetimes.ClassicDesktopStyleApplicationLifetime.OnShutdownRequested(Object sender, ShutdownRequestedEventArgs e) in /_/src/Avalonia.Controls/ApplicationLifetimes/ClassicDesktopStyleApplicationLifetime.cs:line 186
                
/   at Avalonia.Win32.Win32Platform.WndProc(IntPtr hWnd, UInt32 msg, IntPtr wParam, IntPtr lParam) in /_/src/Windows/Avalonia.Win32/Win32Platform.cs:line 283
                if (_isShuttingDown)
                    
发现 Unix 特定路径：../SteamTools\src\Avalonia.Skia.Internals\DrawingContextExtensions.cs
/github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Rendering/Composition/Server/DrawingContextProxy.cs
            FieldInfo? implField = context.GetType().GetField("_impl", BindingFlags.NonPublic | BindingFlags.Instance);
            if (implField != null)
            {
                object? implValue = implField.GetValue(context);
                if (implValue != null && implValue is IDrawingContextImpl contextImpl)
                {
                    drawableImage.Draw((DrawingContextImpl)contextImpl, s, d, paint);
                }
            }
        }

        SKPaintCache.Shared.ReturnReset(paint);
    }
}

发现 Unix 特定路径：../SteamTools\src\Avalonia.Skia.Internals\ImmutableBitmap.cs
/github.com/AvaloniaUI/Avalonia/blob/0.10.13/src/Skia/Avalonia.Skia/ImmutableBitmap.cs


/ </summary>

/ </summary>

/ <param name="stream">Stream containing encoded data.</param>

/        var realScale = horizontal ? ((double)info.Height / info.Width) : ((double)info.Width / info.Height);


/            var supportedScale = codec.GetScaledDimensions(horizontal ? ((float)decodeSize / info.Width) : ((float)decodeSize / info.Height));


/ </summary>

/ <param name="size">Size of the bitmap.</param>

/ <param name="dpi">DPI of the bitmap.</param>

/ <param name="stride">Stride of data pixels.</param>

/ <param name="format">Format of data pixels.</param>

/ <param name="alphaFormat">Alpha format of data pixels.</param>

/ <param name="data">Data pixels.</param>

/ <inheritdoc />

/ <inheritdoc />

/ <inheritdoc />

/ <inheritdoc />

发现 Unix 特定路径：../SteamTools\src\Avalonia.Skia.Internals\PlatformRenderInterface.cs
/github.com/AvaloniaUI/Avalonia/blob/0.10.13/src/Skia/Avalonia.Skia/PlatformRenderInterface.cs


发现 Unix 特定路径：../SteamTools\src\Avalonia.Skia.Internals\SkiaPlatform2.cs
/github.com/AvaloniaUI/Avalonia/blob/0.10.13/src/Skia/Avalonia.Skia/SkiaPlatform.cs#L18-L27


发现 Unix 特定路径：../SteamTools\src\Avalonia.Skia.Internals\SkiaSharpHelpers.cs
/docs.microsoft.com/en-us/xamarin/xamarin-forms/user-interface/graphics/skiasharp/basics/bitmaps#loading-a-bitmap-from-the-web

发现 Unix 特定路径：../SteamTools\src\Avalonia.Skia.Internals\SKTypefaceCollectionCache.cs
/ </summary>

/ <param name="fontFamily">The font family.</param>

/ <returns></returns>

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\App\IApplication.Assets.cs
/ </summary>
    
/ <param name="iconKey"></param>
    
/ <returns></returns>
    string? GetIconSourceByIconKey(string? iconKey) => string.IsNullOrWhiteSpace(iconKey) ? null :
#if WINDOWS || MACCATALYST || MACOS || LINUX
        $"avares:
/BD.WTTS.Client.Avalonia.App/UI/Assets/Icons/{iconKey}.ico";
#elif IOS || ANDROID
        iconKey;
#endif

    
/ </summary>
    
/ <param name="typeName"></param>
    
/ <returns></returns>
    string GetIconKeyByTypeName(string typeName)
    {
#if WINDOWS || MACCATALYST || MACOS || LINUX
        return typeName;
#elif IOS || ANDROID
        return $"{typeName.ToLowerInvariant()}.png";
#endif
    }
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\App\IApplication.Assets.cs
WINDOWS
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\App\IApplication.Clipboard.cs
/ </summary>
    
/ <param name="text"></param>
    
/ <param name="msgToast"></param>
    
/ <param name="showToast"></param>
    
/ <returns></returns>
    static async Task CopyToClipboardAsync(string? text, string? msgToast = null, bool showToast = true)
    {
        if (!string.IsNullOrWhiteSpace(text))
        {
            await Clipboard2.SetTextAsync(text);
            if (showToast) Toast.Show(ToastIcon.Success, msgToast ?? AppResources.CopyToClipboard);
        }
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\App\IApplication.cs
/ </summary>
public partial interface IApplication
{
    static IApplication Instance => Ioc.Get<IApplication>();

    
/ </summary>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static bool IsDesktop()
#if WINDOWS || MACOS || LINUX
        => true;
#elif MACCATALYST
        => OperatingSystem.IsMacOS();
#elif IOS || ANDROID
        => false;
#else
        => OperatingSystem.IsWindows() || OperatingSystem.IsMacOS() || (OperatingSystem.IsLinux() && !OperatingSystem.IsAndroid());
#endif

    [Obsolete("use IsDesktop", true)]
    static bool IsDesktopPlatform => IsDesktop();

    
/ <para>reference to the ViewController (if using Xamarin.iOS), Activity (if using Xamarin.Android) IWin32Window or IntPtr (if using .Net Framework).</para>
    
/ </summary>
    object CurrentPlatformUIHost { get; }

#if WINDOWS
    private static readonly Lazy<DeploymentMode> _DeploymentMode = new(() =>
    {
        try
        {
            var path = typeof(object).Assembly.Location;
            var programFiles = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles);
            if (path.StartsWith(programFiles, StringComparison.OrdinalIgnoreCase))
            {
                return DeploymentMode.FDE;
            }
        }
        catch
        {
        }
        return DeploymentMode.SCD;
    });
#endif

    DeploymentMode DeploymentMode =>
#if WINDOWS
        _DeploymentMode.Value;
#else
        DeploymentMode.SCD;
#endif

    
/ <inheritdoc cref="IPlatformService.SetBootAutoStart(bool, string)"/>
    static void SetBootAutoStart(bool isAutoStart) => IPlatformService.Instance.SetBootAutoStart(isAutoStart, Constants.HARDCODED_APP_NAME);

    private static readonly Lazy<ClientPlatform> clientPlatform = new(() =>
    {
        var platform = DeviceInfo2.Platform();
        
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\App\IApplication.cs
WINDOWS
WINDOWS
WINDOWS
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\App\IApplication.Helper.cs
/ </summary>
    
/ <param name="value"></param>
    void SetThemeNotChangeValue(AppTheme value) { }

    
/ </summary>
    void Shutdown() { }

    
/ </summary>
    void RestoreMainWindow() { }

    
/ </summary>
    void SetTopmostOneTime() { }

    
/ </summary>
    IReadOnlyDictionary<string, ICommand> TrayIconMenus { get; }

    
/ </summary>
    
/ <returns></returns>
    bool HasActiveWindow();
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\App\IApplication.Log.cs
/ </summary>
    
/ <param name="logLevel">level to be converted.</param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static NLogLevel ConvertLogLevel(LogLevel logLevel) => IPCSubProcessFileSystem.ConvertLogLevel(logLevel);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static void SetNLoggerMinLevel(LogLevel logLevel) => SetNLoggerMinLevel(ConvertLogLevel(logLevel));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static void SetNLoggerMinLevel(NLogLevel logLevel)
    {
        NLogManager.GlobalThreshold = logLevel;
        NInternalLogger.LogLevel = logLevel;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void TrySetLoggerMinLevel(LogLevel logLevel)
    {
        try
        {
            var o = LoggerFilterOptions;
            if (o != null) o.MinLevel = logLevel;
        }
        catch
        {
        }
        SetNLoggerMinLevel(ConvertLogLevel(logLevel));
    }

    private static LoggerFilterOptions? _LoggerFilterOptions;

    
/ </summary>
    static LoggerFilterOptions? LoggerFilterOptions
    {
        get
        {
            if (_LoggerFilterOptions != null) return _LoggerFilterOptions;
            return Ioc.Get_Nullable<IOptions<LoggerFilterOptions>>()?.Value;
        }
        set => _LoggerFilterOptions = value;
    }

    
/ </summary>
    public static Action<ILoggingBuilder> ConfigureLogging(LogLevel minLevel = DefaultLoggerMinLevel)
    {
        return (ILoggingBuilder builder) =>
        {
            builder.ClearProviders();

            
/ </summary>
    public static LogLevel LoggerMinLevel
    {
        get
        {
            var o = LoggerFilterOptions;
            if (o == null)
            {
                o = new();
                LoggerFilterOptions = o;
            }
            return o.MinLevel;
        }

        set
        {
            var o = LoggerFilterOptions;
            if (o != null)
            {
                o.MinLevel = value;
            }
            SetNLoggerMinLevel(value);
        }
    }

    
/ </summary>
    public static bool EnableLogger
    {
        get => LoggerMinLevel > LogLevel.None;
        set
        {
            LoggerMinLevel = value ? DefaultLoggerMinLevel : LogLevel.None;
        }
    }

    #endregion

    #region LogHelper

    
/ </summary>
    static string LogDirPath { get; internal set; } = string.Empty;

#if (WINDOWS || MACCATALYST || MACOS || LINUX) && !(IOS || ANDROID)

    
/ </summary>
    static string LogDirPathASF { get; set; } = string.Empty;

#endif

#if DEBUG
    
/ </summary>
    [Obsolete("only True.", true)]
    static bool LogUnderCache => true;
#endif

    static Action? ASFInitCoreLoggers { get; private set; }

    #endregion
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\App\IApplication.Log.cs
WINDOWS
ANDROID
DEBUG
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\App\IApplication.Options.cs
/ </summary>
    public static bool DisableGPU { get; set; }

    
/ </summary>
    public static bool UseWgl { get; set; }
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\App\IApplication.Options.cs
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\App\IApplication.Program.cs
/ </summary>
    [Obsolete("use var processPath = Environment.ProcessPath; processPath.ThrowIsNull()", true)]
    static string ProgramPath
    {
        get
        {
            _ProgramPath ??= Environment.ProcessPath ?? "";
            return _ProgramPath;
        }
    }
#endif

    private static string? _ProgramName;

    
/ </summary>
    static string ProgramName
    {
        get
        {
            _ProgramName ??= GetProgramName();
            return _ProgramName;
        }
    }

    private static string GetProgramName()
    {
        var processPath = Environment.ProcessPath;
        var programName = Path.GetFileName(processPath.ThrowIsNull());
        return programName.ThrowIsNull();
    }
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\App\IApplication.Program.cs
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\App\IApplication.Theme.cs
/ </summary>
    AppTheme Theme { get; set; }

    
/ </summary>
    AppTheme ActualTheme => Theme switch
    {
        AppTheme.FollowingSystem => GetActualThemeByFollowingSystem(),
        AppTheme.Light => AppTheme.Light,
        AppTheme.Dark => AppTheme.Dark,
        _ => DefaultActualTheme,
    };

    
/ </summary>
    protected AppTheme DefaultActualTheme { get; }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static AppTheme GetAppThemeByIsLightOrDarkTheme(bool isLightOrDarkTheme) => isLightOrDarkTheme ? AppTheme.Light : AppTheme.Dark;

    
/ </summary>
    
/ <returns></returns>
    protected AppTheme GetActualThemeByFollowingSystem()
    {
        var dps = IPlatformService.Instance;
        var isLightOrDarkTheme = dps.IsLightOrDarkTheme;
        if (isLightOrDarkTheme.HasValue)
        {
            return GetAppThemeByIsLightOrDarkTheme(isLightOrDarkTheme.Value);
        }
        return DefaultActualTheme;
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\App\IApplication.TrayIcon.cs
/ </summary>
    
/ <param name="menuKey"></param>
    
/ <param name="trayMenuItem"></param>
    void UpdateMenuItems(string menuKey, TrayMenuItem trayMenuItem);
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Attributes\AuthorizeAttribute.cs
/ </summary>
[AttributeUsage(AttributeTargets.Class, Inherited = true)]
public sealed class AuthorizeAttribute : Attribute
{
    public static bool HasAuthorize(object obj)
        => obj.GetType().GetCustomAttributes<AuthorizeAttribute>(true).Any();
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Constants\CertificateConstants.cs
/ </summary>
    public const string CertificateName = "SteamTools";

    public const string RootCertificateName = $"{CertificateName} Certificate";

    
/ </summary>
    public const string PfxFileName = $"{CertificateName}.Certificate{FileEx.PFX}";

    
/ </summary>
    public const string CerFileName = $"{CertificateName}.Certificate{FileEx.CER}";

    
/ </summary>
    public static string CerExportFileName
    {
        get
        {
            var now = DateTime.Now;
            const string f = $"{AssemblyInfo.Trademark}  Certificate {{0}}{FileEx.CER}";
            return string.Format(f, now.ToString(DateTimeFormat.File));
        }
    }

    static string? _AppDataDirectory;

    public static string AppDataDirectory
    {
        get => _AppDataDirectory ?? IOPath.AppDataDirectory;
        set => _AppDataDirectory = value;
    }

    
/ </summary>
    public static string DefaultPfxFilePath => Path.Combine(AppDataDirectory, PfxFileName);

    
/ </summary>
    public static string DefaultCerFilePath => Path.Combine(AppDataDirectory, CerFileName);
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Constants\UrlConstants.cs
/ ReSharper disable once CheckNamespace
namespace BD.WTTS;

[Obsolete("use Constants.Urls/Constants", true)]
public static class UrlConstants
{
    public const string GitHub_User_Rmbadmin = Constants.Urls.GitHub_User_Rmbadmin;
    public const string GitHub_User_AigioL = Constants.Urls.GitHub_User_AigioL;
    public const string GitHub_User_Mossimos = Constants.Urls.GitHub_User_Mossimos;

    public const string Rmbadmin_Email = Constants.Urls.Rmbadmin_Email;

    public const string OfficialWebsite = Constants.Urls.OfficialWebsite;
    public const string OfficialWebsite_Privacy = Constants.Urls.OfficialWebsite_Privacy;
    public const string OfficialWebsite_Agreement = Constants.Urls.OfficialWebsite_Agreement;
    public const string OfficialWebsite_Contact = Constants.Urls.OfficialWebsite_Contact;
    public const string OfficialWebsite_Faq = Constants.Urls.OfficialWebsite_Faq;
    public const string OfficialWebsite_Changelog = Constants.Urls.OfficialWebsite_Changelog;
    public const string OfficialWebsite_Box_Changelog_ = Constants.Urls.OfficialWebsite_Box_Changelog_;
    public const string OfficialWebsite_Box_Faq_ = Constants.Urls.OfficialWebsite_Box_Faq_;
    public const string OfficialWebsite_Box_Privacy = Constants.Urls.OfficialWebsite_Box_Privacy;
    public const string OfficialWebsite_Box_Agreement = Constants.Urls.OfficialWebsite_Box_Agreement;
    public const string OfficialWebsite_LiunxSetupCer = Constants.Urls.OfficialWebsite_LiunxSetupCer;
    public const string OfficialWebsite_UnixHostAccess_ = Constants.Urls.OfficialWebsite_UnixHostAccess_;
    public const string OfficialWebsite_UnixHostAccess = Constants.Urls.OfficialWebsite_UnixHostAccess;
    public const string OfficialWebsite_ApplicationUpdateFailCode_ = Constants.Urls.OfficialWebsite_AppUpdateFailCode_;
    public const string OfficialWebsite_Notice = Constants.Urls.OfficialWebsite_Notice;
    public const string OfficialWebsite_UploadsPublishFiles = Constants.Urls.OfficialWebsite_UploadsPublishFiles;
    public const string OfficialWebsite_UploadsPublish = Constants.Urls.OfficialWebsite_UploadsPublish;

    public const string GitHub_Repository = Constants.Urls.GitHub_Repository;
    public const string Gitee_Repository = Constants.Urls.Gitee_Repository;

    public const string GitHub_Issues = Constants.Urls.GitHub_Issues;
    public const string Gitee_Issues = Constants.Urls.Gitee_Issues;

    public const string License_GPLv3 = Constants.Urls.License_GPLv3;

    public const string MicrosoftStoreId = Constants.MicrosoftStoreId;
    public const string MicrosoftStoreAppWebsite = Constants.Urls.MicrosoftStoreAppWebsite;
    public const string MicrosoftStoreProtocolLink = Constants.Urls.MicrosoftStoreProtocolLink;
    public const string MicrosoftStoreReviewLink = Constants.Urls.MicrosoftStoreReviewLink;

    public const string SponsorUrl_afdian = Constants.Urls.SponsorUrl_afdian;
    public const string SponsorUrl_ko_fi = Constants.Urls.SponsorUrl_ko_fi;
    public const string SponsorUrl_patreon = Constants.Urls.SponsorUrl_patreon;
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Diagnostics\StartWatchTrace.cs
/ </summary>
[Obsolete]
public static class StartWatchTrace
{
    static Stopwatch? sw;
    static StringBuilder? sb;

    public static void Record(string? mark = null, bool dispose = false)
    {
        if (sw != null)
        {
            if (string.IsNullOrEmpty(mark))
            {
                if (dispose) sw.Stop();
                else sw.Restart();
                return;
            }
            sw.Stop();
            var isMobile = !IApplication.IsDesktop();
            if (isMobile)
            {
                sb ??= new();
                sb.AppendFormatLine("init {1} {0}ms", sw.ElapsedMilliseconds, mark);
            }
            else
            {
                var args = string.Join(" ", Environment.GetCommandLineArgs().Skip(1).Take(1));
                var msg = $"{(string.IsNullOrWhiteSpace(args) ? "" : args + " ")}mark: {mark}, value: {sw.ElapsedMilliseconds}";
                Debug.WriteLine(msg);
                Console.WriteLine(msg);
            }
            if (!dispose) sw.Restart();
        }
        else
        {
            sw = Stopwatch.StartNew();
        }
    }

    public static new string ToString() => sb?.ToString() ?? string.Empty;

    public static long ElapsedMilliseconds => sw == null ? 0L : sw.ElapsedMilliseconds;
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Entities\Notification.cs
/ </summary>
[SQLiteTable("A765AD32")]
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public sealed class Notification : IEntity<Guid>
{
    string DebuggerDisplay => Id.ToString();

    [Column("2ABD43F2")]
    [PrimaryKey]
    public Guid Id { get; set; }

    [Column("4557AC21")]
    public DateTimeOffset ExpirationTime { get; set; } = DateTimeOffset.Now;

    [Column("8E7393C5")]
    public bool HasRead { get; set; }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Entities\RequestCache.cs
/ </summary>
    [SQLiteNotNull]
    [Column(ColumnName_UsageTime)]
    public long UsageTime { get; set; } = DateTimeOffset.UtcNow.Ticks;
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Enums\AppEndPoint.cs
/ </summary>
public enum AppEndPoint : byte
{
    LoginOrRegister = 1,
    MessageBox,
    AddAuth,
    ShowAuth,
    AuthTrade,
    EncryptionAuth,
    TextBox,
    TaskBar,
    ExportAuth,
    ScriptStore,
    HideApp,
    EditAppInfo,
    IdleApp,
    ShareManage,
    [Obsolete]
    ChangeBindPhoneNumber,
    UserProfile,
    [Obsolete("not impl", true)]
    NewVersion,
    [Obsolete]
    BindPhoneNumber,
    ASF_AddBot,
    SteamShutdown,
    ProxySettings,
    Notice,
    SaveEditedAppInfo,
    Content,
}

#if DEBUG
[Obsolete("use AppEndPoint", true)]
public enum CustomWindow { }
#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Enums\AppEndPoint.cs
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Enums\AppFolder.cs
/ </summary>
public enum AppFolder : byte
{
    
/ </summary>
    Images,

    
/ </summary>
    Database,

    
/ </summary>
    Cache,
}


/ Enum 扩展 <see cref="AppFolder"/>

/ </summary>
public static class AppFolderEnumExtensions
{
    
/ </summary>
    
/ <param name="folder"></param>
    
/ <returns></returns>
    public static string GetPath(this AppFolder folder)
    {
        var path1 = folder switch
        {
            AppFolder.Images or AppFolder.Cache => IOPath.CacheDirectory,
            AppFolder.Database => IOPath.AppDataDirectory,
            _ => throw new ArgumentOutOfRangeException(nameof(folder), folder, null),
        };
        var path = Path.Combine(path1, folder.ToString());
        IOPath.DirCreateByNotExists(path);
        return path;
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Enums\AppServicesLevel.cs
/ </summary>
[Flags]
public enum AppServicesLevel : uint
{
    
/ </summary>
    Min = 0,

    
/ </summary>
    ServerApiClient = 2,

    
/ </summary>
    UI = 4,

    
/ <see cref="IHttpClientFactory"/> 服务
    
/ </summary>
    HttpClientFactory = 8,

    
/ </summary>
    Hosts = 16,

    
/ </summary>
    AppUpdateAndTrayIcon = 32,

    
/ </summary>
    Steam = 64,

    
/ </summary>
    HttpProxy = 128,

    
/ </summary>
    IPCRoot = 256,

    
/ </summary>
    Repositories = 512,

    
/ </summary>
    MainProcess =
        ServerApiClient |
        UI |
        HttpClientFactory |
        Hosts |
        AppUpdateAndTrayIcon |
        Steam |
        HttpProxy,

    #endregion
}

#if DEBUG
[Obsolete("use AppServicesLevel", true)]
public enum DILevel { }
#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Enums\AppServicesLevel.cs
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Enums\AppTheme.cs
/ </summary>
public enum AppTheme : byte
{
    
/ </summary>
    FollowingSystem,

    
/ 亮色/浅色主题
    
/ </summary>
    Light,

    
/ 暗色/深色主题
    
/ </summary>
    Dark,

    
/ </summary>
    HighContrast,

    
/ </summary>
    [Obsolete("In development…")]
    Custom,
}

public static partial class AppThemeEnumExtensions
{
#if DEBUG
    
/ auto/light/dark
    
/ </summary>
    
/ <param name="value"></param>
    
/ <returns></returns>
    [Obsolete("use ToEnglishString", true)]
    public static string ToString2(this AppTheme value) => value switch
    {
        AppTheme.FollowingSystem => "auto",
        AppTheme.Light => "light",
        AppTheme.HighContrast => "highContrast",
        _ => "dark",
    };

    
/ Resx / AppResources
    
/ </summary>
    
/ <param name="value"></param>
    
/ <returns></returns>
    [Obsolete("use ToDisplayString", true)]
    public static string ToString3(this AppTheme value) => value switch
    {
        AppTheme.FollowingSystem => AppResources.Settings_UI_SystemDefault,
        AppTheme.Light => AppResources.Settings_UI_Light,
        AppTheme.HighContrast => AppResources.Settings_UI_HighContrast,
        _ => AppResources.Settings_UI_Dark,
    };
#endif

    
/ auto/light/dark/highContrast
    
/ </summary>
    
/ <param name="value"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static string ToEnglishString(this AppTheme value) => value switch
    {
        AppTheme.FollowingSystem => "auto",
        AppTheme.Light => "light",
        AppTheme.HighContrast => "highContrast",
        _ => "dark",
    };

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static string ToDisplayString(this AppTheme value) => value switch
    {
        AppTheme.FollowingSystem => AppResources.Settings_UI_SystemDefault,
        AppTheme.Light => AppResources.Settings_UI_Light,
        AppTheme.HighContrast => AppResources.Settings_UI_HighContrast,
        _ => AppResources.Settings_UI_Dark,
    };
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Enums\AppTheme.cs
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Enums\AppWebProxyMode.cs
/ </summary>
public enum AppWebProxyMode : byte
{
    
/ </summary>
    FollowSystem = 0,

    
/ </summary>
    NoProxy,

    
/ </summary>
    Custom,
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Enums\CommandExitCode.cs
/ <inheritdoc cref="HttpStatusCode.OK"/>
    HttpStatusCodeOk = 200,

    
/ <inheritdoc cref="HttpStatusCode.BadRequest"/>
    HttpStatusBadRequest = 400,

    
/ <inheritdoc cref="HttpStatusCode.InternalServerError"/>
    HttpStatusCodeInternalServerError = 500,

    #endregion

    #region xxxx 4 位数通用错误码

    
/ </summary>
    EmptyArrayArgs = 4001,

    
/ </summary>
    EmptyPipeName = 4002,

    
/ </summary>
    EmptyMainProcessId = 4003,

    
/ </summary>
    NotFoundMainProcessId = 4004,

    
/ </summary>
    SubProcessArgumentIndex2ModelIsNull,

    
/ </summary>
    GetPluginsFail = 4040,

    
/ </summary>
    GetPluginFail = 4041,

    
/ </summary>
    GetSubProcessBootConfigurationFail = 4042,

    #endregion
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Enums\EncodingType.cs
/ 自动，在 Windows 上使用 <see cref="UTF8WithBOM"/>，在其他操作系统上使用 <see cref="UTF8"/>
    
/ </summary>
    Auto,

    
/ <para></para>
    
/ 在非 Windows 上此项与 <see cref="UTF8"/> 行为一致。
    
/ </summary>
    ANSICodePage,

    UTF8,

    UTF8WithBOM,
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Enums\NotificationChannelType.cs
/ 通知渠道类型(一个渠道可包含一个或多个<see cref="NotificationType"/>)

/     <term>iOS：</term>

/   </item>

/     <term>Android：将枚举通过 GetChannelId 转换为 <see cref="string"/> 用作 NotificationCompat.Builder 中的 channelId</term>

/   </item>

/     <term>UWP：</term>

/   </item>

/     <term>Win32：</term>

/   </item>

/ </list>

/ <para>添加新的枚举常量注意事项：</para>

/ <para>在<see cref="NotificationType_Channel_EnumExtensions.GetName(NotificationChannelType)"/>中添加渠道名称</para>

/ <para>在<see cref="NotificationType_Channel_EnumExtensions.GetDescription(NotificationChannelType)"/>中添加渠道描述</para>

/ <para>在<see cref="NotificationType_Channel_EnumExtensions.GetImportanceLevel(NotificationChannelType)"/>中添加渠道重要性级别</para>

/ </summary>
public enum NotificationChannelType
{
    
/ <inheritdoc cref="NotificationType.NewVersion"/>
    NewVersion = 2,

    
/ <inheritdoc cref="NotificationType.Announcement"/>
    Announcement,

    
/ <inheritdoc cref="NotificationType.Message"/>
    Message,

    
/ <para><see cref="NotificationType.ProxyForegroundService"/></para>
    
/ <para><see cref="NotificationType.ArchiSteamFarmForegroundService"/></para>
    
/ </summary>
    ForegroundService,
}


/ Enum 扩展 <see cref="NotificationType"/> AND <see cref="NotificationChannelType"/>

/ </summary>
public static partial class NotificationType_Channel_EnumExtensions
{
    
/ </summary>
    
/ <param name="value"></param>
    
/ <returns></returns>
    
/ <exception cref="ArgumentOutOfRangeException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static NotificationChannelType GetChannel(this NotificationType value) => value switch
    {
        NotificationType.Announcement => NotificationChannelType.Announcement,
        NotificationType.NewVersion => NotificationChannelType.NewVersion,
        NotificationType.Message => NotificationChannelType.Message,
        NotificationType.ProxyForegroundService or
        NotificationType.ArchiSteamFarmForegroundService => NotificationChannelType.ForegroundService,
        _ => throw new ArgumentOutOfRangeException(nameof(value), value, null),
    };

    
/ <para>建议的最大长度为40个字符，如果该值太长，可能会被截断</para>
    
/developer.android.google.cn/reference/android/app/NotificationChannel?hl=en#setName%28java.lang.CharSequence%29 </para>
    
/ </summary>
    
/ <exception cref="ArgumentOutOfRangeException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static string GetName(this NotificationChannelType value)
    {
        return value switch
        {
            NotificationChannelType.Announcement => AppResources.NotificationChannelType_Name_Announcement,
            NotificationChannelType.NewVersion => AppResources.NotificationChannelType_Name_NewVersion,
            NotificationChannelType.Message => AppResources.NotificationChannelType_Name_Message,
            NotificationChannelType.ForegroundService => AppResources.NotificationChannelType_Name_ForegroundService,
            _ => throw new ArgumentOutOfRangeException(nameof(value), value, null),
        };
    }

    
/ <para>建议的最大长度为300个字符，如果该值太长，可能会被截断</para>
    
/developer.android.google.cn/reference/android/app/NotificationChannel?hl=en#setDescription%28java.lang.String%29 </para>
    
/ </summary>
    
/ <param name="value"></param>
    
/ <returns></returns>
    
/ <exception cref="ArgumentOutOfRangeException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static string GetDescription(this NotificationChannelType value)
    {
        return value switch
        {
            NotificationChannelType.Announcement => AppResources.NotificationChannelType_Description_Announcement,
            NotificationChannelType.NewVersion => AppResources.NotificationChannelType_Description_NewVersion,
            NotificationChannelType.Message => AppResources.NotificationChannelType_Description_Message,
            NotificationChannelType.ForegroundService => AppResources.NotificationChannelType_Description_ForegroundService,
            _ => string.Empty,
        };
    }

    
/developer.android.google.cn/reference/android/app/NotificationChannel?hl=en#getImportance%28%29 </para>
    
/ </summary>
    
/ <param name="value"></param>
    
/ <returns></returns>
    
/ <exception cref="ArgumentOutOfRangeException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static NotificationImportanceLevel GetImportanceLevel(this NotificationChannelType value)
        => value switch
        {
            NotificationChannelType.Announcement => NotificationImportanceLevel.High,
            _ => NotificationImportanceLevel.Medium,
        };
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Enums\OperationResultType.cs
/ </summary>
[Description("操作结果的枚举")]
public enum OperationResultType
{
    
/ </summary>
    [Description("操作成功。")]
    Success,

    
/ </summary>
    [Description("操作没有引发任何变化，提交取消。")]
    NoChanged,

    
/ </summary>
    [Description("参数错误。")]
    ParamError,

    
/ </summary>
    [Description("指定参数的数据不存在。")]
    QueryNull,

    
/ </summary>
    [Description("当前用户权限不足，不能继续操作。")]
    PurviewLack,

    
/ </summary>
    [Description("登录超时")]
    LoginTimeOut,

    
/ </summary>
    [Description("非法操作。")]
    IllegalOperation,

    
/ </summary>
    [Description("警告")]
    Warning,

    
/ </summary>
    [Description("操作引发错误。")]
    Error,
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Enums\OSExitMode.cs
/ </summary>
public enum OSExitMode : byte
{
    
/ </summary>
    Sleep,

    
/ </summary>
    Hibernate,

    
/ </summary>
    Shutdown,

    
/ </summary>
    Lock,

    
/ </summary>
    Logout,
}

#if DEBUG
[Obsolete("use OSExitMode", true)]
public enum SystemEndMode { }
#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Enums\OSExitMode.cs
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Enums\TextReaderProvider.cs
/ </summary>
public enum TextReaderProvider
{
    
/ </summary>
    Notepad,

    
/ </summary>
    VSCode,
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Enums\UI\ResIcon.cs
/ </summary>
public enum ResIcon
{
    None,
    AvatarDefault,
    AccountBox,
    Info,
    Person,
    Settings,
    SportsEsports,
    VerifiedUser,
    Steam,
    Xbox,
    Apple,
    QQ,
    Phone,
    Attach,
    Contact,
    OpenFile,

    
/ </summary>
    PlatformPhone,
    Exit,
}

public static class ResIconEnumExtensions
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ResIcon ToIcon(this ExternalLoginChannel fastLoginChannel)
        => fastLoginChannel switch
        {
            ExternalLoginChannel.Steam => ResIcon.Steam,
            ExternalLoginChannel.Microsoft => ResIcon.Xbox,
            ExternalLoginChannel.QQ => ResIcon.QQ,
            ExternalLoginChannel.Apple => ResIcon.Apple,
            _ => throw new ArgumentOutOfRangeException(nameof(fastLoginChannel), fastLoginChannel, null),
        };
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Enums\UI\ResizeMode.cs
/ </summary>
public enum ResizeMode : byte
{
    
/ </summary>
    NoResize,

    
/ </summary>
    CanMinimize,

    
/ </summary>
    CanResize,

    
/ 此选项具有与相同的功能 <see cref="CanResize"/> ，但会将 "调整手柄" 添加到窗口的右下角。
    
/ </summary>
    [Obsolete("not implemented")]
    CanResizeWithGrip,
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Extensions\ApiRspImplHandleUIExtensions.cs
/ <see cref="ApiRspImpl"/> 的扩展函数

/ </summary>
public static class ApiRspImplHandleUIExtensions
{
    const string TAG = "HandleUI";

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static void LogError(this ApiRspBase apiRsp, string message)
    {
        var url = string.IsNullOrWhiteSpace(apiRsp.Url) ? null : apiRsp.Url.Split('?', StringSplitOptions.RemoveEmptyEntries).FirstOrDefault();
        Log.Error(TAG, apiRsp.ClientException, "message: {message}, url: {url}", message, url);
    }

    
/ UI 上处理 <see cref="ApiRspImpl"/>，失败时显示错误消息
    
/ </summary>
    
/ <param name="apiRsp"></param>
    
/ <param name="icon"></param>
    
/ <param name="errorAppendText"></param>
    
/ <param name="errorFormat"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool HandleUI(this ApiRspBase apiRsp, ToastIcon icon = ToastIcon.Error, string? errorAppendText = null, string? errorFormat = null)
    {
        if (!apiRsp.IsSuccess)
        {
            
/ UI 上处理 <see cref="ApiRspImpl{TContent}"/>，失败时显示错误消息
    
/ <para>Content 为 <see langword="null"/> 时，显示 <see cref="ApiRspCode.NoResponseContent"/></para>
    
/ <para>Content 为 <see cref="IExplicitHasValue"/> 且验证失败时，显示 <see cref="ApiRspCode.NoResponseContentValue"/></para>
    
/ </summary>
    
/ <typeparam name="TContent"></typeparam>
    
/ <param name="apiRsp"></param>
    
/ <param name="content"></param>
    
/ <param name="icon"></param>
    
/ <param name="errorAppendText"></param>
    
/ <param name="errorFormat"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool HandleUI<TContent>(this ApiRsp<TContent> apiRsp,
       [NotNullWhen(true)] out TContent? content, ToastIcon icon = ToastIcon.Error, string? errorAppendText = null, string? errorFormat = null)
    {
        
/ UI 上处理 <see cref="ApiRspImpl{TContent}"/>，失败时显示错误消息，Content 允许为 <see langword="null"/>
    
/ </summary>
    
/ <typeparam name="TContent"></typeparam>
    
/ <param name="apiRsp"></param>
    
/ <param name="content"></param>
    
/ <param name="icon"></param>
    
/ <param name="errorAppendText"></param>
    
/ <param name="errorFormat"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool HandleUIAllowNull<TContent>(this ApiRsp<TContent> apiRsp,
       out TContent? content, ToastIcon icon = ToastIcon.Error, string? errorAppendText = null, string? errorFormat = null)
    {
        
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Extensions\CompositeDisposableExtensions.cs
/learn.microsoft.com/zh-cn/dotnet/standard/garbage-collection/implementing-disposeasync#implement-both-dispose-and-async-dispose-patterns

        IDisposable? _disposableResource;
        IAsyncDisposable? _asyncDisposableResource;

        public AsyncDisposable(IDisposable? disposableResource)
        {
            _disposableResource = disposableResource;
        }

        public AsyncDisposable(IAsyncDisposable? asyncDisposableResource)
        {
            _asyncDisposableResource = asyncDisposableResource;
        }

        public AsyncDisposable(Func<ValueTask>? dispose) : this(Nito.Disposables.AnonymousAsyncDisposable.Create(dispose))
        {

        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        public async ValueTask DisposeAsync()
        {
            await DisposeAsyncCoreAsync().ConfigureAwait(false);

            Dispose(disposing: false);
            GC.SuppressFinalize(this);
        }

        void Dispose(bool disposing)
        {
            if (disposing)
            {
                _disposableResource?.Dispose();
                (_asyncDisposableResource as IDisposable)?.Dispose();
                _disposableResource = null;
                _asyncDisposableResource = null;
            }
        }

        async ValueTask DisposeAsyncCoreAsync()
        {
            if (_asyncDisposableResource is not null)
            {
                await _asyncDisposableResource.DisposeAsync().ConfigureAwait(false);
            }

            if (_disposableResource is IAsyncDisposable disposable)
            {
                await disposable.DisposeAsync().ConfigureAwait(false);
            }
            else
            {
                _disposableResource?.Dispose();
            }

            _asyncDisposableResource = null;
            _disposableResource = null;
        }
    }
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Extensions\CompositeDisposableExtensions.cs
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Extensions\ProcessExtensions.cs
/ 为 <see cref="Process"/> 类型提供扩展方法

/ </summary>
public static class ProcessExtensions
{
    
/ <inheritdoc cref="IPlatformService.GetCommandLineArgs(Process)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static string GetCommandLineArgs(this Process process)
    {
        try
        {
            return IPlatformService.Instance.GetCommandLineArgs(process);
        }
        catch
        {
            
发现 Windows 特有的库：../SteamTools\src\BD.WTTS.Client\Extensions\Platform\ServiceCollectionExtensions.PlatformService.cs
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Extensions\Platform\ServiceCollectionExtensions.PlatformService.cs
WINDOWS
LINUX
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Extensions\Platform\Windows\ServiceCollectionExtensions.AddScheduledTaskService.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Extensions\Security\ServiceCollectionExtensions.AddSecurityService.cs
/ </summary>
    
/ <param name="services"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IServiceCollection AddSecurityService(this IServiceCollection services)
    {
        services.AddSecurityService<EmbeddedAesDataProtectionProvider, LocalDataProtectionProvider>();
        return services;
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Extensions\ServiceCollection\ServiceCollectionExtensions.AddGeneralLogging.cs
/ </summary>
    
/ <param name="services"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IServiceCollection AddGeneralLogging(this IServiceCollection services)
    {
        
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Extensions\ServiceCollection\ServiceCollectionExtensions.AddHostsFileService.cs
/ </summary>
    
/ <param name="services"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IServiceCollection AddHostsFileService(this IServiceCollection services)
    {
        services.AddSingleton<IHostsFileService, HostsFileServiceImpl>();
        return services;
    }
#endif
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Extensions\ServiceCollection\ServiceCollectionExtensions.AddViewModelManager.cs
/ 添加 <see cref="IViewModelManager"/>
    
/ </summary>
    
/ <param name="services"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IServiceCollection AddViewModelManager(this IServiceCollection services)
    {
        services.AddSingleton<IViewModelManager, ViewModelManager>();
        return services;
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Extensions\ServiceCollection\ServiceCollectionExtensions.TryAddClientHttpPlatformHelperService.cs
/ 添加适用于客户端的 <see cref="IHttpPlatformHelperService"/>
    
/ </summary>
    
/ <param name="services"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IServiceCollection TryAddClientHttpPlatformHelperService(this IServiceCollection services)
    {
        services.TryAddSingleton<IHttpPlatformHelperService, ClientHttpPlatformHelperServiceImpl>();
        return services;
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Extensions\ServiceCollection\ServiceCollectionExtensions.TryAddImageHttpClientService.cs
/ 添加适用于客户端的 <see cref="IImageHttpClientService"/>
    
/ </summary>
    
/ <param name="services"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IServiceCollection TryImageHttpClientService(this IServiceCollection services)
    {
        services.TryAddSingleton<IImageHttpClientService, ImageHttpClientService>();
        return services;
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Extensions\ServiceCollection\ServiceCollectionExtensions.TryAddMicroServiceClient.cs
/ </summary>
    
/ <param name="services"></param>
    
/ <param name="config"></param>
    
/ <param name="configureHandler"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IServiceCollection TryAddMicroServiceClient(
        this IServiceCollection services)
    {
        services.AddSingleton<MSC_IMPL>();
        services.TryAddSingleton<MicroServiceClientBase>(s => s.GetRequiredService<MSC_IMPL>());
        services.TryAddSingleton<IApiConnectionPlatformHelper>(s => s.GetRequiredService<MSC_IMPL>());
        services.TryAddSingleton<IMicroServiceClient>(s => s.GetRequiredService<MSC_IMPL>());
        
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Extensions\ServiceCollection\ServiceCollectionExtensions.TryAddNotificationService.cs
/ 尝试添加由 NotifyIcon 实现的 <see cref="INotificationService"/>
    
/ </summary>
    
/ <param name="services"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IServiceCollection TryAddNotificationService(this IServiceCollection services)
    {
        services.TryAddSingleton<INotificationService, NotificationServiceImpl>();
        return services;
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Extensions\ServiceCollection\ServiceCollectionExtensions.TryAddToast.cs
/ 尝试添加使用 <see cref="ToastService"/> 实现的 <see cref="IToast"/>
    
/ </summary>
    
/ <param name="services"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IServiceCollection TryAddToast(this IServiceCollection services)
        => ToastImpl.TryAddToast(services);
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Extensions\Steam\CurrencyCodeEnumExtensions.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Extensions\Steam\ServiceCollectionExtensions.AddSteamService.cs
/ </summary>
    
/ <param name="services"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IServiceCollection AddSteamService2(this IServiceCollection services)
    {
        services.AddSingleton<ISteamService, SteamServiceImpl2>();
        return services;
    }
#endif
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\FileSystem\LinuxFileSystem.cs
/ <para>XDG Base Directory Specification</para>

/specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html</para>

/wiki.archlinux.org/title/XDG_Base_Directory</para>

/ <item>AppData: $XDG_DATA_HOME/Steam++ or $HOME/.local/share/Steam++</item>

/ <item>Cache: $XDG_CACHE_HOME/Steam++ or $HOME/.cache/Steam++</item>

/ <item>Logs: $XDG_CACHE_HOME/Steam++/Logs or $HOME/.cache/Steam++/Logs</item>

/ </list>

/ </summary>
sealed class LinuxFileSystem : IOPath.FileSystemBase
{
    private LinuxFileSystem() => throw new NotSupportedException();

    
/ <inheritdoc cref="FileSystem2.InitFileSystem"/>
    public static void InitFileSystem()
    {
        var appDataDirectory = AppDataDirectory;
        var cacheDirectory = CacheDirectory;
        IOPath.DirCreateByNotExists(appDataDirectory);
        IOPath.DirCreateByNotExists(cacheDirectory);

        InitFileSystemWithMigrations(
            appDataDirectory,
            cacheDirectory,
            FileSystem2.BaseDirectory.AppDataDirectory,
            FileSystem2.BaseDirectory.CacheDirectory);
    }

    static string AppDataDirectory
    {
        get
        {
            var value = Environment.GetEnvironmentVariable(XDG_DATA_HOME);
            if (!string.IsNullOrWhiteSpace(value))
            {
                return Path.Combine(value, Constants.HARDCODED_APP_NAME);
            }
            value = Environment.GetEnvironmentVariable(HOME);
            if (!string.IsNullOrWhiteSpace(value))
            {
                return Path.Combine(value, ".local", "share", Constants.HARDCODED_APP_NAME);
            }
            throw new PlatformNotSupportedException();
        }
    }

    static string CacheDirectory
    {
        get
        {
            var value = Environment.GetEnvironmentVariable(XDG_CACHE_HOME);
            if (!string.IsNullOrWhiteSpace(value))
            {
                return Path.Combine(value, Constants.HARDCODED_APP_NAME);
            }
            value = Environment.GetEnvironmentVariable(HOME);
            if (!string.IsNullOrWhiteSpace(value))
            {
                return Path.Combine(value, ".cache", Constants.HARDCODED_APP_NAME);
            }
            throw new PlatformNotSupportedException();
        }
    }

    const string HOME = "HOME";

    const string XDG_DATA_HOME = "XDG_DATA_HOME";

    const string XDG_CACHE_HOME = "XDG_CACHE_HOME";
}
#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\FileSystem\LinuxFileSystem.cs
LINUX
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\FileSystem\MacCatalystFileSystem.cs
/ <item>AppData: ~/Library/Steam++</item>

/ <item>Cache: ~/Library/Caches/Steam++</item>

/ <item>Logs: ~/Library/Caches/Steam++/Logs</item>

/ </list>

/ </summary>
sealed class MacCatalystFileSystem : IOPath.FileSystemBase
{
    private MacCatalystFileSystem() => throw new NotSupportedException();

    
/ <inheritdoc cref="FileSystem2.InitFileSystem"/>
    public static void InitFileSystem()
    {
        
/github.com/xamarin/Essentials/blob/main/Xamarin.Essentials/FileSystem/FileSystem.ios.tvos.watchos.macos.cs
        var appDataPath = Path.Combine(GetDirectory(NSSearchPathDirectory.LibraryDirectory), Constants.HARDCODED_APP_NAME);
        var cachePath = Path.Combine(GetDirectory(NSSearchPathDirectory.CachesDirectory), Constants.HARDCODED_APP_NAME);
        IOPath.DirCreateByNotExists(appDataPath);
        IOPath.DirCreateByNotExists(cachePath);
        InitFileSystem(GetAppDataDirectory, GetCacheDirectory);
        string GetAppDataDirectory() => appDataPath;
        string GetCacheDirectory() => cachePath;
    }

    static string GetDirectory(NSSearchPathDirectory directory)
    {
        var dirs = NSSearchPath.GetDirectories(directory, NSSearchPathDomain.User);
        if (dirs == null || dirs.Length == 0)
        {
            
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\FileSystem\MacCatalystFileSystem.cs
MACOS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\FileSystem\WindowsFileSystem.cs
/ <item>AppData: \AppData or %LocalAppData%\Steam++</item>

/ <item>Cache: \Cache or %Tmp%\Steam++</item>

/ <item>Logs: \Logs or %Tmp%\Steam++\Logs</item>

/ </list>

/ </summary>
sealed class WindowsFileSystem : IOPath.FileSystemBase
{
    private WindowsFileSystem() => throw new NotSupportedException();

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static void TryDeleteRootPathObsoleteFiles()
    {
        
/ <inheritdoc cref="FileSystem2.InitFileSystem"/>
    public static void InitFileSystem()
    {
        var isPrivilegedProcess = WindowsPlatformServiceImpl.IsPrivilegedProcess;
        if (isPrivilegedProcess)
        {
            TryDeleteRootPathObsoleteFiles();
        }

        if (WindowsPlatformServiceImpl.CurrentAppIsInstallVersion)
        {
            /* 安装版将使用以下路径，但如果根目录上有文件夹则会优先使用根目录上的文件夹(从 2.7.0+ 开始)
             * Environment.SpecialFolder.LocalApplicationData
             * Path.GetTempPath()
             */
            InitFileSystemByInstallVersion();
            return;
        }
        FileSystem2.InitFileSystem();
    }

    
/ </summary>
    
/ <param name="destAppDataPath">新的 AppData 文件夹路径</param>
    
/ <param name="destCachePath">新的 Cache 文件夹路径</param>
    
/ <param name="sourceAppDataPath">旧的 AppData 文件夹路径</param>
    
/ <param name="sourceCachePath">旧的 Cache 文件夹路径</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static void InitFileSystemByInstallVersion()
    {
        var appDataDirectory = AppDataDirectory;
        var cacheDirectory = CacheDirectory;
        IOPath.DirCreateByNotExists(appDataDirectory);
        IOPath.DirCreateByNotExists(cacheDirectory);

        DirectoryInfo oldAppDataDirectoryInfo = new(FileSystem2.BaseDirectory.AppDataDirectory);
        if (oldAppDataDirectoryInfo.Exists)
        {
            static void EnumerateDbFiles(
                string oldAppData,
                string newAppData,
                string[] dbFiles)
            {
                var item = dbFiles[0];
                var dbFilePath = Path.Combine(oldAppData, item);
                if (File.Exists(dbFilePath))
                {
                    var destFilePath = Path.Combine(newAppData, item);
                    var hashFilePath = destFilePath + "_hash.tmp";

                    
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\FileSystem\WindowsFileSystem.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\FileSystem\WindowsRuntimeFileSystem.cs
/ <item>AppData: %USERPROFILE%\AppData\Local\Packages\4651ED44255E.47979655102CE_k6txddmbb6c52\LocalState</item>

/ <item>Cache: %USERPROFILE%\AppData\Local\Packages\4651ED44255E.47979655102CE_k6txddmbb6c52\LocalCache</item>

/ <item>Logs: %USERPROFILE%\AppData\Local\Packages\4651ED44255E.47979655102CE_k6txddmbb6c52\LocalCache\Logs</item>

/ </list>

/ </summary>
sealed class WindowsRuntimeFileSystem : IOPath.FileSystemBase
{
    private WindowsRuntimeFileSystem() => throw new NotSupportedException();

    
/ <inheritdoc cref="FileSystem2.InitFileSystem"/>
    public static void InitFileSystem()
    {
        
/github.com/xamarin/Essentials/blob/1.6.1/Xamarin.Essentials/FileSystem/FileSystem.uwp.cs#L12
        
/docs.microsoft.com/zh-cn/windows/msix/desktop/desktop-to-uwp-behind-the-scenes
        
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\FileSystem\WindowsRuntimeFileSystem.cs
WINDOWS
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Helpers\DesktopBridgeHelper.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Helpers\DotNetRuntimeHelper.cs
/learn.microsoft.com/zh-cn/dotnet/core/tools/dotnet-environment-variables#net-sdk-and-cli-environment-variables

    const string EnvName_DotNetRoot = "DOTNET_ROOT";
    
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Helpers\GlobalDllImportResolver.cs
/learn.microsoft.com/zh-cn/dotnet/standard/native-interop/cross-platform#custom-import-resolver</para>

/ <para>本机库放入 .\native\win-x64\xxx.dll</para>

/learn.microsoft.com/zh-cn/nuget/create-packages/supporting-multiple-target-frameworks#architecture-specific-folders</para>

/ </summary>
public static partial class GlobalDllImportResolver
{
#if DEBUG
    
/ <inheritdoc cref="RID"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static string GetRID()
    {
#if WINDOWS
        return RuntimeInformation.ProcessArchitecture switch
        {
            Architecture.X86 => "win-x86",
            Architecture.X64 => "win-x64",
            Architecture.Arm64 => "win-arm64",
            _ => throw new PlatformNotSupportedException(),
        };
#elif MACCATALYST || MACOS
        return RuntimeInformation.ProcessArchitecture switch
        {
            Architecture.X64 => "osx-x64", 
/learn.microsoft.com/zh-cn/dotnet/core/rid-catalog
    
/ </summary>
    public static readonly string RID = GetRID();

    static string? _BaseDirectory;

    
/ <inheritdoc cref="AppContext.BaseDirectory"/>
    public static string BaseDirectory
    {
        get => _BaseDirectory ?? AppContext.BaseDirectory;
        set => _BaseDirectory = value;
    }

    
/ </summary>
    public static void MoveFiles()
    {
        
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Helpers\GlobalDllImportResolver.cs
WINDOWS
DEBUG
WINDOWS
WINDOWS
DEBUG
LINUX
DEBUG
DEBUG
LINUX
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Helpers\GlobalDllImportResolver.LibraryName.cs
/ </summary>
    internal const string e_sqlite3 = "e_sqlite3";

    
/ </summary>
    internal const string libSkiaSharp = "libSkiaSharp";

    
/ </summary>
    internal const string libHarfBuzzSharp = "libHarfBuzzSharp";

#if WINDOWS || TOOL_PUBLISH

    
/ </summary>
    internal const string av_libGLESv2 = "av_libGLESv2";

    
/ </summary>
    internal const string WebView2Loader = "WebView2Loader";

    
/ </summary>
    internal const string WinDivert = "WinDivert";

    
/ </summary>
    internal const string WinDivert32 = "WinDivert32";

    
/ </summary>
    internal const string WinDivert64 = "WinDivert64";

    
/ </summary>
    internal const string _7z = "7z";

    internal const string xunyoucall64 = "xunyoucall64";
#endif

    static IEnumerable<string> GetLibraryNames()
    {
        yield return e_sqlite3;
        yield return libSkiaSharp;
        yield return libHarfBuzzSharp;
#if WINDOWS || TOOL_PUBLISH
        yield return av_libGLESv2;
        yield return WebView2Loader;
        yield return WinDivert;
        yield return _7z;
        yield return xunyoucall64;
#endif
    }

#pragma warning disable SA1304 
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Helpers\GlobalDllImportResolver.LibraryName.cs
WINDOWS
WINDOWS
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Helpers\IcoEncoder.cs
/ </summary>
public static class IcoEncoder
{
    public static void Encode(Stream stream, IReadOnlyList<SKBitmap> bitmaps)
    {
        
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Helpers\Interop.cs
MACCATALYST
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Helpers\MouseHook.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Helpers\ReflectionHelper.cs
/ </summary>
    
/ <param name="thisAssembly"></param>
    
/ <param name="stackTrace"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsInternalCall(Assembly thisAssembly, StackTrace stackTrace)
    {
        if (stackTrace.FrameCount >= 1)
        {
            for (int i = 1; i < stackTrace.FrameCount; i++)
            {
                try
                {
                    var method = stackTrace.GetFrame(i)?.GetMethod();
                    var assembly = method?.Module.Assembly;
                    if (assembly == thisAssembly)
                    {
                        return true;
                    }
                }
                catch
                {

                }
                if (i == 2)
                    break;
            }
        }
        return false;
    }

    
/ <inheritdoc cref="IsInternalCall(Assembly, StackTrace)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsInternalCall<T>(StackTrace stackTrace)
        => IsInternalCall(typeof(T).Assembly, stackTrace);
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Helpers\SystemUtility.cs
/github.com/microsoft/nodejstools/blob/main/Nodejs/Product/Nodejs/SharedProject/SystemUtilities.cs


/ </summary>
static class SystemUtility
{
    
/ </summary>
    internal static void ExecuteProcessUnElevated(string process, string args, string currentDirectory = "")
    {
        var shellWindows = (IShellWindows)new CShellWindows();

        
/ </summary>
    private const int CSIDL_Desktop = 0;
    private const int SWC_DESKTOP = 8;
    private const int SWFO_NEEDDISPATCH = 1;
    private const int SW_SHOWNORMAL = 1;
    private const int SVGIO_BACKGROUND = 0;
    private static readonly Guid SID_STopLevelBrowser = new("4C96BE40-915C-11CF-99D3-00AA004AE837");

    [ComImport]
    [Guid("9BA05972-F6A8-11CF-A442-00A0C90A8F39")]
    [ClassInterface(ClassInterfaceType.None)]
    private class CShellWindows
    {
    }

    [ComImport]
    [Guid("85CB6900-4D95-11CF-960C-0080C7F4EE85")]
    [InterfaceType(ComInterfaceType.InterfaceIsIDispatch)]
    private interface IShellWindows
    {
        [return: MarshalAs(UnmanagedType.IDispatch)]
        object FindWindowSW([MarshalAs(UnmanagedType.Struct)] ref object pvarloc, [MarshalAs(UnmanagedType.Struct)] ref object pvarlocRoot, int swClass, out int pHWND, int swfwOptions);
    }

    [ComImport]
    [Guid("6d5140c1-7436-11ce-8034-00aa006009fa")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    private interface IServiceProvider
    {
        [return: MarshalAs(UnmanagedType.Interface)]
        object QueryService(ref Guid guidService, ref Guid riid);
    }

    [ComImport]
    [Guid("000214E2-0000-0000-C000-000000000046")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    private interface IShellBrowser
    {
        void VTableGap01(); 
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Helpers\SystemUtility.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Helpers\TracepointHelper.cs
/ </summary>
static partial class TracepointHelper
{
    
/ 属性键/名称不能为空，最大允许键长度 = 125
    
/learn.microsoft.com/zh-cn/appcenter/sdk/analytics/windows#custom-events
    
/ </summary>
    
/ <param name="name">事件名称（可定义枚举值，最多不超过 200 个名称）</param>
    
/ <param name="properties">可选属性</param>
    public static void TrackEvent(string name, IDictionary<string, string>? properties = null)
    {
        Analytics.TrackEvent(name, properties!);
    }
}

发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Helpers\TracepointHelper.cs
USE
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Helpers\UnixHelper.RunShell.cs
/ <inheritdoc cref="IPlatformService.RunShellAsync(string, bool)"/>
    public static ValueTask RunShellAsync(string script, bool requiredAdministrator)
        => RunShellAsync(script, requiredAdministrator, 3);

    
/ <inheritdoc cref="IPlatformService.RunShellAsync(string, bool)"/>
    static async ValueTask RunShellAsync(string script, bool requiredAdministrator, sbyte retry)
    {
        if (retry <= 0) return;
        var scriptContent = new StringBuilder();
        if (requiredAdministrator)
        {
            TextBoxWindowViewModel vm = new()
            {
                Title = AppResources.UnixSudoPasswordTips,
                InputType = TextBoxWindowViewModel.TextBoxInputType.Password,
                Description = $"sudo {script}",
            };
            await TextBoxWindowViewModel.ShowDialogAsync(vm);
            if (string.IsNullOrWhiteSpace(vm.Value))
                return;
            scriptContent.AppendLine($"echo \"{vm.Value}\" | sudo -S {script}");
        }
        scriptContent.AppendLine(script);
        var msg = RunShell(scriptContent.ToString());
        if (!string.IsNullOrWhiteSpace(msg))
            Toast.Show(ToastIcon.None, msg);
    }

    
/ </summary>
    
/ <param name="shell">脚本指令</param>
    
/ <returns>返回结果</returns>
    public static string RunShell(string shell)
        => Process2.RunShell(Process2.BinBash, shell, e => e.LogAndShowT(TAG));
}
#endif
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Helpers\Compression\TarGZipHelper.cs
/ </summary>
    
/ <param name="filePath">要创建的文件路径</param>
    
/ <param name="dirPath">要打包的目录</param>
    
/ <param name="level">压缩等级，取值范围在 <see cref="Deflater.NO_COMPRESSION"/> ~ <see cref="Deflater.BEST_COMPRESSION"/></param>
    
/ <param name="progress">进度值监听</param>
    
/ <returns></returns>
    public static bool Create(string filePath, string dirPath, int level = Deflater.BEST_COMPRESSION, ProgressMessageHandler? progress = null)
    {
        if (!filePath.EndsWith(FileEx.TAR_GZ)) filePath += FileEx.TAR_GZ;
        if (File.Exists(filePath)) return false;
        if (!Directory.Exists(dirPath)) return false;

        using var fs = File.Create(filePath);
        using var s = new GZipOutputStream(fs);
        s.SetLevel(level);
        using var archive = TarArchive.CreateOutputTarArchive(s, TarBuffer.DefaultBlockFactor, EncodingCache.UTF8NoBOM);
        if (progress != null) archive.ProgressMessageEvent += progress;

        HandleFiles(dirPath);
        HandleDirs(dirPath);

        void HandleFiles(string dirPath_)
        {
            foreach (var file in Directory.GetFiles(dirPath_))
            {
                var entry = TarEntry.CreateEntryFromFile(file);
                entry.Name = file.TrimStart(dirPath).Trim(Path.DirectorySeparatorChar);
                if (Path.DirectorySeparatorChar != IOPath.UnixDirectorySeparatorChar)
                    entry.Name = entry.Name.Replace(Path.DirectorySeparatorChar, IOPath.UnixDirectorySeparatorChar);
                archive.WriteEntry(entry, false);
            }
        }

        void HandleDirs(string dirPath_)
        {
            foreach (var dir in Directory.GetDirectories(dirPath_))
            {
                HandleFiles(dir);
            }
        }

        return true;
    }

    
/ </summary>
    
/ <param name="filePath">要解压的压缩包文件路径</param>
    
/ <param name="dirPath">要解压的文件夹路径，文件夹必须不存在</param>
    
/ <param name="progressMessage">进度消息监听</param>
    
/ <param name="progress">进度值监听</param>
    
/ <param name="maxProgress"></param>
    
/ <returns></returns>
    public static bool Unpack(string filePath, string dirPath,
        ProgressMessageHandler? progressMessage = null,
        IProgress<float>? progress = null,
        float maxProgress = 100f)
    {
        if (!File.Exists(filePath)) return false;
        if (Directory.Exists(dirPath)) return false;

        using var fs = File.OpenRead(filePath);
        
/github.com/icsharpcode/SharpZipLib/blob/v1.3.1/src/ICSharpCode.SharpZipLib/Zip/Compression/Streams/InflaterInputStream.cs#L542
        float length = fs.Length;
        var isFinish = false;
        CancellationTokenSource? cts = null;
        async void ProgressMonitor()
        {
            try
            {
                while (!isFinish)
                {
                    var value = fs.Position / length * maxProgress;
                    progress!.Report(value);
                    await Task.Delay(200, cts.Token);
                }
            }
            catch (OperationCanceledException)
            {
            }
        }
        Directory.CreateDirectory(dirPath);
        using var s = new GZipInputStream(fs);
        using var archive = TarArchive.CreateInputTarArchive(s, EncodingCache.UTF8NoBOM);
        if (progressMessage != null) archive.ProgressMessageEvent += progressMessage;
        var hasProgress = progress != null;
        if (hasProgress)
        {
            cts = new();
            try
            {
                Task.Factory.StartNew(ProgressMonitor, cts.Token);
            }
            catch (OperationCanceledException)
            {
            }
        }
        archive.ExtractContents(dirPath);
        isFinish = true;
        if (hasProgress)
        {
            cts!.Cancel();
            progress!.Report(maxProgress);
        }
        return true;
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Helpers\UI\ImageUrlHelper.cs
/ </summary>
    const string GetImageApiUrl = "{1}/api/image/{0}";

    
/ </summary>
    
/ <param name="imageId"></param>
    
/ <returns></returns>
    public static string? GetImageApiUrlById(Guid imageId) => imageId == default ? default : string.Format(GetImageApiUrl, imageId, IMicroServiceClient.Instance.ApiBaseUrl);
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Helpers\UI\QRCodeHelper.cs
/ </summary>
    public enum QRCodeCreateResult
    {
        Success,
        DataTooLong,
        Exception,
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Helpers\UI\QRCodeHelper.Net.Codecrete.QrCodeGenerator.SkiaSharp.cs
/github.com/manuelbl/QrCodeGenerator
 * Copyright (c) 2021 Manuel Bleichenbacher
 * Licensed under MIT License
 * https:
/opensource.org/licenses/MIT
 */

using SkiaSharp;


发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Helpers\UI\SendSmsUIHelper.cs
/ </summary>
    
/ <param name="i"></param>
    public static void RemoveAllDelegate(this IViewModel i)
    {
        i.TbPhoneNumberFocus = null;
        i.TbSmsCodeFocus = null;
    }
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Helpers\UI\SendSmsUIHelper.cs
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Helpers\UI\ThirdPartyLoginHelper.cs
/ </summary>
public static class ThirdPartyLoginHelper
{
#if DEBUG
    static readonly bool UseLoopbackTest = false;
#endif

    public interface IBindWindowViewModel
    {
        void OnBindSuccessed();
    }

    public static ICommand ManualLogin { get; }
        = ReactiveCommand.CreateFromTask(ManualLoginAsync);

    
/ </summary>
    
/ <returns></returns>
    static async Task ManualLoginAsync()
    {
        await MainThread2.InvokeOnMainThreadAsync(async () =>
        {
            TextBoxWindowViewModel modelvm = new()
            {
                Title = AppResources.LoginInputManualLoginToken,
                InputType = TextBoxWindowViewModel.TextBoxInputType.TextBox,
            };
            await TextBoxWindowViewModel.ShowDialogAsync(modelvm);
            if (string.IsNullOrWhiteSpace(modelvm.Value))
            {
                if (modelvm.Value != null)
                {
                    Toast.Show(ToastIcon.Warning, AppResources.Login_ManualLoginEmpt);
                }
                return;
            }
            else
            {
                await LoginForStr(modelvm.Value);
            }
        });
    }

    
/ </summary>
    
/ <param name="msg"></param>
    
/ <param name="socket"></param>
    
/ <returns></returns>
    public static async Task LoginForStr(string msg, IWebSocketConnection? socket = null)
    {
        if (tempAes == null) return;
        if (string.IsNullOrWhiteSpace(msg)) return;
        var conn_helper = Ioc.Get<IApiConnectionPlatformHelper>();
        try
        {
            var byteArray = msg.Base64UrlDecodeToByteArray();
            try
            {
                byteArray = tempAes.Decrypt(byteArray);
            }
            catch
            {
                Toast.Show(ToastIcon.Error, AppResources.Login_WebSocketOnMessage);
                return;
            }
            var rsp = ApiRspHelper.Deserialize<LoginOrRegisterResponse>(byteArray);
            var webRsp = new WebResponseDTO();
            if (rsp.IsSuccess && rsp.Content == null)
            {
                webRsp.Msg = ApiRspExtensions.GetMessage(ApiRspCode.NoResponseContent);
                if (socket != null)
                    await socket.Send(JsonSerializer.Serialize(webRsp));
                else
                    Toast.Show(ToastIcon.None, webRsp.Msg);
                return;
            }
            webRsp.State = rsp.IsSuccess;
            if (socket != null)
                await socket.Send(JsonSerializer.Serialize(webRsp)); 
/ </summary>
    public static void DisposeServer()
    {
        serverDisposable?.Dispose();
        serverDisposable = null;
    }

    static Aes? tempAes;
    static bool isBind;
    static WindowViewModel? vm;

    
/ </summary>
    static WebSocketServer? ws;

    
/ </summary>
    static int port;

    
/ </summary>
    
/ <param name="vm"></param>
    
/ <param name="channel"></param>
    
/ <param name="isBind"></param>
    
/ <returns></returns>
    public static async Task StartAsync(WindowViewModel vm, ExternalLoginChannel channel, bool isBind)
    {
        var app = IApplication.Instance;
        if (!OperatingSystem2.IsAndroid() && !OperatingSystem2.IsIOS() && !OperatingSystem2.IsMacOS())
        {
            
/ Android/iOS 使用 URL Scheme 回调
            StartServer(app);
        }
        var conn_helper = Ioc.Get<IApiConnectionPlatformHelper>();
        var apiBaseUrl = IMicroServiceClient.Instance.ApiBaseUrl;
#if DEBUG
        if (UseLoopbackTest) apiBaseUrl = "https:
/var version = csc.Settings.AppVersionStr;
        var ver = AssemblyInfo.Version.Base64UrlEncode();
        var qs = HttpUtility.ParseQueryString("");
        qs.Add("port", port.ToString());
        qs.Add("sKeyHex", skey_str);
        qs.Add("sKeyPadding", padding.OaepHashAlgorithm.ToString());
        qs.Add("ver", ver);
        qs.Add("isBind", isBind.ToString());
        qs.Add("access_token_expires_hex", access_token_expires);
        qs.Add("access_token_hex", access_token);
        qs.Add("dg", DeviceIdHelper.DeviceIdG.ToStringN());
        qs.Add("dr", DeviceIdHelper.DeviceIdR);
        qs.Add("dn", DeviceIdHelper.DeviceIdN);
        if (OperatingSystem2.IsMacOS())
        {
            qs.Add("isUS", "true");
        }
        var ub = new UriBuilder(apiBaseUrl)
        {
            Path = $"/identity/v1/externallogin/{(int)channel}",
            Query = qs.ToString(),
        };

        await Browser2.OpenAsync(ub.Uri, BrowserLaunchMode.External);
    }

    
/ </summary>
    public sealed class WebResponseDTO
    {
        public bool State { get; set; }

        public string Msg { get; set; } = string.Empty;
    }

    public static readonly ExternalLoginChannel[] ExternalLoginChannels = new[] 
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Helpers\UI\ThirdPartyLoginHelper.cs
DEBUG
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Logging\ClientLogger.cs
/github.com/dotnet/extensions/blob/v3.1.5/src/Logging/Logging.Console/src/ConsoleLogger.cs</para>

/ </summary>
public abstract class ClientLogger : ILogger
{
    static readonly string _messagePadding = new string(' ', 6);
    static readonly string _newLineWithMessagePadding = Environment.NewLine + _messagePadding;

    protected readonly string name;

    public ClientLogger(string name) => this.name = name;

    public virtual IDisposable? BeginScope<TState>(TState state) where TState : notnull
    {
        return NullScope.Instance;
    }

    public virtual bool IsEnabled(LogLevel logLevel) => logLevel != LogLevel.None;

    public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception? exception, Func<TState, Exception?, string> formatter)
    {
        if (!IsEnabled(logLevel))
            return;

        if (formatter == null)
            throw new ArgumentNullException(nameof(formatter));

        var message = formatter(state, exception);

        if (!string.IsNullOrEmpty(message) || exception != null)
            WriteMessage(logLevel, name, eventId.Id, message, exception);
    }

    public virtual void WriteMessage(LogLevel logLevel, string logName, int eventId, string? message, Exception? exception)
    {
        var logBuilder = new StringBuilder();

        CreateDefaultLogMessage(logBuilder, logName, eventId, message, exception);

        var logMessage = logBuilder.ToString();
        WriteMessage(logLevel, logMessage);
    }

    static void CreateDefaultLogMessage(StringBuilder logBuilder, string logName, int eventId, string? message, Exception? exception)
    {
        
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Logging\NSLogger.cs
/ <inheritdoc cref="ClientLogger"/>
public sealed partial class NSLogger : ClientLogger
{
    public NSLogger(string name) : base(name)
    {
    }

    public override bool IsEnabled(LogLevel logLevel)
    {
#if DEBUG
        return true;
#else
        return logLevel >= LogLevel.Error;
#endif
    }

    public override void WriteMessage(LogLevel logLevel, string message)
    {
        NSLog(message);
    }

    [LibraryImport("/System/Library/Frameworks/Foundation.framework/Foundation")]
    static partial void NSLog(IntPtr format, [MarshalAs(UnmanagedType.LPWStr)] string s);

    static void NSLog(string format, params object[]? args)
    {
#pragma warning disable CS0618 
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Logging\NSLogger.cs
MACOS
DEBUG
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Logging\NSLoggerProvider.cs
MACOS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Logging\NullScope.cs
/github.com/dotnet/extensions/blob/v3.1.5/src/Logging/shared/NullScope.cs</para>

/github.com/dotnet/runtime/blob/v5.0.0-rtm.20519.4/src/libraries/Common/src/Extensions/Logging/NullScope.cs</para>

/ </summary>
sealed class NullScope : IDisposable
{
    public static NullScope Instance { get; } = new();

    NullScope()
    {
    }

    public void Dispose()
    {
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Logging\OSLogLogger.cs
/github.com/unoplatform/uno.extensions.logging/blob/1.4.0/src/Uno.Extensions.Logging.OSLog/OSLogLogger.cs

发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Logging\OSLogLogger.cs
MACOS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Logging\OSLogLoggerProvider.cs
/github.com/unoplatform/uno.extensions.logging/blob/1.4.0/src/Uno.Extensions.Logging.OSLog/OSLogLoggerProvider.cs


/ A provider of <see cref="OSLogLogger"/> instances.

/ </summary>
public sealed class OSLogLoggerProvider : ILoggerProvider
{
    readonly ConcurrentDictionary<string, OSLogLogger> _loggers;

    
/ Creates an instance of <see cref="OSLogLoggerProvider"/>.
    
/ </summary>
    OSLogLoggerProvider()
    {
        _loggers = new ConcurrentDictionary<string, OSLogLogger>();
    }

    
/ <inheritdoc />
    public ILogger CreateLogger(string name)
    {
        return _loggers.GetOrAdd(name, loggerName => new OSLogLogger(name));
    }

    
/ <inheritdoc />
    public void Dispose()
    {
    }

    public static ILoggerProvider Instance { get; } = new OSLogLoggerProvider();
}
#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Logging\OSLogLoggerProvider.cs
MACOS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Migrations\Migrations.cs
/ </summary>
public static class Migrations
{
    public const string DirName_Scripts = "Scripts";
    public const string DirName_BuildScripts = "BuildScripts";

    static Version? PreviousVersion { get; } = Version.TryParse(VersionTracking2.PreviousVersion, out var value) ? value : null;

    
/ </summary>
    public static void Up()
    {
        
/ 可以删除 /AppData/application2.dbf 表 0984415E 使此 if 返回 True
        
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Models\AppSettings.cs
/ </summary>
[MPObj, MP2Obj(SerializeLayout.Explicit)]
public sealed partial class AppSettings : IMicroServiceClient.ISettings
{
    
/ </summary>
    [MPKey(0)]
    [MP2Ignore]
    [N_JsonIgnore]
    [S_JsonIgnore]
    [Obsolete("Delete", true)]
    public Guid AppVersion { get; set; }

    
/ </summary>
    [MPKey(1), MP2Key(0)]
    [N_JsonProperty("1")]
    [S_JsonProperty("1")]
    public string? ApiBaseUrl { get; set; }

    
/ </summary>
    [MPKey(2), MP2Key(1)]
    [N_JsonProperty("2")]
    [S_JsonProperty("2")]
    public byte[]? AesSecret { get; set; }

    Aes? aes;

    [MPIgnore]
    [MP2Ignore]
    [N_JsonIgnore]
    [S_JsonIgnore]
    public Aes Aes
    {
        get
        {
            if (aes == null)
            {
                if (AesSecret == null) throw new IsNotOfficialChannelPackageException(nameof(Aes), new ArgumentNullException(nameof(AesSecret)));
                aes = AESUtils.Create(AesSecret);
            }
            return aes;
        }
    }

    
/ </summary>
    [MPKey(3), MP2Key(2)]
    [N_JsonProperty("3")]
    [S_JsonProperty("3")]
    public byte[]? RSASecret { get; set; }

    RSA? rsa;

    [MPIgnore]
    [MP2Ignore]
    [N_JsonIgnore]
    [S_JsonIgnore]
    public RSA RSA
    {
        get
        {
            if (rsa == null)
            {
                if (RSASecret == null) throw new IsNotOfficialChannelPackageException(nameof(RSA), new ArgumentNullException(nameof(RSASecret)));
                rsa = RSA.Create(Serializable.DMP2<RSAParameters>(RSASecret));
            }
            return rsa;
        }
    }

    
/ </summary>
    
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Models\AppSettings.cs
SIGN
DEBUG
DEBUG
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Models\EnumModel.cs
/ </summary>
    
/ 获取该枚举值的本地化显示字符串，使用 <see cref="Description"/> 或 <see cref="Name"/> 查找本地化资源
    
/ </summary>
    
/ </summary>
    public string? LocalizationName => string.IsNullOrEmpty(Description) ?
        AppResources.ResourceManager.GetString($"{typeof(TEnum).Name}_{Name}", AppResources.Culture) :
        AppResources.ResourceManager.GetString(Description, AppResources.Culture);

    string? _Description;

    public string? Description
    {
        get
        {
            _Description ??= Enum2.GetDescription(Value) ?? "";
            return _Description;
        }
        set => _Description = value;
    }

    TEnum _Value;

    public TEnum Value
    {
        get => _Value;
        set => this.RaiseAndSetIfChanged(ref _Value, value);
    }

    bool _Enable;

    public bool Enable
    {
        get => _Enable;
        set => this.RaiseAndSetIfChanged(ref _Enable, value);
    }

    int _Count;

    
/ </summary>
    public int Count
    {
        get => _Count;
        set => this.RaiseAndSetIfChanged(ref _Count, value);
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Models\NativeWindowModel.cs
/ </summary>

/ <param name="Handle">窗口句柄</param>

/ <param name="Title">窗口标题</param>

/ <param name="ClassName"></param>

/ <param name="Process">进程</param>

/ <param name="Path">路径</param>

/ <param name="Name">名称</param>
[SupportedOSPlatform("Windows")]
public record class NativeWindowModel(
    IntPtr Handle,
    string? Title,
    string? ClassName,
    Process? Process,
    string? Path,
    string? Name);

[SupportedOSPlatform("Windows")]
public static class HandleWindowExtensions
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsHasProcessExits(this NativeWindowModel window)
    {
        if (window?.Process?.HasExited == false && window.Name != Process.GetCurrentProcess().ProcessName)
        {
            return false;
        }
        return true;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Kill(this NativeWindowModel window)
    {
        if (!window.IsHasProcessExits())
        {
            window.Process?.Kill();
        }
    }
}
#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Models\NativeWindowModel.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Models\OperationResult.cs
/ <inheritdoc cref="OperationResultBase{T}"/>
public sealed class OperationResult : OperationResultBase<object>
{
    
/ <inheritdoc cref="OperationResultBase{T}.OperationResultBase(OperationResultType)"/>
    public OperationResult()
    {
    }

    
/ <inheritdoc cref="OperationResultBase{T}.OperationResultBase(OperationResultType)"/>
    public OperationResult(OperationResultType resultType) : base(resultType)
    {
    }

    
/ <inheritdoc cref="OperationResultBase{T}.OperationResultBase(OperationResultType, string)"/>
    public OperationResult(OperationResultType resultType, string message) : base(resultType, message)
    {
    }

    
/ <inheritdoc cref="OperationResultBase{T}.OperationResultBase(OperationResultType, string, T)"/>
    public OperationResult(OperationResultType resultType, string message, object? appendData) : base(resultType, message, appendData)
    {
    }

    
/ <inheritdoc cref="OperationResultBase{T}.OperationResultBase(OperationResultType, string, string)"/>
    public OperationResult(OperationResultType resultType, string message, string logMessage) : base(resultType, message, logMessage)
    {
    }

    
/ <inheritdoc cref="OperationResultBase{T}.OperationResultBase(OperationResultType, string, string, T)"/>
    public OperationResult(OperationResultType resultType, string message, string logMessage, object? appendData) : base(resultType, message, logMessage, appendData)
    {
    }

    public OperationResult(IOperationResult result)
    {
        ResultType = result.ResultType;
        Message = result.Message;
        LogMessage = result.LogMessage;
    }

    [MPIgnore, MP2Ignore]
    [N_JsonIgnore]
    [S_JsonIgnore]
    public sealed override object AppendData
    {
        get => null!;
        set { }
    }
}


/ <inheritdoc cref="OperationResultBase{T}"/>
public sealed class OperationResult<T> : OperationResultBase<T>
{
    
/ <inheritdoc cref="OperationResultBase{T}.OperationResultBase(OperationResultType)"/>
    public OperationResult()
    {
    }

    
/ <inheritdoc cref="OperationResultBase{T}.OperationResultBase(OperationResultType)"/>
    public OperationResult(OperationResultType resultType) : base(resultType)
    {
    }

    
/ <inheritdoc cref="OperationResultBase{T}.OperationResultBase(OperationResultType, string)"/>
    public OperationResult(OperationResultType resultType, string message) : base(resultType, message)
    {
    }

    
/ <inheritdoc cref="OperationResultBase{T}.OperationResultBase(OperationResultType, string, T)"/>
    public OperationResult(OperationResultType resultType, string message, T appendData) : base(resultType, message, appendData)
    {
    }

    
/ <inheritdoc cref="OperationResultBase{T}.OperationResultBase(OperationResultType, string, string)"/>
    public OperationResult(OperationResultType resultType, string message, string logMessage) : base(resultType, message, logMessage)
    {
    }

    
/ <inheritdoc cref="OperationResultBase{T}.OperationResultBase(OperationResultType, string, string, T)"/>
    public OperationResult(OperationResultType resultType, string message, string logMessage, T appendData) : base(resultType, message, logMessage, appendData)
    {
    }

    public OperationResult(IOperationResult result)
    {
        ResultType = result.ResultType;
        Message = result.Message;
        LogMessage = result.LogMessage;
        if (result is IOperationResult<T> result2)
        {
            AppendData = result2.AppendData;
        }
    }

    public OperationResult(IOperationResult<T> result)
    {
        ResultType = result.ResultType;
        Message = result.Message;
        LogMessage = result.LogMessage;
        AppendData = result.AppendData;
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Models\ReactiveSerializationObject.cs
/ <see cref="ReactiveObject"/> 的序列化忽略基类

/ </summary>
public abstract class ReactiveSerializationObject : ReactiveObject
{
    
/ <inheritdoc cref="ReactiveObject.Changing" />
    [XmlIgnore, IgnoreDataMember, SystemTextJsonIgnore, NewtonsoftJsonIgnore, MPIgnore, MP2Ignore]
    public new IObservable<IReactivePropertyChangedEventArgs<IReactiveObject>> Changing => base.Changing;

    
/ <inheritdoc cref="ReactiveObject.Changed" />
    [XmlIgnore, IgnoreDataMember, SystemTextJsonIgnore, NewtonsoftJsonIgnore, MPIgnore, MP2Ignore]
    public new IObservable<IReactivePropertyChangedEventArgs<IReactiveObject>> Changed => base.Changed;

    
/ <inheritdoc cref="ReactiveObject.ThrownExceptions" />
    [XmlIgnore, IgnoreDataMember, SystemTextJsonIgnore, NewtonsoftJsonIgnore, MPIgnore, MP2Ignore]
    public new IObservable<Exception> ThrownExceptions => base.ThrownExceptions;
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Models\Abstractions\IOperationResult.cs
/ </summary>
public interface IOperationResult
{
    
/ </summary>
    OperationResultType ResultType { get; set; }

    
/ </summary>
    string Message { get; set; }

    
/ </summary>
    string LogMessage { get; set; }
}


/ <inheritdoc cref="IOperationResult"/>
public interface IOperationResult<T> : IOperationResult
{
    
/ </summary>
    T AppendData { get; set; }
}


/ <inheritdoc cref="IOperationResult{T}"/>
public abstract class OperationResultBase<T> : IOperationResult<T>
{
    #region 构造函数

    public OperationResultBase()
    {
        ResultType = OperationResultType.Error;
    }

    
/ </summary>
    
/ <param name="resultType">操作结果类型</param>
    public OperationResultBase(OperationResultType resultType)
    {
        ResultType = resultType;
    }

    
/ </summary>
    
/ <param name="resultType">操作结果类型</param>
    
/ <param name="message">返回消息</param>
    public OperationResultBase(OperationResultType resultType, string message)
        : this(resultType)
    {
        Message = message;
    }

    
/ </summary>
    
/ <param name="resultType">操作结果类型</param>
    
/ <param name="message">返回消息</param>
    
/ <param name="appendData">返回数据</param>
    public OperationResultBase(OperationResultType resultType, string message, T? appendData)
        : this(resultType, message)
    {
        _AppendData = appendData;
    }

    
/ </summary>
    
/ <param name="resultType">操作结果类型</param>
    
/ <param name="message">返回消息</param>
    
/ <param name="logMessage">日志记录消息</param>
    public OperationResultBase(OperationResultType resultType, string message, string logMessage)
        : this(resultType, message)
    {
        LogMessage = logMessage;
    }

    
/ </summary>
    
/ <param name="resultType">操作结果类型</param>
    
/ <param name="message">返回消息</param>
    
/ <param name="logMessage">日志记录消息</param>
    
/ <param name="appendData">返回数据</param>
    public OperationResultBase(OperationResultType resultType, string message, string logMessage, T? appendData)
        : this(resultType, message, logMessage)
    {
        _AppendData = appendData;
    }

    #endregion

    #region 属性

    public OperationResultType ResultType { get; set; }

    public string Message { get; set; } = string.Empty;

    public string LogMessage { get; set; } = string.Empty;

    protected T? _AppendData;

    public virtual T AppendData
    {
        get
        {
            _AppendData ??= Activator.CreateInstance<T>();
            return _AppendData;
        }
        set => _AppendData = value;
    }

    #endregion
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Models\Identity\CurrentUser.cs
/ 当前登录用户模型，如需增加字段，还需要在 <see cref="Clone"/> 中赋值新添加字段

/ </summary>
[MPObj, MP2Obj(SerializeLayout.Explicit)]
public sealed partial class CurrentUser : IExplicitHasValue, IPhoneNumber
{
    [MPKey(0), MP2Key(0)]
    [N_JsonProperty("0")]
    [S_JsonProperty("0")]
    public Guid UserId { get; set; }

    [MPKey(1), MP2Key(1)]
    [N_JsonProperty("1")]
    [S_JsonProperty("1")]
    public JWTEntity? AuthToken { get; set; }

    [MPKey(2), MP2Key(2)]
    [N_JsonProperty("2")]
    [S_JsonProperty("2")]
    public string? PhoneNumber { get; set; }

    [MPKey(3), MP2Key(3)]
    [N_JsonProperty("3")]
    [S_JsonProperty("3")]
    public JWTEntity? ShopAuthToken { get; set; }

    bool IExplicitHasValue.ExplicitHasValue()
    {
        if (!AuthToken.HasValue()) return false;
        return true;
    }

    public CurrentUser? Clone() => this.HasValue() ?
        new()
        {
            UserId = UserId,
            AuthToken = AuthToken,
            PhoneNumber = PhoneNumber,
            ShopAuthToken = ShopAuthToken,
        } : null;
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Plugins\PluginRepetitionType.cs
/ </summary>
public enum PluginRepetitionType : byte
{
    Id = 5,
    UniqueEnglishName,
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Plugins\PluginResult.cs
/ </summary>

/ <typeparam name="TData">结果数据类型</typeparam>

/ <param name="IsDisable">是否禁用</param>

/ <param name="Data">插件数据</param>
public sealed class PluginResult<TData>
    : ReactiveObject, IEquatable<PluginResult<TData>>,
    IEquatable<TData>, IReactiveObject
    where TData : notnull
{
    [SetsRequiredMembers]
    public PluginResult(bool isDisable, TData data)
    {
        IsDisable = isDisable;
        Data = data;
    }

    [property: Reactive]
    public bool IsDisable { get; set; }

    public required TData Data { get; init; }

    public override int GetHashCode() => Data.GetHashCode();

    public bool Equals(PluginResult<TData>? other)
        => EqualityComparer<TData?>.Default.Equals(other == default ? default : other.Data, Data);

    public bool Equals(TData? other)
        => EqualityComparer<TData>.Default.Equals(other, Data);

    public override bool Equals(object? obj)
    {
        if (obj is TData obj1) return Equals(obj1);
        if (obj is PluginResult<TData> obj2) return Equals(obj2);
        return base.Equals(obj);
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Plugins\PluginsCore.cs
/ 禁用的插件使用单独的 <see cref="AssemblyLoadContext"/> 加载与卸载
    
/ </summary>
    sealed class DisablePluginsAssemblyLoadContext : AssemblyLoadContext
    {
        public DisablePluginsAssemblyLoadContext() : base($"{Constants.HARDCODED_APP_NAME_NEW}.DisablePlugins", true)
        {

        }

        protected override Assembly? Load(AssemblyName assemblyName)
        {
            var assemblyLoadContext = DefaultAssemblyLoadContext;
            if (assemblyLoadContext != this)
            {
                try
                {
                    var assembly = assemblyLoadContext.LoadFromAssemblyName(assemblyName);
                    if (assembly != null)
                    {
                        return assembly;
                    }
                }
                catch
                {

                }
            }
            return base.Load(assemblyName);
        }
    }

    static AssemblyLoadContext DefaultAssemblyLoadContext
    {
        get
        {
            
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Plugins\PluginsCore.cs
DEBUG
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Plugins\Abstractions\IPlugin.cs
/ </summary>
public partial interface IPlugin
{
    
/ 判断插件是否满足要求，如没有任何要求则返回 <see angword="true"/>
    
/ </summary>
    
/ <param name="error"></param>
    
/ <returns></returns>
    bool HasValue([NotNullWhen(false)] out string? error);

    
/ </summary>
    
/ <returns></returns>
    IEnumerable<MenuTabItemViewModel>? GetMenuTabItems();

    
/ </summary>
    
/ <param name="directoryExists"></param>
    
/ <returns></returns>
    IEnumerable<(Action<IServiceCollection>? @delegate, bool isInvalid, string name)>? GetConfiguration(bool directoryExists);

    
/ </summary>
    
/ <returns></returns>
    ValueTask OnInitializeAsync();

    
/ </summary>
    
/ <param name="services"></param>
    
/ <param name="startup"></param>
    void ConfigureDemandServices(
        IServiceCollection services,
        Startup startup);

    
/ </summary>
    
/ <param name="services"></param>
    
/ <param name="startup"></param>
    void ConfigureRequiredServices(
        IServiceCollection services,
        Startup startup);

    void ConfigureServices(IpcProvider ipcProvider,
        Startup startup)
    { }

    
/ </summary>
    
/ <param name="cfg"></param>
    void OnAddAutoMapper(IMapperConfigurationExpression cfg);

    
/ </summary>
    
/ <param name="ex"></param>
    
/ <param name="name"></param>
    void OnUnhandledException(Exception ex, string name, bool? isTerminating = null);

    ValueTask OnExit();

    
/ </summary>
    
/ <param name="moduleName"></param>
    
/ <param name="pipeName"></param>
    
/ <param name="processId"></param>
    
/ <param name="encodedArgs"></param>
    
/ <returns></returns>
    Task<int> RunSubProcessMainAsync(string moduleName, string pipeName, string processId, string encodedArgs);

    
/ </summary>
    
/ <param name="isReconnected">是否为重连</param>
    
/ <returns></returns>
    ValueTask OnPeerConnected(bool isReconnected);

    
/ </summary>
    
/ <returns></returns>
    ValueTask OnCommandRun(params string[] commandParams);
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Plugins\Abstractions\IPlugin.Properties.cs
/ </summary>
    Guid Id => default;

    
/ </summary>
    string Name { get; }

    
/ </summary>
    string UniqueEnglishName { get; }

    
/ 插件版本号，<see cref="Version.TryParse(string?, out Version?)"/> 可能返回 <see langword="false"/>，当字符串中存在符号或字母时
    
/ </summary>
    string Version { get; }

    
/ </summary>
    string? Description { get; }

    
/ </summary>
    string StoreUrl { get; }

    
/ </summary>
    string HelpUrl { get; }

    
/ </summary>
    Type? SettingsPageViewType { get; }

    
/ </summary>
    string? Author { get; }

    
/ </summary>
    string AuthorStoreUrl { get; }

    
/ </summary>
    string AssemblyLocation { get; }

    
/ </summary>
    string AppDataDirectory { get; }

    
/ </summary>
    string CacheDirectory { get; }

    
/ </summary>
    bool IsOfficial { get; }

    
/ 插件显示图标图片资源路径，值为 <see langword="null"/> 时使用默认图片
    
/ </summary>
    object? Icon { get; }

    
/ </summary>
    DateTimeOffset InstallTime { get; }

    
/ </summary>
    DateTimeOffset ReleaseTime { get; }

    
/ </summary>
    string? LoadError { get; internal set; }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Plugins\Abstractions\PluginBase.cs
/ </summary>
    
/ <param name="args"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    protected static string DecodeArgs(string args)
        => HttpUtility.UrlDecode(args);

    
/ </summary>
    
/ <param name="args"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    protected static string[] DecodeToArrayArgs(string args)
        => HttpUtility.UrlDecode(args).Split(' ', StringSplitOptions.RemoveEmptyEntries);

    public virtual async Task<int> RunSubProcessMainAsync(
        string moduleName,
        string pipeName,
        string processId,
        string encodedArgs)
    {
        var subProcessBootConfiguration = GetSubProcessBootConfiguration(encodedArgs ?? string.Empty);
        if (subProcessBootConfiguration == default)
            return (int)CommandExitCode.GetSubProcessBootConfigurationFail;

        var pluginName = UniqueEnglishName;
        var exitCode = await IPCSubProcessService.MainAsync(moduleName, pluginName,
            subProcessBootConfiguration.configureServices,
            subProcessBootConfiguration.configureIpcProvider,
            new[] { pipeName, processId });
        return exitCode;
    }

    
/ </summary>
    
/ <param name="args"></param>
    
/ <returns></returns>
    protected virtual (Action<IServiceCollection>? configureServices, Action<IpcProvider>? configureIpcProvider) GetSubProcessBootConfiguration(string args)
    {
        return default;
    }

    public virtual ValueTask OnPeerConnected(bool isReconnected)
    {
        return ValueTask.CompletedTask;
    }

    public virtual ValueTask OnCommandRun(params string[] commandParams)
    {
        return ValueTask.CompletedTask;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    protected static async ValueTask GetIpcRemoteServiceAsync<T>(
        string moduleName,
        IPCMainProcessService ipc,
        TaskCompletionSource<T> tsc)
        where T : class
    {
        try
        {
            var ipcRemoteService = await ipc.GetServiceAsync<T>(moduleName);
            tsc.TrySetResult(ipcRemoteService.ThrowIsNull());
        }
        catch (Exception ex)
        {
            tsc.TrySetException(ex);
        }
    }
}

public abstract partial class PluginBase<TPlugin> : PluginBase, IPlugin where TPlugin : PluginBase<TPlugin>, new()
{
    public PluginBase()
    {
        Instance = (TPlugin)this;
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Plugins\Abstractions\PluginBase.Properties.cs
/steampp.net/store/plugins/names/{WebUtility.UrlEncode(UniqueEnglishName.ToLowerInvariant())}";

    public virtual string HelpUrl =>
        $"https:
/steampp.net/store/plugins/helps/names/{WebUtility.UrlEncode(UniqueEnglishName.ToLowerInvariant())}";

    public virtual Type? SettingsPageViewType { get; }

    
/ </summary>
    
/ <param name="author"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static bool IsIllegalAuthor(string author)
    {
        if (author.Contains("Steam++", StringComparison.OrdinalIgnoreCase) ||
            author.Contains("Steam", StringComparison.OrdinalIgnoreCase) ||
            author.Contains("steampp", StringComparison.OrdinalIgnoreCase) ||
            author.Contains("Watt", StringComparison.OrdinalIgnoreCase) ||
            author.Contains("WattToolkit", StringComparison.OrdinalIgnoreCase) ||
            author.Contains("\u6B21\u5143\u8D85\u8D8A", StringComparison.OrdinalIgnoreCase) ||
            author.Contains("\u51E1\u661F", StringComparison.OrdinalIgnoreCase) ||
            author.Contains("\u7E41\u661F", StringComparison.OrdinalIgnoreCase))
        {
            return true;
        }
        return false;
    }

    public string? Author
    {
        get
        {
            if (IsOfficial)
                return Strings.Plugin_OfficialAuthor_.Format(AssemblyInfo.Trademark);
            var author = AuthorOriginalString;
            if (string.IsNullOrWhiteSpace(author))
                return Strings.Plugin_UnknownAuthor;
            if (IsIllegalAuthor(author))
                return Strings.Plugin_IllegalAuthor;
            return author;
        }
    }

    
/ </summary>
    protected virtual string? AuthorOriginalString { get; }

    public virtual string AuthorStoreUrl =>
        $"https:
/steampp.net/store/plugins/authors/{WebUtility.UrlEncode(Author)}";

    public virtual string? Description { get; }

    public abstract string AssemblyLocation { get; }

    public string AppDataDirectory => mAppDataDirectory.Value;

    public string CacheDirectory => mCacheDirectory.Value;

    
/ </summary>
    
/ </summary>
    
/ <returns></returns>
    
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Plugins\Abstractions\PluginBase.Properties.cs
DEBUG
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Properties\Resources.Designer.cs
/ </auto-generated>

/ </summary>
    
/ (以 /str 作为命令选项)，或重新生成 VS 项目。
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        
/ </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("BD.WTTS.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        
/ </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        
/ </summary>
        internal static byte[] AppLogo_128 {
            get {
                object obj = ResourceManager.GetObject("AppLogo_128", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        
/ </summary>
        internal static byte[] AppLogo_16 {
            get {
                object obj = ResourceManager.GetObject("AppLogo_16", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        
/ </summary>
        internal static byte[] AppLogo_24 {
            get {
                object obj = ResourceManager.GetObject("AppLogo_24", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        
/ </summary>
        internal static byte[] AppLogo_256 {
            get {
                object obj = ResourceManager.GetObject("AppLogo_256", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        
/ </summary>
        internal static byte[] AppLogo_32 {
            get {
                object obj = ResourceManager.GetObject("AppLogo_32", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        
/ </summary>
        internal static byte[] AppLogo_48 {
            get {
                object obj = ResourceManager.GetObject("AppLogo_48", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        
/ </summary>
        internal static byte[] AppLogo_512 {
            get {
                object obj = ResourceManager.GetObject("AppLogo_512", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        
/ </summary>
        internal static byte[] AppLogo_64 {
            get {
                object obj = ResourceManager.GetObject("AppLogo_64", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        
/ </summary>
        internal static byte[] AppLogo_96 {
            get {
                object obj = ResourceManager.GetObject("AppLogo_96", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        
/ </summary>
        internal static byte[] open_source_library {
            get {
                object obj = ResourceManager.GetObject("open_source_library", resourceCulture);
                return ((byte[])(obj));
            }
        }
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Repositories\Abstractions\Http\IRequestCacheRepository.cs
/ </summary>
    
/ <param name="id"></param>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    Task UpdateUsageTimeByIdAsync(string id, CancellationToken cancellationToken);

    
/ </summary>
    
/ <returns></returns>
    Task<int> DeleteAllAsync();

    
/ </summary>
    
/ <returns></returns>
    Task<int> DeleteAllAsync(DateTimeOffset dateTimeOffset);

    const string DefaultRequestUri = "/";

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static string GetOriginalRequestUri(HttpRequestMessage request)
    {
        string? originalRequestUri;
        if (request is ImageHttpClientService.ImageHttpRequestMessage request2)
        {
            
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Repositories\Http\RequestCacheRepository.cs
/github.com/reactiveui/Fusillade/blob/2.4.67/src/Fusillade/RateLimitedHttpMessageHandler.cs#L54-L89

        using var s = new MemoryStream();
        s.Write(Encoding.UTF8.GetBytes(originalRequestUri));
        s.Write("\r\n"u8);
        s.Write(Encoding.UTF8.GetBytes(request.Method.Method));
        s.Write("\r\n"u8);
        static void Write(Stream s, IEnumerable<object> items)
        {
            foreach (var item in items)
            {
                var str = item.ToString();
                if (!string.IsNullOrEmpty(str))
                    s.Write(Encoding.UTF8.GetBytes(str));
                s.Write("|"u8);
            }
        }
        Write(s, request.Headers.Accept);
        s.Write("\r\n"u8);
        
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Resources\Strings.Designer.cs
/ </auto-generated>

/ </summary>
    
/ (以 /str 作为命令选项)，或重新生成 VS 项目。
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    public class Strings {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Strings() {
        }
        
        
/ </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("BD.WTTS.Resources.Strings", typeof(Strings).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        
/ </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        
/ </summary>
        public static string About {
            get {
                return ResourceManager.GetString("About", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string About_FormerName__ {
            get {
                return ResourceManager.GetString("About_FormerName__", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string About_ThankSupport {
            get {
                return ResourceManager.GetString("About_ThankSupport", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string About_Version_ {
            get {
                return ResourceManager.GetString("About_Version_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string AboutThisPlugin {
            get {
                return ResourceManager.GetString("AboutThisPlugin", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Accelerator_OpenHostsDir {
            get {
                return ResourceManager.GetString("Accelerator_OpenHostsDir", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string AccountChange_RestartSteam {
            get {
                return ResourceManager.GetString("AccountChange_RestartSteam", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string AccountChange_ShareManageAboutTips {
            get {
                return ResourceManager.GetString("AccountChange_ShareManageAboutTips", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string AccountChange_Title {
            get {
                return ResourceManager.GetString("AccountChange_Title", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string AccountLogin {
            get {
                return ResourceManager.GetString("AccountLogin", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Achievement_Description {
            get {
                return ResourceManager.GetString("Achievement_Description", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Achievement_EditSucces {
            get {
                return ResourceManager.GetString("Achievement_EditSucces", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Achievement_Icon {
            get {
                return ResourceManager.GetString("Achievement_Icon", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Achievement_IsProtection {
            get {
                return ResourceManager.GetString("Achievement_IsProtection", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Achievement_LoadData {
            get {
                return ResourceManager.GetString("Achievement_LoadData", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Achievement_LoadSucces {
            get {
                return ResourceManager.GetString("Achievement_LoadSucces", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Achievement_Manage {
            get {
                return ResourceManager.GetString("Achievement_Manage", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Achievement_Name {
            get {
                return ResourceManager.GetString("Achievement_Name", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Achievement_RefreshTip {
            get {
                return ResourceManager.GetString("Achievement_RefreshTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Achievement_ResetTip {
            get {
                return ResourceManager.GetString("Achievement_ResetTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Achievement_ResetWaring_1 {
            get {
                return ResourceManager.GetString("Achievement_ResetWaring_1", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Achievement_ResetWaring_2 {
            get {
                return ResourceManager.GetString("Achievement_ResetWaring_2", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Achievement_ResetWaring_3 {
            get {
                return ResourceManager.GetString("Achievement_ResetWaring_3", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Achievement_RiskWarning {
            get {
                return ResourceManager.GetString("Achievement_RiskWarning", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Achievement_StatsEdit {
            get {
                return ResourceManager.GetString("Achievement_StatsEdit", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Achievement_StoreTip {
            get {
                return ResourceManager.GetString("Achievement_StoreTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Achievement_TimeFormat {
            get {
                return ResourceManager.GetString("Achievement_TimeFormat", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Achievement_Unlock {
            get {
                return ResourceManager.GetString("Achievement_Unlock", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Achievement_Warning_1 {
            get {
                return ResourceManager.GetString("Achievement_Warning_1", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Achievement_Warning_2 {
            get {
                return ResourceManager.GetString("Achievement_Warning_2", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Achievement_Warning_3 {
            get {
                return ResourceManager.GetString("Achievement_Warning_3", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Achievement_Warning_4 {
            get {
                return ResourceManager.GetString("Achievement_Warning_4", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Add {
            get {
                return ResourceManager.GetString("Add", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string AddPlatform {
            get {
                return ResourceManager.GetString("AddPlatform", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string AdministratorStartup {
            get {
                return ResourceManager.GetString("AdministratorStartup", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Advertisement {
            get {
                return ResourceManager.GetString("Advertisement", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Advertisement_Close {
            get {
                return ResourceManager.GetString("Advertisement_Close", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Advertisement_NoShow {
            get {
                return ResourceManager.GetString("Advertisement_NoShow", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Advertisement_NoShow_Tip {
            get {
                return ResourceManager.GetString("Advertisement_NoShow_Tip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Agree {
            get {
                return ResourceManager.GetString("Agree", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string AllPassed {
            get {
                return ResourceManager.GetString("AllPassed", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string AllTyoe {
            get {
                return ResourceManager.GetString("AllTyoe", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string And {
            get {
                return ResourceManager.GetString("And", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string AppTheme_Dark {
            get {
                return ResourceManager.GetString("AppTheme_Dark", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string AppTheme_FollowingSystem {
            get {
                return ResourceManager.GetString("AppTheme_FollowingSystem", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string AppTheme_Light {
            get {
                return ResourceManager.GetString("AppTheme_Light", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ArchiSteamFarmPlus {
            get {
                return ResourceManager.GetString("ArchiSteamFarmPlus", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Arguments {
            get {
                return ResourceManager.GetString("Arguments", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ASF_AddBot {
            get {
                return ResourceManager.GetString("ASF_AddBot", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ASF_BotManage {
            get {
                return ResourceManager.GetString("ASF_BotManage", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ASF_DeleteBotSuccess {
            get {
                return ResourceManager.GetString("ASF_DeleteBotSuccess", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ASF_DeleteBotTip {
            get {
                return ResourceManager.GetString("ASF_DeleteBotTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ASF_EffectiveAfterRestart {
            get {
                return ResourceManager.GetString("ASF_EffectiveAfterRestart", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ASF_ExecuteFileUnsafe {
            get {
                return ResourceManager.GetString("ASF_ExecuteFileUnsafe", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ASF_IPCIsReadyFalse {
            get {
                return ResourceManager.GetString("ASF_IPCIsReadyFalse", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ASF_RedeemKeyBotSuccessTip {
            get {
                return ResourceManager.GetString("ASF_RedeemKeyBotSuccessTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ASF_RequirRunASF {
            get {
                return ResourceManager.GetString("ASF_RequirRunASF", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ASF_Restarted {
            get {
                return ResourceManager.GetString("ASF_Restarted", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ASF_Restarting {
            get {
                return ResourceManager.GetString("ASF_Restarting", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ASF_SelectASFExePath {
            get {
                return ResourceManager.GetString("ASF_SelectASFExePath", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ASF_SetCryptKey {
            get {
                return ResourceManager.GetString("ASF_SetCryptKey", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ASF_SetExePathFirst {
            get {
                return ResourceManager.GetString("ASF_SetExePathFirst", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ASF_Settings {
            get {
                return ResourceManager.GetString("ASF_Settings", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ASF_Start {
            get {
                return ResourceManager.GetString("ASF_Start", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ASF_Started {
            get {
                return ResourceManager.GetString("ASF_Started", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ASF_Starting {
            get {
                return ResourceManager.GetString("ASF_Starting", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ASF_Stop {
            get {
                return ResourceManager.GetString("ASF_Stop", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ASF_Stoped {
            get {
                return ResourceManager.GetString("ASF_Stoped", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ASF_Stoping {
            get {
                return ResourceManager.GetString("ASF_Stoping", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Auth_Add {
            get {
                return ResourceManager.GetString("Auth_Add", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Auth_AddMachineValidation {
            get {
                return ResourceManager.GetString("Auth_AddMachineValidation", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Auth_AddPasswordProtect {
            get {
                return ResourceManager.GetString("Auth_AddPasswordProtect", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Auth_EditName {
            get {
                return ResourceManager.GetString("Auth_EditName", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Auth_EncryptionHelp {
            get {
                return ResourceManager.GetString("Auth_EncryptionHelp", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Auth_ExportAll {
            get {
                return ResourceManager.GetString("Auth_ExportAll", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Auth_ExportmaFile {
            get {
                return ResourceManager.GetString("Auth_ExportmaFile", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Auth_ExportUsingPassword {
            get {
                return ResourceManager.GetString("Auth_ExportUsingPassword", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Auth_FixedDisplay {
            get {
                return ResourceManager.GetString("Auth_FixedDisplay", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Auth_ImportCustomFile {
            get {
                return ResourceManager.GetString("Auth_ImportCustomFile", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Auth_lock {
            get {
                return ResourceManager.GetString("Auth_lock", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Auth_OnlylocalCanDecrypt {
            get {
                return ResourceManager.GetString("Auth_OnlylocalCanDecrypt", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Auth_OnlyMafileFormat {
            get {
                return ResourceManager.GetString("Auth_OnlyMafileFormat", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Auth_PasswordProtectedVerifyFirst {
            get {
                return ResourceManager.GetString("Auth_PasswordProtectedVerifyFirst", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Auth_Possession {
            get {
                return ResourceManager.GetString("Auth_Possession", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Auth_RemoveMachineValidation {
            get {
                return ResourceManager.GetString("Auth_RemoveMachineValidation", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Auth_RemovePasswordProtect {
            get {
                return ResourceManager.GetString("Auth_RemovePasswordProtect", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Auth_SteamLoginImport {
            get {
                return ResourceManager.GetString("Auth_SteamLoginImport", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Auth_Sync_DeleteTime {
            get {
                return ResourceManager.GetString("Auth_Sync_DeleteTime", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Auth_Sync_LatestData {
            get {
                return ResourceManager.GetString("Auth_Sync_LatestData", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Auth_Sync_MoveError {
            get {
                return ResourceManager.GetString("Auth_Sync_MoveError", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Auth_Sync_NoHasPassword {
            get {
                return ResourceManager.GetString("Auth_Sync_NoHasPassword", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Auth_Sync_NoHasRecover {
            get {
                return ResourceManager.GetString("Auth_Sync_NoHasRecover", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Auth_Sync_Recover {
            get {
                return ResourceManager.GetString("Auth_Sync_Recover", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Auth_Sync_RecoverSuccess {
            get {
                return ResourceManager.GetString("Auth_Sync_RecoverSuccess", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Auth_Sync_ResetPassword {
            get {
                return ResourceManager.GetString("Auth_Sync_ResetPassword", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Auth_Sync_UpdateTips {
            get {
                return ResourceManager.GetString("Auth_Sync_UpdateTips", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Auth_Sync_VerifyRecover {
            get {
                return ResourceManager.GetString("Auth_Sync_VerifyRecover", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Auth_UniversalImport {
            get {
                return ResourceManager.GetString("Auth_UniversalImport", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string AuthImport {
            get {
                return ResourceManager.GetString("AuthImport", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string AuthLocal_ExportToQRCodeTooLongErrorTip {
            get {
                return ResourceManager.GetString("AuthLocal_ExportToQRCodeTooLongErrorTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Back {
            get {
                return ResourceManager.GetString("Back", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Background {
            get {
                return ResourceManager.GetString("Background", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BatchPass {
            get {
                return ResourceManager.GetString("BatchPass", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BatchReject {
            get {
                return ResourceManager.GetString("BatchReject", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Bind {
            get {
                return ResourceManager.GetString("Bind", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BindThirdPartyAccount {
            get {
                return ResourceManager.GetString("BindThirdPartyAccount", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Btn_Text_Complete {
            get {
                return ResourceManager.GetString("Btn_Text_Complete", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Btn_Text_Continue {
            get {
                return ResourceManager.GetString("Btn_Text_Continue", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BugReport {
            get {
                return ResourceManager.GetString("BugReport", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CalcHashing_ {
            get {
                return ResourceManager.GetString("CalcHashing_", resourceCulture);
            }
        }
        
        
/   查找类似 正在校验（{1}/{2}）：{0}% 的本地化字符串。
        
/ </summary>
        public static string CalcHashing3__ {
            get {
                return ResourceManager.GetString("CalcHashing3__", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Cancel {
            get {
                return ResourceManager.GetString("Cancel", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CancelAll {
            get {
                return ResourceManager.GetString("CancelAll", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Cancelled {
            get {
                return ResourceManager.GetString("Cancelled", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Changelog {
            get {
                return ResourceManager.GetString("Changelog", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ChangePassword {
            get {
                return ResourceManager.GetString("ChangePassword", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CheckUpdate {
            get {
                return ResourceManager.GetString("CheckUpdate", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Close {
            get {
                return ResourceManager.GetString("Close", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CloseSteam {
            get {
                return ResourceManager.GetString("CloseSteam", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CloudMaxnumFiles {
            get {
                return ResourceManager.GetString("CloudMaxnumFiles", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CloudSaveFileSize {
            get {
                return ResourceManager.GetString("CloudSaveFileSize", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CloudSync {
            get {
                return ResourceManager.GetString("CloudSync", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix {
            get {
                return ResourceManager.GetString("CommunityFix", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_AccelerationsEnable {
            get {
                return ResourceManager.GetString("CommunityFix_AccelerationsEnable", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_AccEmpty {
            get {
                return ResourceManager.GetString("CommunityFix_AccEmpty", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_AlreadyProxy {
            get {
                return ResourceManager.GetString("CommunityFix_AlreadyProxy", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_AutoRunProxy {
            get {
                return ResourceManager.GetString("CommunityFix_AutoRunProxy", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_CustomDohAddres {
            get {
                return ResourceManager.GetString("CommunityFix_CustomDohAddres", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_DeleteCertificate {
            get {
                return ResourceManager.GetString("CommunityFix_DeleteCertificate", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_DeleteCertificate_Fail {
            get {
                return ResourceManager.GetString("CommunityFix_DeleteCertificate_Fail", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_DeleteCertificate_Success {
            get {
                return ResourceManager.GetString("CommunityFix_DeleteCertificate_Success", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_DNSErrorNotify {
            get {
                return ResourceManager.GetString("CommunityFix_DNSErrorNotify", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_EditHostsFile {
            get {
                return ResourceManager.GetString("CommunityFix_EditHostsFile", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_EnableHttpProxyToHttps {
            get {
                return ResourceManager.GetString("CommunityFix_EnableHttpProxyToHttps", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_EnableScriptService {
            get {
                return ResourceManager.GetString("CommunityFix_EnableScriptService", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_EnableUseDoh {
            get {
                return ResourceManager.GetString("CommunityFix_EnableUseDoh", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_FlowStatistics {
            get {
                return ResourceManager.GetString("CommunityFix_FlowStatistics", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_Hosts_MarkDuplicate_ {
            get {
                return ResourceManager.GetString("CommunityFix_Hosts_MarkDuplicate_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_ItemsEmpty {
            get {
                return ResourceManager.GetString("CommunityFix_ItemsEmpty", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_MenuName {
            get {
                return ResourceManager.GetString("CommunityFix_MenuName", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_OnlySteamBrowser {
            get {
                return ResourceManager.GetString("CommunityFix_OnlySteamBrowser", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_OnRunCatch {
            get {
                return ResourceManager.GetString("CommunityFix_OnRunCatch", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_OpenCertificateDir {
            get {
                return ResourceManager.GetString("CommunityFix_OpenCertificateDir", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_OpenHostsDir {
            get {
                return ResourceManager.GetString("CommunityFix_OpenHostsDir", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_ProxyLog {
            get {
                return ResourceManager.GetString("CommunityFix_ProxyLog", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_ProxyMode {
            get {
                return ResourceManager.GetString("CommunityFix_ProxyMode", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_ProxyMode_HostsTip {
            get {
                return ResourceManager.GetString("CommunityFix_ProxyMode_HostsTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_ProxyMode_WinSystemTip {
            get {
                return ResourceManager.GetString("CommunityFix_ProxyMode_WinSystemTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_ProxyOnlyOnScript {
            get {
                return ResourceManager.GetString("CommunityFix_ProxyOnlyOnScript", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_ProxySettings {
            get {
                return ResourceManager.GetString("CommunityFix_ProxySettings", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_ReadHosts_IOException {
            get {
                return ResourceManager.GetString("CommunityFix_ReadHosts_IOException", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_ResetHostsFile {
            get {
                return ResourceManager.GetString("CommunityFix_ResetHostsFile", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_ResetHostsFileCatchTip_ {
            get {
                return ResourceManager.GetString("CommunityFix_ResetHostsFileCatchTip_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_ResetHostsFileOk {
            get {
                return ResourceManager.GetString("CommunityFix_ResetHostsFileOk", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_ResetHostsFileTip {
            get {
                return ResourceManager.GetString("CommunityFix_ResetHostsFileTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_ScriptsEnable {
            get {
                return ResourceManager.GetString("CommunityFix_ScriptsEnable", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_Services {
            get {
                return ResourceManager.GetString("CommunityFix_Services", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_SetAsSystemPACProxyFail {
            get {
                return ResourceManager.GetString("CommunityFix_SetAsSystemPACProxyFail", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_SetAsSystemProxyFail {
            get {
                return ResourceManager.GetString("CommunityFix_SetAsSystemProxyFail", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_SetupCertificate {
            get {
                return ResourceManager.GetString("CommunityFix_SetupCertificate", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_SetupCertificate_Fail {
            get {
                return ResourceManager.GetString("CommunityFix_SetupCertificate_Fail", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_SetupCertificate_Success {
            get {
                return ResourceManager.GetString("CommunityFix_SetupCertificate_Success", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_Starting {
            get {
                return ResourceManager.GetString("CommunityFix_Starting", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_StartProxy {
            get {
                return ResourceManager.GetString("CommunityFix_StartProxy", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_StartProxyFaild443_ {
            get {
                return ResourceManager.GetString("CommunityFix_StartProxyFaild443_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_StartProxyFaild443___ {
            get {
                return ResourceManager.GetString("CommunityFix_StartProxyFaild443___", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_StartProxySuccess {
            get {
                return ResourceManager.GetString("CommunityFix_StartProxySuccess", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_StopProxy {
            get {
                return ResourceManager.GetString("CommunityFix_StopProxy", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CommunityFix_SubProcessFileNotExist {
            get {
                return ResourceManager.GetString("CommunityFix_SubProcessFileNotExist", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Confirm {
            get {
                return ResourceManager.GetString("Confirm", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Confirmed {
            get {
                return ResourceManager.GetString("Confirmed", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ConfirmImport {
            get {
                return ResourceManager.GetString("ConfirmImport", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ConfirmTransaction {
            get {
                return ResourceManager.GetString("ConfirmTransaction", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ContactUs {
            get {
                return ResourceManager.GetString("ContactUs", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Continue {
            get {
                return ResourceManager.GetString("Continue", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CookieLogin {
            get {
                return ResourceManager.GetString("CookieLogin", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Copy {
            get {
                return ResourceManager.GetString("Copy", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CopyToClipboard {
            get {
                return ResourceManager.GetString("CopyToClipboard", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CopyUserId {
            get {
                return ResourceManager.GetString("CopyUserId", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CreateCertificateFaild {
            get {
                return ResourceManager.GetString("CreateCertificateFaild", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CreateShortcutInfo {
            get {
                return ResourceManager.GetString("CreateShortcutInfo", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CreateTime {
            get {
                return ResourceManager.GetString("CreateTime", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CustomFilePicker_Tip {
            get {
                return ResourceManager.GetString("CustomFilePicker_Tip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Cut {
            get {
                return ResourceManager.GetString("Cut", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Debug_InstructionPlaceholder {
            get {
                return ResourceManager.GetString("Debug_InstructionPlaceholder", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Decompressing_ {
            get {
                return ResourceManager.GetString("Decompressing_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Default {
            get {
                return ResourceManager.GetString("Default", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string DefaultExport {
            get {
                return ResourceManager.GetString("DefaultExport", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string DelAccount {
            get {
                return ResourceManager.GetString("DelAccount", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Delete {
            get {
                return ResourceManager.GetString("Delete", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Depot {
            get {
                return ResourceManager.GetString("Depot", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Developer {
            get {
                return ResourceManager.GetString("Developer", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string DirPath {
            get {
                return ResourceManager.GetString("DirPath", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Disable {
            get {
                return ResourceManager.GetString("Disable", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Disabled {
            get {
                return ResourceManager.GetString("Disabled", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string DiskUsage {
            get {
                return ResourceManager.GetString("DiskUsage", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string DisplayQRCode {
            get {
                return ResourceManager.GetString("DisplayQRCode", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Download {
            get {
                return ResourceManager.GetString("Download", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Download_Failed_FileNameTip {
            get {
                return ResourceManager.GetString("Download_Failed_FileNameTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Download_ScriptError {
            get {
                return ResourceManager.GetString("Download_ScriptError", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Download_ScriptError_ {
            get {
                return ResourceManager.GetString("Download_ScriptError_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Download_ScriptOk {
            get {
                return ResourceManager.GetString("Download_ScriptOk", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Download_Success_FileNameTip {
            get {
                return ResourceManager.GetString("Download_Success_FileNameTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string DownloadAndInstall {
            get {
                return ResourceManager.GetString("DownloadAndInstall", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Downloaded {
            get {
                return ResourceManager.GetString("Downloaded", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string DownloadFailedPleaseTryAgainLater {
            get {
                return ResourceManager.GetString("DownloadFailedPleaseTryAgainLater", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string DownloadFlow {
            get {
                return ResourceManager.GetString("DownloadFlow", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Downloading_ {
            get {
                return ResourceManager.GetString("Downloading_", resourceCulture);
            }
        }
        
        
/   查找类似 正在下载（{1}/{2}）：{0}% 的本地化字符串。
        
/ </summary>
        public static string Downloading3__ {
            get {
                return ResourceManager.GetString("Downloading3__", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Edit {
            get {
                return ResourceManager.GetString("Edit", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string EditName {
            get {
                return ResourceManager.GetString("EditName", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Email {
            get {
                return ResourceManager.GetString("Email", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string EmailCode {
            get {
                return ResourceManager.GetString("EmailCode", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Enable {
            get {
                return ResourceManager.GetString("Enable", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string EnableAccelerationPrompt {
            get {
                return ResourceManager.GetString("EnableAccelerationPrompt", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Enabled {
            get {
                return ResourceManager.GetString("Enabled", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Encrypt {
            get {
                return ResourceManager.GetString("Encrypt", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string EncryptSettings {
            get {
                return ResourceManager.GetString("EncryptSettings", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error {
            get {
                return ResourceManager.GetString("Error", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_AccountIdIsEmpty {
            get {
                return ResourceManager.GetString("Error_AccountIdIsEmpty", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_AnswerIncorrect {
            get {
                return ResourceManager.GetString("Error_AnswerIncorrect", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_AuthProtectFailed_ {
            get {
                return ResourceManager.GetString("Error_AuthProtectFailed_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_AuthSynchronizationFailed_ {
            get {
                return ResourceManager.GetString("Error_AuthSynchronizationFailed_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_AuthUnbindFailed {
            get {
                return ResourceManager.GetString("Error_AuthUnbindFailed", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_BaseDir_StartsWith_Temp {
            get {
                return ResourceManager.GetString("Error_BaseDir_StartsWith_Temp", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_CannotConnectGoogleServer {
            get {
                return ResourceManager.GetString("Error_CannotConnectGoogleServer", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_CannotConnectTokenVerificationServer {
            get {
                return ResourceManager.GetString("Error_CannotConnectTokenVerificationServer", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_CannotFindAccountFile_ {
            get {
                return ResourceManager.GetString("Error_CannotFindAccountFile_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_CloudAuthMaximumQuantity___ {
            get {
                return ResourceManager.GetString("Error_CloudAuthMaximumQuantity___", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_CopyFileFailed {
            get {
                return ResourceManager.GetString("Error_CopyFileFailed", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_CurrentSteamPathIncorrect {
            get {
                return ResourceManager.GetString("Error_CurrentSteamPathIncorrect", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_DataNotUnified {
            get {
                return ResourceManager.GetString("Error_DataNotUnified", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_DelCloudData {
            get {
                return ResourceManager.GetString("Error_DelCloudData", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_DelFileFailedRunning {
            get {
                return ResourceManager.GetString("Error_DelFileFailedRunning", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_EndProcessFailed_ {
            get {
                return ResourceManager.GetString("Error_EndProcessFailed_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_Exception_ {
            get {
                return ResourceManager.GetString("Error_Exception_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_FailedToSynchronizeAuth {
            get {
                return ResourceManager.GetString("Error_FailedToSynchronizeAuth", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_IncompatibleOS {
            get {
                return ResourceManager.GetString("Error_IncompatibleOS", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_IncorrectPlatformPathSelection_ {
            get {
                return ResourceManager.GetString("Error_IncorrectPlatformPathSelection_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_localAuthNotEmpty {
            get {
                return ResourceManager.GetString("Error_localAuthNotEmpty", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_ModifyJsonFileFailed {
            get {
                return ResourceManager.GetString("Error_ModifyJsonFileFailed", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_NotSupportedFileImport {
            get {
                return ResourceManager.GetString("Error_NotSupportedFileImport", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_OperateRegistryFilesFailed {
            get {
                return ResourceManager.GetString("Error_OperateRegistryFilesFailed", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_PageFault {
            get {
                return ResourceManager.GetString("Error_PageFault", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_PathFailedUnableSwitchAccount_ {
            get {
                return ResourceManager.GetString("Error_PathFailedUnableSwitchAccount_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_PleaseEnterAnswer {
            get {
                return ResourceManager.GetString("Error_PleaseEnterAnswer", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_PleaseEnterCode {
            get {
                return ResourceManager.GetString("Error_PleaseEnterCode", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_PleaseEnterEmailCode {
            get {
                return ResourceManager.GetString("Error_PleaseEnterEmailCode", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_PleaseEnterTelCode {
            get {
                return ResourceManager.GetString("Error_PleaseEnterTelCode", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_PleaseEnterUsernamePassword {
            get {
                return ResourceManager.GetString("Error_PleaseEnterUsernamePassword", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_PleaseLoginWattToolKit {
            get {
                return ResourceManager.GetString("Error_PleaseLoginWattToolKit", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_ReadRegistryFailed {
            get {
                return ResourceManager.GetString("Error_ReadRegistryFailed", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_ScanQRCodeFailed_ {
            get {
                return ResourceManager.GetString("Error_ScanQRCodeFailed_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_SetSecurityIssuesFailed {
            get {
                return ResourceManager.GetString("Error_SetSecurityIssuesFailed", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_StartProcessFailed_ {
            get {
                return ResourceManager.GetString("Error_StartProcessFailed_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_SteamGetUserInfo {
            get {
                return ResourceManager.GetString("Error_SteamGetUserInfo", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_TokenPasswordRemovedFailed {
            get {
                return ResourceManager.GetString("Error_TokenPasswordRemovedFailed", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_TokenPasswordSetFailed {
            get {
                return ResourceManager.GetString("Error_TokenPasswordSetFailed", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_UnableSwitchPlatformAccount_ {
            get {
                return ResourceManager.GetString("Error_UnableSwitchPlatformAccount_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_UnknownLogin_ {
            get {
                return ResourceManager.GetString("Error_UnknownLogin_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_UpdateCloudData {
            get {
                return ResourceManager.GetString("Error_UpdateCloudData", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Error_WriteRegistryFailed {
            get {
                return ResourceManager.GetString("Error_WriteRegistryFailed", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ExecutableFile {
            get {
                return ResourceManager.GetString("ExecutableFile", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Exit {
            get {
                return ResourceManager.GetString("Exit", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Export {
            get {
                return ResourceManager.GetString("Export", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ExportAll {
            get {
                return ResourceManager.GetString("ExportAll", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ExportAuth {
            get {
                return ResourceManager.GetString("ExportAuth", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ExportedToPath_ {
            get {
                return ResourceManager.GetString("ExportedToPath_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string FailedGetImageFromSteamGridDB {
            get {
                return ResourceManager.GetString("FailedGetImageFromSteamGridDB", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string FAQ {
            get {
                return ResourceManager.GetString("FAQ", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string FileAttributeIsReadOnlyModifyFailSeeWebPage_ {
            get {
                return ResourceManager.GetString("FileAttributeIsReadOnlyModifyFailSeeWebPage_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string FileAttributeIsReadOnlyModifyFailTryBakDelAgain {
            get {
                return ResourceManager.GetString("FileAttributeIsReadOnlyModifyFailTryBakDelAgain", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string FileNumber {
            get {
                return ResourceManager.GetString("FileNumber", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string FileNumber_ {
            get {
                return ResourceManager.GetString("FileNumber_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string FilePath {
            get {
                return ResourceManager.GetString("FilePath", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string FilePathNotExist {
            get {
                return ResourceManager.GetString("FilePathNotExist", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string FileSize {
            get {
                return ResourceManager.GetString("FileSize", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string FileSizeTooLarge {
            get {
                return ResourceManager.GetString("FileSizeTooLarge", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string FileUnauthorized {
            get {
                return ResourceManager.GetString("FileUnauthorized", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Filter {
            get {
                return ResourceManager.GetString("Filter", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string FilterRequirement {
            get {
                return ResourceManager.GetString("FilterRequirement", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string FixedTop {
            get {
                return ResourceManager.GetString("FixedTop", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string FixNetworkComplete {
            get {
                return ResourceManager.GetString("FixNetworkComplete", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Game_Hidden {
            get {
                return ResourceManager.GetString("Game_Hidden", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Game_LayoutWay {
            get {
                return ResourceManager.GetString("Game_LayoutWay", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameAccelerator {
            get {
                return ResourceManager.GetString("GameAccelerator", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameAccelerator_Accelerate {
            get {
                return ResourceManager.GetString("GameAccelerator_Accelerate", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameAccelerator_AccelerateAreaSelectTip {
            get {
                return ResourceManager.GetString("GameAccelerator_AccelerateAreaSelectTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameAccelerator_ChangeArea {
            get {
                return ResourceManager.GetString("GameAccelerator_ChangeArea", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameAccelerator_GamesEmptyTip {
            get {
                return ResourceManager.GetString("GameAccelerator_GamesEmptyTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameAccelerator_ImmediatelyAccelerate {
            get {
                return ResourceManager.GetString("GameAccelerator_ImmediatelyAccelerate", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameAccelerator_InstallWattAccelerator {
            get {
                return ResourceManager.GetString("GameAccelerator_InstallWattAccelerator", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameAccelerator_SearchGame {
            get {
                return ResourceManager.GetString("GameAccelerator_SearchGame", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameAccelerator_SetShowWattWindow {
            get {
                return ResourceManager.GetString("GameAccelerator_SetShowWattWindow", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameAccelerator_ShowWattAccelerator {
            get {
                return ResourceManager.GetString("GameAccelerator_ShowWattAccelerator", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameAccelerator_Stop {
            get {
                return ResourceManager.GetString("GameAccelerator_Stop", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameAccelerator_UninstallWattAccelerator {
            get {
                return ResourceManager.GetString("GameAccelerator_UninstallWattAccelerator", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameAccelerator_WattAcceleratorInstallPath {
            get {
                return ResourceManager.GetString("GameAccelerator_WattAcceleratorInstallPath", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameAccount_AddNewAccount {
            get {
                return ResourceManager.GetString("GameAccount_AddNewAccount", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameAccount_EndProcessWay {
            get {
                return ResourceManager.GetString("GameAccount_EndProcessWay", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameAccount_SaveCurrentAccount {
            get {
                return ResourceManager.GetString("GameAccount_SaveCurrentAccount", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameAccount_StartProcessWay {
            get {
                return ResourceManager.GetString("GameAccount_StartProcessWay", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList {
            get {
                return ResourceManager.GetString("GameList", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_AddAFKAppsMaxCountTips {
            get {
                return ResourceManager.GetString("GameList_AddAFKAppsMaxCountTips", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_AddAFKAppsSuccess {
            get {
                return ResourceManager.GetString("GameList_AddAFKAppsSuccess", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_AddAFKAppsWarningCountTips {
            get {
                return ResourceManager.GetString("GameList_AddAFKAppsWarningCountTips", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_AddAfkGameList {
            get {
                return ResourceManager.GetString("GameList_AddAfkGameList", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_AddHideAppEmpty {
            get {
                return ResourceManager.GetString("GameList_AddHideAppEmpty", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_AddIdeaAppEmpty {
            get {
                return ResourceManager.GetString("GameList_AddIdeaAppEmpty", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_AutoAFK {
            get {
                return ResourceManager.GetString("GameList_AutoAFK", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_CloudArchiveDeleteAllTip {
            get {
                return ResourceManager.GetString("GameList_CloudArchiveDeleteAllTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_CloudArchiveDeleteTip {
            get {
                return ResourceManager.GetString("GameList_CloudArchiveDeleteTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_CloudArchiveManager {
            get {
                return ResourceManager.GetString("GameList_CloudArchiveManager", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_DeleteAll {
            get {
                return ResourceManager.GetString("GameList_DeleteAll", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_DeleteItem {
            get {
                return ResourceManager.GetString("GameList_DeleteItem", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_DeleteSuccess {
            get {
                return ResourceManager.GetString("GameList_DeleteSuccess", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_EditAppInfo {
            get {
                return ResourceManager.GetString("GameList_EditAppInfo", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_EditedAppsSaveManger {
            get {
                return ResourceManager.GetString("GameList_EditedAppsSaveManger", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_FindAppsText {
            get {
                return ResourceManager.GetString("GameList_FindAppsText", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_HideApp_AllCheck {
            get {
                return ResourceManager.GetString("GameList_HideApp_AllCheck", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_HideAppsSuccess {
            get {
                return ResourceManager.GetString("GameList_HideAppsSuccess", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_HideGameManger {
            get {
                return ResourceManager.GetString("GameList_HideGameManger", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_HideTheGame {
            get {
                return ResourceManager.GetString("GameList_HideTheGame", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_IdleGamesManger {
            get {
                return ResourceManager.GetString("GameList_IdleGamesManger", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_Install {
            get {
                return ResourceManager.GetString("GameList_Install", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_IsEmpty {
            get {
                return ResourceManager.GetString("GameList_IsEmpty", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_IsLoading {
            get {
                return ResourceManager.GetString("GameList_IsLoading", resourceCulture);
            }
        }
        
        
/   查找类似 已添加 ({0}/{1}) 的本地化字符串。
        
/ </summary>
        public static string GameList_ListCount {
            get {
                return ResourceManager.GetString("GameList_ListCount", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_LoaingTips {
            get {
                return ResourceManager.GetString("GameList_LoaingTips", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_NavScreenshotToSteamView {
            get {
                return ResourceManager.GetString("GameList_NavScreenshotToSteamView", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_NavToSteamView {
            get {
                return ResourceManager.GetString("GameList_NavToSteamView", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_OnlyCloudArchive {
            get {
                return ResourceManager.GetString("GameList_OnlyCloudArchive", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_OnlyInstalled {
            get {
                return ResourceManager.GetString("GameList_OnlyInstalled", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_OpenFolder {
            get {
                return ResourceManager.GetString("GameList_OpenFolder", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_OpenSteamCardUrl {
            get {
                return ResourceManager.GetString("GameList_OpenSteamCardUrl", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_OpenSteamDBUrl {
            get {
                return ResourceManager.GetString("GameList_OpenSteamDBUrl", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_OpenSteamGridUrl {
            get {
                return ResourceManager.GetString("GameList_OpenSteamGridUrl", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_OpenStoreUrl {
            get {
                return ResourceManager.GetString("GameList_OpenStoreUrl", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_OperationSuccess {
            get {
                return ResourceManager.GetString("GameList_OperationSuccess", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_Play {
            get {
                return ResourceManager.GetString("GameList_Play", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_RefreshGamesList {
            get {
                return ResourceManager.GetString("GameList_RefreshGamesList", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_RefreshGamesListSucess {
            get {
                return ResourceManager.GetString("GameList_RefreshGamesListSucess", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_RemoveBtn {
            get {
                return ResourceManager.GetString("GameList_RemoveBtn", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_RemoveItemBtn {
            get {
                return ResourceManager.GetString("GameList_RemoveItemBtn", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_ResizeAppLogo {
            get {
                return ResourceManager.GetString("GameList_ResizeAppLogo", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_RuningBtn {
            get {
                return ResourceManager.GetString("GameList_RuningBtn", resourceCulture);
            }
        }
        
        
/   查找类似 正在运行 {0}/{1} 的本地化字符串。
        
/ </summary>
        public static string GameList_RuningCount {
            get {
                return ResourceManager.GetString("GameList_RuningCount", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_RuningItemBtn {
            get {
                return ResourceManager.GetString("GameList_RuningItemBtn", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_RuningWait {
            get {
                return ResourceManager.GetString("GameList_RuningWait", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_RunOtherAppCount_ {
            get {
                return ResourceManager.GetString("GameList_RunOtherAppCount_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_RunState {
            get {
                return ResourceManager.GetString("GameList_RunState", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_SetCustomImage {
            get {
                return ResourceManager.GetString("GameList_SetCustomImage", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_SteamShutdown {
            get {
                return ResourceManager.GetString("GameList_SteamShutdown", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_SteamShutdown_AppsEmpty {
            get {
                return ResourceManager.GetString("GameList_SteamShutdown_AppsEmpty", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_SteamShutdown_DownloadComplete {
            get {
                return ResourceManager.GetString("GameList_SteamShutdown_DownloadComplete", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_SteamShutdown_DownloadCompleteTip {
            get {
                return ResourceManager.GetString("GameList_SteamShutdown_DownloadCompleteTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_SteamShutdown_EnableWatchDownloading {
            get {
                return ResourceManager.GetString("GameList_SteamShutdown_EnableWatchDownloading", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_StopBtn {
            get {
                return ResourceManager.GetString("GameList_StopBtn", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_StopItemBtn {
            get {
                return ResourceManager.GetString("GameList_StopItemBtn", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_StopState {
            get {
                return ResourceManager.GetString("GameList_StopState", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_Unsupport {
            get {
                return ResourceManager.GetString("GameList_Unsupport", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameList_UploadCloudArchiveFile {
            get {
                return ResourceManager.GetString("GameList_UploadCloudArchiveFile", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameRelated {
            get {
                return ResourceManager.GetString("GameRelated", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameRelated_Borderless {
            get {
                return ResourceManager.GetString("GameRelated_Borderless", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameRelated_Borderless_BorderlessWindow {
            get {
                return ResourceManager.GetString("GameRelated_Borderless_BorderlessWindow", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameRelated_Borderless_ClassName {
            get {
                return ResourceManager.GetString("GameRelated_Borderless_ClassName", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameRelated_Borderless_Hide {
            get {
                return ResourceManager.GetString("GameRelated_Borderless_Hide", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameRelated_Borderless_KillProcess {
            get {
                return ResourceManager.GetString("GameRelated_Borderless_KillProcess", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameRelated_Borderless_Maximize {
            get {
                return ResourceManager.GetString("GameRelated_Borderless_Maximize", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameRelated_Borderless_MoveMouseTip {
            get {
                return ResourceManager.GetString("GameRelated_Borderless_MoveMouseTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameRelated_Borderless_Normal {
            get {
                return ResourceManager.GetString("GameRelated_Borderless_Normal", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameRelated_Borderless_Path {
            get {
                return ResourceManager.GetString("GameRelated_Borderless_Path", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameRelated_Borderless_Process {
            get {
                return ResourceManager.GetString("GameRelated_Borderless_Process", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameRelated_Borderless_ResetWallerpaper {
            get {
                return ResourceManager.GetString("GameRelated_Borderless_ResetWallerpaper", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameRelated_Borderless_Show {
            get {
                return ResourceManager.GetString("GameRelated_Borderless_Show", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameRelated_Borderless_Title {
            get {
                return ResourceManager.GetString("GameRelated_Borderless_Title", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameRelated_Borderless_ToWallerpaper {
            get {
                return ResourceManager.GetString("GameRelated_Borderless_ToWallerpaper", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GameRelated_Borderless_ToWallerpaperTip {
            get {
                return ResourceManager.GetString("GameRelated_Borderless_ToWallerpaperTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Gender {
            get {
                return ResourceManager.GetString("Gender", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GeneralAuth_Code {
            get {
                return ResourceManager.GetString("GeneralAuth_Code", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GeneralAuth_EnterkeyOrLink {
            get {
                return ResourceManager.GetString("GeneralAuth_EnterkeyOrLink", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GeneralAuth_ImportText {
            get {
                return ResourceManager.GetString("GeneralAuth_ImportText", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GeneralAuth_Name {
            get {
                return ResourceManager.GetString("GeneralAuth_Name", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GeneralAuth_VerifySuccessfulImport {
            get {
                return ResourceManager.GetString("GeneralAuth_VerifySuccessfulImport", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GetImageFromSteamGridDB {
            get {
                return ResourceManager.GetString("GetImageFromSteamGridDB", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Google {
            get {
                return ResourceManager.GetString("Google", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Helper {
            get {
                return ResourceManager.GetString("Helper", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string HorizontalTitlePage {
            get {
                return ResourceManager.GetString("HorizontalTitlePage", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Hosts_Exists {
            get {
                return ResourceManager.GetString("Hosts_Exists", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Hosts_ReadError {
            get {
                return ResourceManager.GetString("Hosts_ReadError", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Hosts_ReadSuccess {
            get {
                return ResourceManager.GetString("Hosts_ReadSuccess", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Hosts_UpdateSuccess {
            get {
                return ResourceManager.GetString("Hosts_UpdateSuccess", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Hosts_WirteError {
            get {
                return ResourceManager.GetString("Hosts_WirteError", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string HOTP {
            get {
                return ResourceManager.GetString("HOTP", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Icon {
            get {
                return ResourceManager.GetString("Icon", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Idle_Complete {
            get {
                return ResourceManager.GetString("Idle_Complete", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Idle_GetBadgesError {
            get {
                return ResourceManager.GetString("Idle_GetBadgesError", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Idle_LoaingTips {
            get {
                return ResourceManager.GetString("Idle_LoaingTips", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Idle_NeedLoginSteam {
            get {
                return ResourceManager.GetString("Idle_NeedLoginSteam", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Idle_NeedParentalPIN {
            get {
                return ResourceManager.GetString("Idle_NeedParentalPIN", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Idle_OpenAutoNext {
            get {
                return ResourceManager.GetString("Idle_OpenAutoNext", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Idle_OperationSuccess {
            get {
                return ResourceManager.GetString("Idle_OperationSuccess", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Idle_PIN_NotBeNull {
            get {
                return ResourceManager.GetString("Idle_PIN_NotBeNull", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Idle_PleaseStartIdle {
            get {
                return ResourceManager.GetString("Idle_PleaseStartIdle", resourceCulture);
            }
        }
        
        
/   查找类似 正在运行 {0}/{1} 的本地化字符串。
        
/ </summary>
        public static string Idle_RuningCount {
            get {
                return ResourceManager.GetString("Idle_RuningCount", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Idle_StartError {
            get {
                return ResourceManager.GetString("Idle_StartError", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Idle_StopAutoNext {
            get {
                return ResourceManager.GetString("Idle_StopAutoNext", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Import {
            get {
                return ResourceManager.GetString("Import", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Info {
            get {
                return ResourceManager.GetString("Info", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Info_AccountAlreadyLogin {
            get {
                return ResourceManager.GetString("Info_AccountAlreadyLogin", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Info_AlreadyTheCurrentAccount {
            get {
                return ResourceManager.GetString("Info_AlreadyTheCurrentAccount", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Info_AuthMaximumQuantity {
            get {
                return ResourceManager.GetString("Info_AuthMaximumQuantity", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Info_LoadingAgentTakesTime____ {
            get {
                return ResourceManager.GetString("Info_LoadingAgentTakesTime____", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Info_PleaseEnterImportText {
            get {
                return ResourceManager.GetString("Info_PleaseEnterImportText", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Info_PleaseVerifyFirstAuthCode {
            get {
                return ResourceManager.GetString("Info_PleaseVerifyFirstAuthCode", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Info_SteamDesktopAuthImportMessage_ {
            get {
                return ResourceManager.GetString("Info_SteamDesktopAuthImportMessage_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Info_V1ImportMessage_ {
            get {
                return ResourceManager.GetString("Info_V1ImportMessage_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Info_V2ImportMessage_ {
            get {
                return ResourceManager.GetString("Info_V2ImportMessage_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Info_WinAuthImportMessage_ {
            get {
                return ResourceManager.GetString("Info_WinAuthImportMessage_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Installed {
            get {
                return ResourceManager.GetString("Installed", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string InstalledPath {
            get {
                return ResourceManager.GetString("InstalledPath", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string IsExistUpdateFalse {
            get {
                return ResourceManager.GetString("IsExistUpdateFalse", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string JoinUs {
            get {
                return ResourceManager.GetString("JoinUs", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LastUpdatedDateTime {
            get {
                return ResourceManager.GetString("LastUpdatedDateTime", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Launch {
            get {
                return ResourceManager.GetString("Launch", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LaunchItem {
            get {
                return ResourceManager.GetString("LaunchItem", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Library {
            get {
                return ResourceManager.GetString("Library", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Link {
            get {
                return ResourceManager.GetString("Link", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LinuxSudoTips {
            get {
                return ResourceManager.GetString("LinuxSudoTips", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Loading {
            get {
                return ResourceManager.GetString("Loading", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth {
            get {
                return ResourceManager.GetString("LocalAuth", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_2FAImport {
            get {
                return ResourceManager.GetString("LocalAuth_2FAImport", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_AddAuth {
            get {
                return ResourceManager.GetString("LocalAuth_AddAuth", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_AddAuth_PartSuccess {
            get {
                return ResourceManager.GetString("LocalAuth_AddAuth_PartSuccess", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_AddAuthSuccess {
            get {
                return ResourceManager.GetString("LocalAuth_AddAuthSuccess", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_AddAuthSyncTip {
            get {
                return ResourceManager.GetString("LocalAuth_AddAuthSyncTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_AuthTrade {
            get {
                return ResourceManager.GetString("LocalAuth_AuthTrade", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_AuthTrade_Confirm {
            get {
                return ResourceManager.GetString("LocalAuth_AuthTrade_Confirm", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_AuthTrade_ConfirmError {
            get {
                return ResourceManager.GetString("LocalAuth_AuthTrade_ConfirmError", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_AuthTrade_ConfirmTip_ {
            get {
                return ResourceManager.GetString("LocalAuth_AuthTrade_ConfirmTip_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_AuthTrade_GetError {
            get {
                return ResourceManager.GetString("LocalAuth_AuthTrade_GetError", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_AuthTrade_GetError3 {
            get {
                return ResourceManager.GetString("LocalAuth_AuthTrade_GetError3", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_AuthTrade_GetTip {
            get {
                return ResourceManager.GetString("LocalAuth_AuthTrade_GetTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_AuthTrade_MessageBoxTip_ {
            get {
                return ResourceManager.GetString("LocalAuth_AuthTrade_MessageBoxTip_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_AuthTrade_Null {
            get {
                return ResourceManager.GetString("LocalAuth_AuthTrade_Null", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_AuthTrade_SelectNull {
            get {
                return ResourceManager.GetString("LocalAuth_AuthTrade_SelectNull", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_CloudSync {
            get {
                return ResourceManager.GetString("LocalAuth_CloudSync", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_Copy {
            get {
                return ResourceManager.GetString("LocalAuth_Copy", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_CopyAuthTip {
            get {
                return ResourceManager.GetString("LocalAuth_CopyAuthTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_Delete {
            get {
                return ResourceManager.GetString("LocalAuth_Delete", resourceCulture);
            }
        }
        
        
/store.steampowered.com/twofactor/manage 解绑后在删除。 的本地化字符串。
        
/ </summary>
        public static string LocalAuth_DeleteAuthTip {
            get {
                return ResourceManager.GetString("LocalAuth_DeleteAuthTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_DeleteAuthTip2 {
            get {
                return ResourceManager.GetString("LocalAuth_DeleteAuthTip2", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_EmailCodeTip {
            get {
                return ResourceManager.GetString("LocalAuth_EmailCodeTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_ExportAuth {
            get {
                return ResourceManager.GetString("LocalAuth_ExportAuth", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_ExportAuth_Error {
            get {
                return ResourceManager.GetString("LocalAuth_ExportAuth_Error", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_ExportAuth_Error_ {
            get {
                return ResourceManager.GetString("LocalAuth_ExportAuth_Error_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_ExportAuth_SelectPath {
            get {
                return ResourceManager.GetString("LocalAuth_ExportAuth_SelectPath", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_GoogleImport {
            get {
                return ResourceManager.GetString("LocalAuth_GoogleImport", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_HOTPImport {
            get {
                return ResourceManager.GetString("LocalAuth_HOTPImport", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_Import {
            get {
                return ResourceManager.GetString("LocalAuth_Import", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_Import_DecodePrivateKeyError {
            get {
                return ResourceManager.GetString("LocalAuth_Import_DecodePrivateKeyError", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_ImportSuccessTip_ {
            get {
                return ResourceManager.GetString("LocalAuth_ImportSuccessTip_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_JoinSteamAuthenticator {
            get {
                return ResourceManager.GetString("LocalAuth_JoinSteamAuthenticator", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_JoinSteamAuthenticator_ConfirmSteamAppAuthenticatorCode {
            get {
                return ResourceManager.GetString("LocalAuth_JoinSteamAuthenticator_ConfirmSteamAppAuthenticatorCode", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_JoinSteamAuthenticator_InitLocalAuthenticatorError {
            get {
                return ResourceManager.GetString("LocalAuth_JoinSteamAuthenticator_InitLocalAuthenticatorError", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_JoinSteamAuthenticator_InputSteamAppAuthenticatorCode {
            get {
                return ResourceManager.GetString("LocalAuth_JoinSteamAuthenticator_InputSteamAppAuthenticatorCode", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_JoinSteamAuthenticator_InputSteamAppAuthenticatorCodeTips {
            get {
                return ResourceManager.GetString("LocalAuth_JoinSteamAuthenticator_InputSteamAppAuthenticatorCodeTips", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_JoinSteamAuthenticator_LoginRequestError {
            get {
                return ResourceManager.GetString("LocalAuth_JoinSteamAuthenticator_LoginRequestError", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_JoinSteamAuthenticator_ParseUser2FAInfoError {
            get {
                return ResourceManager.GetString("LocalAuth_JoinSteamAuthenticator_ParseUser2FAInfoError", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_JoinSteamAuthenticator_RequestUser2FAInfoError {
            get {
                return ResourceManager.GetString("LocalAuth_JoinSteamAuthenticator_RequestUser2FAInfoError", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_JoinSteamAuthenticator_SaveLocalAuthenticatorError {
            get {
                return ResourceManager.GetString("LocalAuth_JoinSteamAuthenticator_SaveLocalAuthenticatorError", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_JoinSteamAuthenticator_SteamAppAuthenticatorCode {
            get {
                return ResourceManager.GetString("LocalAuth_JoinSteamAuthenticator_SteamAppAuthenticatorCode", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_JoinSteamAuthenticator_SteamGuardCodeEmptyError {
            get {
                return ResourceManager.GetString("LocalAuth_JoinSteamAuthenticator_SteamGuardCodeEmptyError", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_JoinSteamAuthenticator_VerifySteamGuardCodeError {
            get {
                return ResourceManager.GetString("LocalAuth_JoinSteamAuthenticator_VerifySteamGuardCodeError", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_JoinSteamAuthenticatorDesc {
            get {
                return ResourceManager.GetString("LocalAuth_JoinSteamAuthenticatorDesc", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_LogoutTip {
            get {
                return ResourceManager.GetString("LocalAuth_LogoutTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_MicrosoftImport {
            get {
                return ResourceManager.GetString("LocalAuth_MicrosoftImport", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_NoAuthTip {
            get {
                return ResourceManager.GetString("LocalAuth_NoAuthTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_PasswordRequired {
            get {
                return ResourceManager.GetString("LocalAuth_PasswordRequired", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_PasswordRequired1 {
            get {
                return ResourceManager.GetString("LocalAuth_PasswordRequired1", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_ProtectionAuth {
            get {
                return ResourceManager.GetString("LocalAuth_ProtectionAuth", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_ProtectionAuth_EnablePassword {
            get {
                return ResourceManager.GetString("LocalAuth_ProtectionAuth_EnablePassword", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_ProtectionAuth_EnablePasswordTip {
            get {
                return ResourceManager.GetString("LocalAuth_ProtectionAuth_EnablePasswordTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_ProtectionAuth_Info {
            get {
                return ResourceManager.GetString("LocalAuth_ProtectionAuth_Info", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_ProtectionAuth_IsOnlyCurrentComputerEncrypt {
            get {
                return ResourceManager.GetString("LocalAuth_ProtectionAuth_IsOnlyCurrentComputerEncrypt", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_ProtectionAuth_IsOnlyCurrentComputerEncryptTip {
            get {
                return ResourceManager.GetString("LocalAuth_ProtectionAuth_IsOnlyCurrentComputerEncryptTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_ProtectionAuth_Password {
            get {
                return ResourceManager.GetString("LocalAuth_ProtectionAuth_Password", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_ProtectionAuth_PasswordError {
            get {
                return ResourceManager.GetString("LocalAuth_ProtectionAuth_PasswordError", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_ProtectionAuth_PasswordErrorTip {
            get {
                return ResourceManager.GetString("LocalAuth_ProtectionAuth_PasswordErrorTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_ProtectionAuth_PathError {
            get {
                return ResourceManager.GetString("LocalAuth_ProtectionAuth_PathError", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_ProtectionAuth_VerifyPassword {
            get {
                return ResourceManager.GetString("LocalAuth_ProtectionAuth_VerifyPassword", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_RemoveAuth {
            get {
                return ResourceManager.GetString("LocalAuth_RemoveAuth", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_SDAImport {
            get {
                return ResourceManager.GetString("LocalAuth_SDAImport", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_ShowAuthInfo {
            get {
                return ResourceManager.GetString("LocalAuth_ShowAuthInfo", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_ShowSteamAuthTip1 {
            get {
                return ResourceManager.GetString("LocalAuth_ShowSteamAuthTip1", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_ShowSteamAuthTip2 {
            get {
                return ResourceManager.GetString("LocalAuth_ShowSteamAuthTip2", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_SMSCodeTip {
            get {
                return ResourceManager.GetString("LocalAuth_SMSCodeTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_Steam2FACodeTip {
            get {
                return ResourceManager.GetString("LocalAuth_Steam2FACodeTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_SteamAppAddSuccess {
            get {
                return ResourceManager.GetString("LocalAuth_SteamAppAddSuccess", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_SteamAppImportTip {
            get {
                return ResourceManager.GetString("LocalAuth_SteamAppImportTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_SteamGuardImport {
            get {
                return ResourceManager.GetString("LocalAuth_SteamGuardImport", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_SteamGuardTip {
            get {
                return ResourceManager.GetString("LocalAuth_SteamGuardTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_SteamUser_Error {
            get {
                return ResourceManager.GetString("LocalAuth_SteamUser_Error", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_SteamUser_Requires2FA {
            get {
                return ResourceManager.GetString("LocalAuth_SteamUser_Requires2FA", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_SteamUserImportSuccess {
            get {
                return ResourceManager.GetString("LocalAuth_SteamUserImportSuccess", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_SteamUUID {
            get {
                return ResourceManager.GetString("LocalAuth_SteamUUID", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_SteamuuidTip {
            get {
                return ResourceManager.GetString("LocalAuth_SteamuuidTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_VerifyCode {
            get {
                return ResourceManager.GetString("LocalAuth_VerifyCode", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_WattToolKitV1Import {
            get {
                return ResourceManager.GetString("LocalAuth_WattToolKitV1Import", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_WattToolKitV2Import {
            get {
                return ResourceManager.GetString("LocalAuth_WattToolKitV2Import", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LocalAuth_WinAuthImport {
            get {
                return ResourceManager.GetString("LocalAuth_WinAuthImport", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Login {
            get {
                return ResourceManager.GetString("Login", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Login_ManualLogin {
            get {
                return ResourceManager.GetString("Login_ManualLogin", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Login_ManualLoginEmpt {
            get {
                return ResourceManager.GetString("Login_ManualLoginEmpt", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Login_WebSocketOnMessage {
            get {
                return ResourceManager.GetString("Login_WebSocketOnMessage", resourceCulture);
            }
        }
        
        
/   查找类似 登录 / 注册 的本地化字符串。
        
/ </summary>
        public static string LoginAndRegister {
            get {
                return ResourceManager.GetString("LoginAndRegister", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Logining {
            get {
                return ResourceManager.GetString("Logining", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LoginInputManualLoginToken {
            get {
                return ResourceManager.GetString("LoginInputManualLoginToken", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LoginVerify {
            get {
                return ResourceManager.GetString("LoginVerify", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Logout {
            get {
                return ResourceManager.GetString("Logout", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string MacSudoPasswordTips {
            get {
                return ResourceManager.GetString("MacSudoPasswordTips", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string MacTrustRootCertificateTips {
            get {
                return ResourceManager.GetString("MacTrustRootCertificateTips", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Mafile {
            get {
                return ResourceManager.GetString("Mafile", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Maximize {
            get {
                return ResourceManager.GetString("Maximize", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Media {
            get {
                return ResourceManager.GetString("Media", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Message_AreYouSureYouWantToDeleteTheAccount {
            get {
                return ResourceManager.GetString("Message_AreYouSureYouWantToDeleteTheAccount", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Microsoft {
            get {
                return ResourceManager.GetString("Microsoft", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Minimize {
            get {
                return ResourceManager.GetString("Minimize", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ModelContent_CancelAllTrade {
            get {
                return ResourceManager.GetString("ModelContent_CancelAllTrade", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ModelContent_CancelTrade {
            get {
                return ResourceManager.GetString("ModelContent_CancelTrade", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ModelContent_ConfirmAllTrade {
            get {
                return ResourceManager.GetString("ModelContent_ConfirmAllTrade", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ModelContent_ConfirmTrade___ {
            get {
                return ResourceManager.GetString("ModelContent_ConfirmTrade___", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ModelContent_ConfirmTrade2_ {
            get {
                return ResourceManager.GetString("ModelContent_ConfirmTrade2_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ModelContent_ConfirmUnbinding {
            get {
                return ResourceManager.GetString("ModelContent_ConfirmUnbinding", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ModelContent_ExportPassword {
            get {
                return ResourceManager.GetString("ModelContent_ExportPassword", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ModelContent_ImportSuccessful_ {
            get {
                return ResourceManager.GetString("ModelContent_ImportSuccessful_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ModelContent_LoginNewUser {
            get {
                return ResourceManager.GetString("ModelContent_LoginNewUser", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ModelContent_SecretKey_ {
            get {
                return ResourceManager.GetString("ModelContent_SecretKey_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Modify {
            get {
                return ResourceManager.GetString("Modify", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string More {
            get {
                return ResourceManager.GetString("More", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string MoreInfo {
            get {
                return ResourceManager.GetString("MoreInfo", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string MoveDown {
            get {
                return ResourceManager.GetString("MoveDown", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string MoveUp {
            get {
                return ResourceManager.GetString("MoveUp", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string My {
            get {
                return ResourceManager.GetString("My", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string MyOrder {
            get {
                return ResourceManager.GetString("MyOrder", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Name {
            get {
                return ResourceManager.GetString("Name", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string NewFeatureDevelopment {
            get {
                return ResourceManager.GetString("NewFeatureDevelopment", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string NewVersionUpdate {
            get {
                return ResourceManager.GetString("NewVersionUpdate", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string NewVersionUpdateNotifyText_ {
            get {
                return ResourceManager.GetString("NewVersionUpdateNotifyText_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string NewVersionUpdateTitle__ {
            get {
                return ResourceManager.GetString("NewVersionUpdateTitle__", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string NickName {
            get {
                return ResourceManager.GetString("NickName", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Notice_Tray_Content_ {
            get {
                return ResourceManager.GetString("Notice_Tray_Content_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Notice_Tray_Title {
            get {
                return ResourceManager.GetString("Notice_Tray_Title", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string NotificationChannelType_Description_Announcement {
            get {
                return ResourceManager.GetString("NotificationChannelType_Description_Announcement", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string NotificationChannelType_Description_ForegroundService {
            get {
                return ResourceManager.GetString("NotificationChannelType_Description_ForegroundService", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string NotificationChannelType_Description_Message {
            get {
                return ResourceManager.GetString("NotificationChannelType_Description_Message", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string NotificationChannelType_Description_NewVersion {
            get {
                return ResourceManager.GetString("NotificationChannelType_Description_NewVersion", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string NotificationChannelType_Name_Announcement {
            get {
                return ResourceManager.GetString("NotificationChannelType_Name_Announcement", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string NotificationChannelType_Name_ForegroundService {
            get {
                return ResourceManager.GetString("NotificationChannelType_Name_ForegroundService", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string NotificationChannelType_Name_Message {
            get {
                return ResourceManager.GetString("NotificationChannelType_Name_Message", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string NotificationChannelType_Name_NewVersion {
            get {
                return ResourceManager.GetString("NotificationChannelType_Name_NewVersion", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Off {
            get {
                return ResourceManager.GetString("Off", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string On {
            get {
                return ResourceManager.GetString("On", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string OnHook {
            get {
                return ResourceManager.GetString("OnHook", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string OpenImageInBrowser {
            get {
                return ResourceManager.GetString("OpenImageInBrowser", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string OpenInBrowser {
            get {
                return ResourceManager.GetString("OpenInBrowser", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string OpenLink {
            get {
                return ResourceManager.GetString("OpenLink", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string OpenMainWindow {
            get {
                return ResourceManager.GetString("OpenMainWindow", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string OpenOfficialWebsite {
            get {
                return ResourceManager.GetString("OpenOfficialWebsite", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string OpenSourceLibrary {
            get {
                return ResourceManager.GetString("OpenSourceLibrary", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string OpenSteamGridDBInBrowser {
            get {
                return ResourceManager.GetString("OpenSteamGridDBInBrowser", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string OpenTheAuthorPageInBrowser {
            get {
                return ResourceManager.GetString("OpenTheAuthorPageInBrowser", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string OperationHostsError_ {
            get {
                return ResourceManager.GetString("OperationHostsError_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string OSExitMode_Hibernate {
            get {
                return ResourceManager.GetString("OSExitMode_Hibernate", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string OSExitMode_Lock {
            get {
                return ResourceManager.GetString("OSExitMode_Lock", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string OSExitMode_Shutdown {
            get {
                return ResourceManager.GetString("OSExitMode_Shutdown", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string OSExitMode_Sleep {
            get {
                return ResourceManager.GetString("OSExitMode_Sleep", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Paste {
            get {
                return ResourceManager.GetString("Paste", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string PersonalCenter {
            get {
                return ResourceManager.GetString("PersonalCenter", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string PersonalSafe {
            get {
                return ResourceManager.GetString("PersonalSafe", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string PictureZoom {
            get {
                return ResourceManager.GetString("PictureZoom", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string PleaseEnterNickName {
            get {
                return ResourceManager.GetString("PleaseEnterNickName", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Plugin_Author {
            get {
                return ResourceManager.GetString("Plugin_Author", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Plugin_Delete {
            get {
                return ResourceManager.GetString("Plugin_Delete", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Plugin_DeleteComfirm {
            get {
                return ResourceManager.GetString("Plugin_DeleteComfirm", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Plugin_DeleteSuccess {
            get {
                return ResourceManager.GetString("Plugin_DeleteSuccess", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Plugin_FileError {
            get {
                return ResourceManager.GetString("Plugin_FileError", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Plugin_IllegalAuthor {
            get {
                return ResourceManager.GetString("Plugin_IllegalAuthor", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Plugin_InstalledPlugins {
            get {
                return ResourceManager.GetString("Plugin_InstalledPlugins", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Plugin_ManageAllInstalledPlugins {
            get {
                return ResourceManager.GetString("Plugin_ManageAllInstalledPlugins", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Plugin_NeedDisable {
            get {
                return ResourceManager.GetString("Plugin_NeedDisable", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Plugin_OfficialAuthor_ {
            get {
                return ResourceManager.GetString("Plugin_OfficialAuthor_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Plugin_OnlyLoadOfficePlugins {
            get {
                return ResourceManager.GetString("Plugin_OnlyLoadOfficePlugins", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Plugin_OpenAppDataFolder {
            get {
                return ResourceManager.GetString("Plugin_OpenAppDataFolder", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Plugin_OpenCacheFolder {
            get {
                return ResourceManager.GetString("Plugin_OpenCacheFolder", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Plugin_OpenFolder {
            get {
                return ResourceManager.GetString("Plugin_OpenFolder", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Plugin_SafeMode {
            get {
                return ResourceManager.GetString("Plugin_SafeMode", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Plugin_Store {
            get {
                return ResourceManager.GetString("Plugin_Store", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Plugin_UnknownAuthor {
            get {
                return ResourceManager.GetString("Plugin_UnknownAuthor", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Plugin_Version {
            get {
                return ResourceManager.GetString("Plugin_Version", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string PreviewPictures {
            get {
                return ResourceManager.GetString("PreviewPictures", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ProxyMode_DNSIntercept {
            get {
                return ResourceManager.GetString("ProxyMode_DNSIntercept", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ProxyMode_Hosts {
            get {
                return ResourceManager.GetString("ProxyMode_Hosts", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ProxyMode_ProxyOnly {
            get {
                return ResourceManager.GetString("ProxyMode_ProxyOnly", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ProxyMode_System {
            get {
                return ResourceManager.GetString("ProxyMode_System", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ProxyMode_VPN {
            get {
                return ResourceManager.GetString("ProxyMode_VPN", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Publisher {
            get {
                return ResourceManager.GetString("Publisher", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string RatingsAndReviews {
            get {
                return ResourceManager.GetString("RatingsAndReviews", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string RecommendedResolution {
            get {
                return ResourceManager.GetString("RecommendedResolution", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string RecoveryCode {
            get {
                return ResourceManager.GetString("RecoveryCode", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string RecoveryCode_Remember {
            get {
                return ResourceManager.GetString("RecoveryCode_Remember", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string RecoveryCode_RememberTip {
            get {
                return ResourceManager.GetString("RecoveryCode_RememberTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Refresh {
            get {
                return ResourceManager.GetString("Refresh", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string RefreshAvatar {
            get {
                return ResourceManager.GetString("RefreshAvatar", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string RefreshList {
            get {
                return ResourceManager.GetString("RefreshList", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string RefreshOK {
            get {
                return ResourceManager.GetString("RefreshOK", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string RememberChooseNotToAskAgain {
            get {
                return ResourceManager.GetString("RememberChooseNotToAskAgain", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Reset {
            get {
                return ResourceManager.GetString("Reset", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ResetAll {
            get {
                return ResourceManager.GetString("ResetAll", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Restore {
            get {
                return ResourceManager.GetString("Restore", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Retract {
            get {
                return ResourceManager.GetString("Retract", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Retry {
            get {
                return ResourceManager.GetString("Retry", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Save {
            get {
                return ResourceManager.GetString("Save", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SaveChanges {
            get {
                return ResourceManager.GetString("SaveChanges", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SaveEditedAppInfo_AppsEmpty {
            get {
                return ResourceManager.GetString("SaveEditedAppInfo_AppsEmpty", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SaveEditedAppInfo_EmptyAppsTip {
            get {
                return ResourceManager.GetString("SaveEditedAppInfo_EmptyAppsTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SaveEditedAppInfo_RestartSteamTip {
            get {
                return ResourceManager.GetString("SaveEditedAppInfo_RestartSteamTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SaveEditedAppInfo_SaveFailed {
            get {
                return ResourceManager.GetString("SaveEditedAppInfo_SaveFailed", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SaveEditedAppInfo_SaveToSteam {
            get {
                return ResourceManager.GetString("SaveEditedAppInfo_SaveToSteam", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SaveEditedAppInfo_SaveToSteamFailed {
            get {
                return ResourceManager.GetString("SaveEditedAppInfo_SaveToSteamFailed", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SaveEditedAppInfo_SaveToSteamSuccess {
            get {
                return ResourceManager.GetString("SaveEditedAppInfo_SaveToSteamSuccess", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SaveEditedAppInfo_SelectImageFailed {
            get {
                return ResourceManager.GetString("SaveEditedAppInfo_SelectImageFailed", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SaveEditedAppInfo_SteamUserNullTip {
            get {
                return ResourceManager.GetString("SaveEditedAppInfo_SteamUserNullTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SaveFile {
            get {
                return ResourceManager.GetString("SaveFile", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SaveImageFileFailed {
            get {
                return ResourceManager.GetString("SaveImageFileFailed", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ScanQRCode {
            get {
                return ResourceManager.GetString("ScanQRCode", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Script_AutoUpdate {
            get {
                return ResourceManager.GetString("Script_AutoUpdate", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Script_BuildDownloadError__ {
            get {
                return ResourceManager.GetString("Script_BuildDownloadError__", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Script_BuildError_ {
            get {
                return ResourceManager.GetString("Script_BuildError_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Script_CacheDeleteError_ {
            get {
                return ResourceManager.GetString("Script_CacheDeleteError_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Script_DeleteError {
            get {
                return ResourceManager.GetString("Script_DeleteError", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Script_DeleteItem {
            get {
                return ResourceManager.GetString("Script_DeleteItem", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Script_DeleteSuccess {
            get {
                return ResourceManager.GetString("Script_DeleteSuccess", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Script_Edit {
            get {
                return ResourceManager.GetString("Script_Edit", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Script_EditTxt {
            get {
                return ResourceManager.GetString("Script_EditTxt", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Script_FileDeleteError_ {
            get {
                return ResourceManager.GetString("Script_FileDeleteError_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Script_FileError_ {
            get {
                return ResourceManager.GetString("Script_FileError_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Script_FileRepeat {
            get {
                return ResourceManager.GetString("Script_FileRepeat", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Script_Home {
            get {
                return ResourceManager.GetString("Script_Home", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Script_ImportLoading {
            get {
                return ResourceManager.GetString("Script_ImportLoading", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Script_NoFile_ {
            get {
                return ResourceManager.GetString("Script_NoFile_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Script_NoFileDeleteError_ {
            get {
                return ResourceManager.GetString("Script_NoFileDeleteError_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Script_NoFileDeleteItem {
            get {
                return ResourceManager.GetString("Script_NoFileDeleteItem", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Script_ReadFileError_ {
            get {
                return ResourceManager.GetString("Script_ReadFileError_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Script_Refresh {
            get {
                return ResourceManager.GetString("Script_Refresh", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Script_ReplaceTips {
            get {
                return ResourceManager.GetString("Script_ReplaceTips", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Script_SaveDBError {
            get {
                return ResourceManager.GetString("Script_SaveDBError", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Script_SaveDbSuccess {
            get {
                return ResourceManager.GetString("Script_SaveDbSuccess", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Script_Settings {
            get {
                return ResourceManager.GetString("Script_Settings", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Script_Update {
            get {
                return ResourceManager.GetString("Script_Update", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Script_UpdateError {
            get {
                return ResourceManager.GetString("Script_UpdateError", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ScriptConfig {
            get {
                return ResourceManager.GetString("ScriptConfig", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ScriptShop_GetTableError {
            get {
                return ResourceManager.GetString("ScriptShop_GetTableError", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ScriptStore {
            get {
                return ResourceManager.GetString("ScriptStore", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Search {
            get {
                return ResourceManager.GetString("Search", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SelectAll {
            get {
                return ResourceManager.GetString("SelectAll", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SelectFile {
            get {
                return ResourceManager.GetString("SelectFile", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SelectFilepath {
            get {
                return ResourceManager.GetString("SelectFilepath", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SelectPicture {
            get {
                return ResourceManager.GetString("SelectPicture", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SetBootAutoStartTrueFail_ {
            get {
                return ResourceManager.GetString("SetBootAutoStartTrueFail_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings {
            get {
                return ResourceManager.GetString("Settings", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_Auth {
            get {
                return ResourceManager.GetString("Settings_Auth", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_Fonts {
            get {
                return ResourceManager.GetString("Settings_Fonts", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_General {
            get {
                return ResourceManager.GetString("Settings_General", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_General_AppData {
            get {
                return ResourceManager.GetString("Settings_General_AppData", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_General_AutoCheckUpdate {
            get {
                return ResourceManager.GetString("Settings_General_AutoCheckUpdate", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_General_BrowseCustomFolder {
            get {
                return ResourceManager.GetString("Settings_General_BrowseCustomFolder", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_General_CacheData {
            get {
                return ResourceManager.GetString("Settings_General_CacheData", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_General_CacheSize {
            get {
                return ResourceManager.GetString("Settings_General_CacheSize", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_General_Calcing {
            get {
                return ResourceManager.GetString("Settings_General_Calcing", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_General_EnableTrayIcon {
            get {
                return ResourceManager.GetString("Settings_General_EnableTrayIcon", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_General_EnableTrayIcon_Tip {
            get {
                return ResourceManager.GetString("Settings_General_EnableTrayIcon_Tip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_General_LogsData {
            get {
                return ResourceManager.GetString("Settings_General_LogsData", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_General_LogSize {
            get {
                return ResourceManager.GetString("Settings_General_LogSize", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_General_RuningMinimize {
            get {
                return ResourceManager.GetString("Settings_General_RuningMinimize", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_General_StartAutoRun {
            get {
                return ResourceManager.GetString("Settings_General_StartAutoRun", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_General_StorageSpace {
            get {
                return ResourceManager.GetString("Settings_General_StorageSpace", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_General_UpdateChannel {
            get {
                return ResourceManager.GetString("Settings_General_UpdateChannel", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_General_UseGPURendering {
            get {
                return ResourceManager.GetString("Settings_General_UseGPURendering", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_InvalidConfigurationFile {
            get {
                return ResourceManager.GetString("Settings_InvalidConfigurationFile", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_Language {
            get {
                return ResourceManager.GetString("Settings_Language", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_Plugin {
            get {
                return ResourceManager.GetString("Settings_Plugin", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_Plugin_OnlyLoadOfficial {
            get {
                return ResourceManager.GetString("Settings_Plugin_OnlyLoadOfficial", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_Plugin_OpenCacheFolder {
            get {
                return ResourceManager.GetString("Settings_Plugin_OpenCacheFolder", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_Plugin_OpenFolder {
            get {
                return ResourceManager.GetString("Settings_Plugin_OpenFolder", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_Plugin_SafeMode {
            get {
                return ResourceManager.GetString("Settings_Plugin_SafeMode", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_Plugin_WasInstalled {
            get {
                return ResourceManager.GetString("Settings_Plugin_WasInstalled", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_Proxy_CustomDNS {
            get {
                return ResourceManager.GetString("Settings_Proxy_CustomDNS", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_Proxy_IPAddress {
            get {
                return ResourceManager.GetString("Settings_Proxy_IPAddress", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_Proxy_Password {
            get {
                return ResourceManager.GetString("Settings_Proxy_Password", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_Proxy_Port {
            get {
                return ResourceManager.GetString("Settings_Proxy_Port", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_Proxy_ProxyType {
            get {
                return ResourceManager.GetString("Settings_Proxy_ProxyType", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_Proxy_SystemProxyIp {
            get {
                return ResourceManager.GetString("Settings_Proxy_SystemProxyIp", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_Proxy_SystemProxyPortId {
            get {
                return ResourceManager.GetString("Settings_Proxy_SystemProxyPortId", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_Proxy_SystemProxyPortId_Tip {
            get {
                return ResourceManager.GetString("Settings_Proxy_SystemProxyPortId_Tip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_Proxy_TwoLevelAgent {
            get {
                return ResourceManager.GetString("Settings_Proxy_TwoLevelAgent", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_Proxy_UserName {
            get {
                return ResourceManager.GetString("Settings_Proxy_UserName", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_RestartEffective {
            get {
                return ResourceManager.GetString("Settings_RestartEffective", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_StartupAutoRun {
            get {
                return ResourceManager.GetString("Settings_StartupAutoRun", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_StartupNoShowMainWindow {
            get {
                return ResourceManager.GetString("Settings_StartupNoShowMainWindow", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_Steam {
            get {
                return ResourceManager.GetString("Settings_Steam", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_Steam_AdminRunPrompt {
            get {
                return ResourceManager.GetString("Settings_Steam_AdminRunPrompt", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_Steam_AutoPopupMessage {
            get {
                return ResourceManager.GetString("Settings_Steam_AutoPopupMessage", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_Steam_AutoRunSteam {
            get {
                return ResourceManager.GetString("Settings_Steam_AutoRunSteam", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_Steam_CheckSteamRuningNotification {
            get {
                return ResourceManager.GetString("Settings_Steam_CheckSteamRuningNotification", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_Steam_DefaultNoShowMainWindow {
            get {
                return ResourceManager.GetString("Settings_Steam_DefaultNoShowMainWindow", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_Steam_NoAutoUpdate {
            get {
                return ResourceManager.GetString("Settings_Steam_NoAutoUpdate", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_Steam_NotCheckUpdate {
            get {
                return ResourceManager.GetString("Settings_Steam_NotCheckUpdate", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_Steam_Path {
            get {
                return ResourceManager.GetString("Settings_Steam_Path", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_Steam_RuningAdmin {
            get {
                return ResourceManager.GetString("Settings_Steam_RuningAdmin", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_Steam_RuningMinimize {
            get {
                return ResourceManager.GetString("Settings_Steam_RuningMinimize", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_Steam_RunSteamChina {
            get {
                return ResourceManager.GetString("Settings_Steam_RunSteamChina", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_Steam_SteamStratParameter {
            get {
                return ResourceManager.GetString("Settings_Steam_SteamStratParameter", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_System {
            get {
                return ResourceManager.GetString("Settings_System", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_Theme {
            get {
                return ResourceManager.GetString("Settings_Theme", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_ThemeAccent {
            get {
                return ResourceManager.GetString("Settings_ThemeAccent", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_UI {
            get {
                return ResourceManager.GetString("Settings_UI", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_UI_AccentColor {
            get {
                return ResourceManager.GetString("Settings_UI_AccentColor", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_UI_BackgroundImageOpacity {
            get {
                return ResourceManager.GetString("Settings_UI_BackgroundImageOpacity", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_UI_BackgroundOpacity {
            get {
                return ResourceManager.GetString("Settings_UI_BackgroundOpacity", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_UI_Custom {
            get {
                return ResourceManager.GetString("Settings_UI_Custom", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_UI_CustomBackgroundImage {
            get {
                return ResourceManager.GetString("Settings_UI_CustomBackgroundImage", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_UI_CustomBackgroundImage_Error {
            get {
                return ResourceManager.GetString("Settings_UI_CustomBackgroundImage_Error", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_UI_CustomColor {
            get {
                return ResourceManager.GetString("Settings_UI_CustomColor", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_UI_Dark {
            get {
                return ResourceManager.GetString("Settings_UI_Dark", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_UI_DefaultFonts {
            get {
                return ResourceManager.GetString("Settings_UI_DefaultFonts", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_UI_DefaultLanguage {
            get {
                return ResourceManager.GetString("Settings_UI_DefaultLanguage", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_UI_EnableDesktopBackground {
            get {
                return ResourceManager.GetString("Settings_UI_EnableDesktopBackground", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_UI_EnableDesktopBackground_Error_ {
            get {
                return ResourceManager.GetString("Settings_UI_EnableDesktopBackground_Error_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_UI_EnableFilletUI {
            get {
                return ResourceManager.GetString("Settings_UI_EnableFilletUI", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_UI_HighContrast {
            get {
                return ResourceManager.GetString("Settings_UI_HighContrast", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_UI_Light {
            get {
                return ResourceManager.GetString("Settings_UI_Light", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_UI_PreviewColor {
            get {
                return ResourceManager.GetString("Settings_UI_PreviewColor", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_UI_SelectImage {
            get {
                return ResourceManager.GetString("Settings_UI_SelectImage", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_UI_StartDefaultPage {
            get {
                return ResourceManager.GetString("Settings_UI_StartDefaultPage", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_UI_SystemDefault {
            get {
                return ResourceManager.GetString("Settings_UI_SystemDefault", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_UI_ThemeStyle {
            get {
                return ResourceManager.GetString("Settings_UI_ThemeStyle", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_UI_WindowBackgroundStyle {
            get {
                return ResourceManager.GetString("Settings_UI_WindowBackgroundStyle", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Settings_UI_WindowTransparencyMaterial {
            get {
                return ResourceManager.GetString("Settings_UI_WindowTransparencyMaterial", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SettingsModifiedRestartThisSoft {
            get {
                return ResourceManager.GetString("SettingsModifiedRestartThisSoft", resourceCulture);
            }
        }
        
        
/   查找类似 显示/隐藏 的本地化字符串。
        
/ </summary>
        public static string ShowHide {
            get {
                return ResourceManager.GetString("ShowHide", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Sign {
            get {
                return ResourceManager.GetString("Sign", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Signed {
            get {
                return ResourceManager.GetString("Signed", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SignOut {
            get {
                return ResourceManager.GetString("SignOut", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SMSCode {
            get {
                return ResourceManager.GetString("SMSCode", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SortAs {
            get {
                return ResourceManager.GetString("SortAs", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SponsorUs {
            get {
                return ResourceManager.GetString("SponsorUs", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string StartSteam {
            get {
                return ResourceManager.GetString("StartSteam", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string StartUpdate {
            get {
                return ResourceManager.GetString("StartUpdate", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Steam_AuthFileImportPath {
            get {
                return ResourceManager.GetString("Steam_AuthFileImportPath", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Steam_BindTel {
            get {
                return ResourceManager.GetString("Steam_BindTel", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Steam_CheckStarted {
            get {
                return ResourceManager.GetString("Steam_CheckStarted", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Steam_ConfirmEmailLink {
            get {
                return ResourceManager.GetString("Steam_ConfirmEmailLink", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Steam_CurrentIPCountry {
            get {
                return ResourceManager.GetString("Steam_CurrentIPCountry", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Steam_CurrentUser {
            get {
                return ResourceManager.GetString("Steam_CurrentUser", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Steam_CustomAuthName {
            get {
                return ResourceManager.GetString("Steam_CustomAuthName", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Steam_EmailCode {
            get {
                return ResourceManager.GetString("Steam_EmailCode", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Steam_EmailConfirmation {
            get {
                return ResourceManager.GetString("Steam_EmailConfirmation", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Steam_ImageCodeShowError {
            get {
                return ResourceManager.GetString("Steam_ImageCodeShowError", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Steam_ImageCodeTip {
            get {
                return ResourceManager.GetString("Steam_ImageCodeTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Steam_Login {
            get {
                return ResourceManager.GetString("Steam_Login", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Steam_Password {
            get {
                return ResourceManager.GetString("Steam_Password", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Steam_PleaseEnterBindTel {
            get {
                return ResourceManager.GetString("Steam_PleaseEnterBindTel", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Steam_ServerTime {
            get {
                return ResourceManager.GetString("Steam_ServerTime", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Steam_Share_RemoveShare {
            get {
                return ResourceManager.GetString("Steam_Share_RemoveShare", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Steam_SteamChina {
            get {
                return ResourceManager.GetString("Steam_SteamChina", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Steam_SteamWorld {
            get {
                return ResourceManager.GetString("Steam_SteamWorld", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Steam_User {
            get {
                return ResourceManager.GetString("Steam_User", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Steam_UserLoginTip {
            get {
                return ResourceManager.GetString("Steam_UserLoginTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Steam2FACode {
            get {
                return ResourceManager.GetString("Steam2FACode", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamAccount {
            get {
                return ResourceManager.GetString("SteamAccount", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamAccountPage_ShareEmpt {
            get {
                return ResourceManager.GetString("SteamAccountPage_ShareEmpt", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamAppType_Application {
            get {
                return ResourceManager.GetString("SteamAppType_Application", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamAppType_Beta {
            get {
                return ResourceManager.GetString("SteamAppType_Beta", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamAppType_Config {
            get {
                return ResourceManager.GetString("SteamAppType_Config", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamAppType_Demo {
            get {
                return ResourceManager.GetString("SteamAppType_Demo", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamAppType_DepotOnly {
            get {
                return ResourceManager.GetString("SteamAppType_DepotOnly", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamAppType_DLC {
            get {
                return ResourceManager.GetString("SteamAppType_DLC", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamAppType_Driver {
            get {
                return ResourceManager.GetString("SteamAppType_Driver", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamAppType_Franchise {
            get {
                return ResourceManager.GetString("SteamAppType_Franchise", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamAppType_Game {
            get {
                return ResourceManager.GetString("SteamAppType_Game", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamAppType_Guide {
            get {
                return ResourceManager.GetString("SteamAppType_Guide", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamAppType_Hardware {
            get {
                return ResourceManager.GetString("SteamAppType_Hardware", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamAppType_Media {
            get {
                return ResourceManager.GetString("SteamAppType_Media", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamAppType_Mod {
            get {
                return ResourceManager.GetString("SteamAppType_Mod", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamAppType_Music {
            get {
                return ResourceManager.GetString("SteamAppType_Music", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamAppType_Plugin {
            get {
                return ResourceManager.GetString("SteamAppType_Plugin", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamAppType_Series {
            get {
                return ResourceManager.GetString("SteamAppType_Series", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamAppType_Shortcut {
            get {
                return ResourceManager.GetString("SteamAppType_Shortcut", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamAppType_Tool {
            get {
                return ResourceManager.GetString("SteamAppType_Tool", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamAppType_Unknown {
            get {
                return ResourceManager.GetString("SteamAppType_Unknown", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamAppType_Video {
            get {
                return ResourceManager.GetString("SteamAppType_Video", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamGridDBTitle {
            get {
                return ResourceManager.GetString("SteamGridDBTitle", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamGuard {
            get {
                return ResourceManager.GetString("SteamGuard", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamGuardData {
            get {
                return ResourceManager.GetString("SteamGuardData", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamIdle_DroppedCardsCountTip_ {
            get {
                return ResourceManager.GetString("SteamIdle_DroppedCardsCountTip_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamIdle_IdleAppTags_ {
            get {
                return ResourceManager.GetString("SteamIdle_IdleAppTags_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamIdle_IdleNotRuning {
            get {
                return ResourceManager.GetString("SteamIdle_IdleNotRuning", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamIdle_IdleRuning {
            get {
                return ResourceManager.GetString("SteamIdle_IdleRuning", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamIdle_LoginSteamUserError {
            get {
                return ResourceManager.GetString("SteamIdle_LoginSteamUserError", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamIdle_OpenAutoNextWarning {
            get {
                return ResourceManager.GetString("SteamIdle_OpenAutoNextWarning", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamIdle_RemainingGames_ {
            get {
                return ResourceManager.GetString("SteamIdle_RemainingGames_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamIdle_Settings {
            get {
                return ResourceManager.GetString("SteamIdle_Settings", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamIdle_SteamClientUserTips {
            get {
                return ResourceManager.GetString("SteamIdle_SteamClientUserTips", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamIdle_UserExpString_ {
            get {
                return ResourceManager.GetString("SteamIdle_UserExpString_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamIdle_UserNextExpString_ {
            get {
                return ResourceManager.GetString("SteamIdle_UserNextExpString_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamIdleCard {
            get {
                return ResourceManager.GetString("SteamIdleCard", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamLoginImport {
            get {
                return ResourceManager.GetString("SteamLoginImport", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamNotRuning {
            get {
                return ResourceManager.GetString("SteamNotRuning", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamRuning {
            get {
                return ResourceManager.GetString("SteamRuning", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SteamUUID {
            get {
                return ResourceManager.GetString("SteamUUID", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Stop {
            get {
                return ResourceManager.GetString("Stop", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SubHeader_FirstNeedToSetPlatformPath_ {
            get {
                return ResourceManager.GetString("SubHeader_FirstNeedToSetPlatformPath_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SubHeader_FirstSyncSetAuth {
            get {
                return ResourceManager.GetString("SubHeader_FirstSyncSetAuth", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SubHeader_PleaseEnterTheAnswerAgain {
            get {
                return ResourceManager.GetString("SubHeader_PleaseEnterTheAnswerAgain", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SubHeader_SecurityIssues_ {
            get {
                return ResourceManager.GetString("SubHeader_SecurityIssues_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SubHeader_SyncReSetAuth {
            get {
                return ResourceManager.GetString("SubHeader_SyncReSetAuth", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Success_ {
            get {
                return ResourceManager.GetString("Success_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Success_AuthloadedSuccessfully {
            get {
                return ResourceManager.GetString("Success_AuthloadedSuccessfully", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Success_AuthPasswordRemovedSuccessfully {
            get {
                return ResourceManager.GetString("Success_AuthPasswordRemovedSuccessfully", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Success_AuthPasswordSetSuccessfully {
            get {
                return ResourceManager.GetString("Success_AuthPasswordSetSuccessfully", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Success_AuthProtectSuccessfully_ {
            get {
                return ResourceManager.GetString("Success_AuthProtectSuccessfully_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Success_AuthUnbindSuccessful {
            get {
                return ResourceManager.GetString("Success_AuthUnbindSuccessful", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Success_AuthUpload__ {
            get {
                return ResourceManager.GetString("Success_AuthUpload__", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Success_CloudSynchronizationSuccessful {
            get {
                return ResourceManager.GetString("Success_CloudSynchronizationSuccessful", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Success_DelCloudData {
            get {
                return ResourceManager.GetString("Success_DelCloudData", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Success_DeletePlatformAccount__ {
            get {
                return ResourceManager.GetString("Success_DeletePlatformAccount__", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Success_ExecuteAllAuthEnd___ {
            get {
                return ResourceManager.GetString("Success_ExecuteAllAuthEnd___", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Success_LocalAuthDelSuccessful {
            get {
                return ResourceManager.GetString("Success_LocalAuthDelSuccessful", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Success_LocalAuthUpdateSuccessful {
            get {
                return ResourceManager.GetString("Success_LocalAuthUpdateSuccessful", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Success_SavedSuccessfully_ {
            get {
                return ResourceManager.GetString("Success_SavedSuccessfully_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Success_SwitchAccount__ {
            get {
                return ResourceManager.GetString("Success_SwitchAccount__", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Success_UpdateCloudData {
            get {
                return ResourceManager.GetString("Success_UpdateCloudData", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string SupportSystem {
            get {
                return ResourceManager.GetString("SupportSystem", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string TelCode {
            get {
                return ResourceManager.GetString("TelCode", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Title_AddAccount_ {
            get {
                return ResourceManager.GetString("Title_AddAccount_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Title_AuthEncryption {
            get {
                return ResourceManager.GetString("Title_AuthEncryption", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Title_DeleteAuth {
            get {
                return ResourceManager.GetString("Title_DeleteAuth", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Title_InputAuthPassword {
            get {
                return ResourceManager.GetString("Title_InputAuthPassword", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Title_LoginAccount_ {
            get {
                return ResourceManager.GetString("Title_LoginAccount_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Title_PasswordConfirm {
            get {
                return ResourceManager.GetString("Title_PasswordConfirm", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Title_PleaseEnterLoginPassword {
            get {
                return ResourceManager.GetString("Title_PleaseEnterLoginPassword", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Title_PleaseEnterNewAuthName {
            get {
                return ResourceManager.GetString("Title_PleaseEnterNewAuthName", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Title_PleaseEnterTheAnswer {
            get {
                return ResourceManager.GetString("Title_PleaseEnterTheAnswer", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Title_PleaseInputCurrentAccountName_ {
            get {
                return ResourceManager.GetString("Title_PleaseInputCurrentAccountName_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Title_SetSecurityIssues {
            get {
                return ResourceManager.GetString("Title_SetSecurityIssues", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Title_SetUp_ {
            get {
                return ResourceManager.GetString("Title_SetUp_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Toolbox {
            get {
                return ResourceManager.GetString("Toolbox", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Top {
            get {
                return ResourceManager.GetString("Top", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Unbound {
            get {
                return ResourceManager.GetString("Unbound", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Unbundling {
            get {
                return ResourceManager.GetString("Unbundling", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UniversalAuthImport {
            get {
                return ResourceManager.GetString("UniversalAuthImport", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UnixSudoPasswordTips {
            get {
                return ResourceManager.GetString("UnixSudoPasswordTips", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Up {
            get {
                return ResourceManager.GetString("Up", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UpdateContent {
            get {
                return ResourceManager.GetString("UpdateContent", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UpdatePackCacheHashInvalidDeleteFileTrue {
            get {
                return ResourceManager.GetString("UpdatePackCacheHashInvalidDeleteFileTrue", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UpdateUnpackFail {
            get {
                return ResourceManager.GetString("UpdateUnpackFail", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Upload {
            get {
                return ResourceManager.GetString("Upload", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UploadFailed {
            get {
                return ResourceManager.GetString("UploadFailed", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UploadFlow {
            get {
                return ResourceManager.GetString("UploadFlow", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UploadSuccess {
            get {
                return ResourceManager.GetString("UploadSuccess", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UseHelp {
            get {
                return ResourceManager.GetString("UseHelp", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string User_AccountBind {
            get {
                return ResourceManager.GetString("User_AccountBind", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string User_Agreement {
            get {
                return ResourceManager.GetString("User_Agreement", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string User_EngineOil {
            get {
                return ResourceManager.GetString("User_EngineOil", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string User_Experience {
            get {
                return ResourceManager.GetString("User_Experience", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string User_FastLogin {
            get {
                return ResourceManager.GetString("User_FastLogin", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string User_FastLoginTip {
            get {
                return ResourceManager.GetString("User_FastLoginTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string User_GetSMSCode {
            get {
                return ResourceManager.GetString("User_GetSMSCode", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string User_Level {
            get {
                return ResourceManager.GetString("User_Level", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string User_Login {
            get {
                return ResourceManager.GetString("User_Login", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string User_LoginCodeTimeLimitTip_ {
            get {
                return ResourceManager.GetString("User_LoginCodeTimeLimitTip_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string User_LoginError {
            get {
                return ResourceManager.GetString("User_LoginError", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string User_LoginError_CodeImage {
            get {
                return ResourceManager.GetString("User_LoginError_CodeImage", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string User_LoginError_Null {
            get {
                return ResourceManager.GetString("User_LoginError_Null", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string User_LoginUnexpectedPrompt {
            get {
                return ResourceManager.GetString("User_LoginUnexpectedPrompt", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string User_NewPhone {
            get {
                return ResourceManager.GetString("User_NewPhone", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string User_Phone {
            get {
                return ResourceManager.GetString("User_Phone", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string User_PhoneLogin {
            get {
                return ResourceManager.GetString("User_PhoneLogin", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string User_Privacy {
            get {
                return ResourceManager.GetString("User_Privacy", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string User_QQLogin {
            get {
                return ResourceManager.GetString("User_QQLogin", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string User_Register {
            get {
                return ResourceManager.GetString("User_Register", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string User_RegisterAgreed {
            get {
                return ResourceManager.GetString("User_RegisterAgreed", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string User_Rememberme {
            get {
                return ResourceManager.GetString("User_Rememberme", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string User_SignIn_Ok {
            get {
                return ResourceManager.GetString("User_SignIn_Ok", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string User_SignOutTip {
            get {
                return ResourceManager.GetString("User_SignOutTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string User_SMSCode {
            get {
                return ResourceManager.GetString("User_SMSCode", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string User_SMSCode_Error {
            get {
                return ResourceManager.GetString("User_SMSCode_Error", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string User_Sponsor {
            get {
                return ResourceManager.GetString("User_Sponsor", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string User_UnLogin {
            get {
                return ResourceManager.GetString("User_UnLogin", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string User_UseExternalLoginChannel_ {
            get {
                return ResourceManager.GetString("User_UseExternalLoginChannel_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string User_UsePhoneNumLoginChannel {
            get {
                return ResourceManager.GetString("User_UsePhoneNumLoginChannel", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string User_WaitFastLoginTip {
            get {
                return ResourceManager.GetString("User_WaitFastLoginTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UserChange_BtnText {
            get {
                return ResourceManager.GetString("UserChange_BtnText", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UserChange_BtnTootlip {
            get {
                return ResourceManager.GetString("UserChange_BtnTootlip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UserChange_DeleteUser {
            get {
                return ResourceManager.GetString("UserChange_DeleteUser", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UserChange_DeleteUserDataTip {
            get {
                return ResourceManager.GetString("UserChange_DeleteUserDataTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UserChange_DeleteUserTip {
            get {
                return ResourceManager.GetString("UserChange_DeleteUserTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UserChange_EditRemark {
            get {
                return ResourceManager.GetString("UserChange_EditRemark", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UserChange_InGame {
            get {
                return ResourceManager.GetString("UserChange_InGame", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UserChange_LoginNewAccount {
            get {
                return ResourceManager.GetString("UserChange_LoginNewAccount", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UserChange_LoginNewAccountTip {
            get {
                return ResourceManager.GetString("UserChange_LoginNewAccountTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UserChange_NoUserTip {
            get {
                return ResourceManager.GetString("UserChange_NoUserTip", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UserChange_OfflineBtn {
            get {
                return ResourceManager.GetString("UserChange_OfflineBtn", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UserChange_OpenUserUrl {
            get {
                return ResourceManager.GetString("UserChange_OpenUserUrl", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UserChange_RecentLogin {
            get {
                return ResourceManager.GetString("UserChange_RecentLogin", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UserChange_RememberMe {
            get {
                return ResourceManager.GetString("UserChange_RememberMe", resourceCulture);
            }
        }
        
        
/   查找类似 显示/隐藏用户名 的本地化字符串。
        
/ </summary>
        public static string UserChange_ShowHideUserName {
            get {
                return ResourceManager.GetString("UserChange_ShowHideUserName", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UserChange_ShowUserDataFolder {
            get {
                return ResourceManager.GetString("UserChange_ShowUserDataFolder", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UserFastChange {
            get {
                return ResourceManager.GetString("UserFastChange", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UserProfile {
            get {
                return ResourceManager.GetString("UserProfile", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Verify {
            get {
                return ResourceManager.GetString("Verify", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string VerticalTitlePage {
            get {
                return ResourceManager.GetString("VerticalTitlePage", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ViewDetailedData {
            get {
                return ResourceManager.GetString("ViewDetailedData", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ViewInStore {
            get {
                return ResourceManager.GetString("ViewInStore", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Warning {
            get {
                return ResourceManager.GetString("Warning", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Warning_CodeNullPleaseLogin {
            get {
                return ResourceManager.GetString("Warning_CodeNullPleaseLogin", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Warning_DoNotOperateFrequently {
            get {
                return ResourceManager.GetString("Warning_DoNotOperateFrequently", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Warning_NotAuthProvided {
            get {
                return ResourceManager.GetString("Warning_NotAuthProvided", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Warning_OnlySupportSteamAuth {
            get {
                return ResourceManager.GetString("Warning_OnlySupportSteamAuth", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Warning_PasswordError {
            get {
                return ResourceManager.GetString("Warning_PasswordError", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Warning_PlatformDeletionNotAllowed_ {
            get {
                return ResourceManager.GetString("Warning_PlatformDeletionNotAllowed_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Warning_PleaseEnterAuthName {
            get {
                return ResourceManager.GetString("Warning_PleaseEnterAuthName", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Warning_PleaseEnterTel {
            get {
                return ResourceManager.GetString("Warning_PleaseEnterTel", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Warning_PleaseInputAccountName {
            get {
                return ResourceManager.GetString("Warning_PleaseInputAccountName", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Warning_PleaseSelectAuth {
            get {
                return ResourceManager.GetString("Warning_PleaseSelectAuth", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Warning_PleaseSelectImportWay {
            get {
                return ResourceManager.GetString("Warning_PleaseSelectImportWay", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Warning_PleaseStopAccelerate {
            get {
                return ResourceManager.GetString("Warning_PleaseStopAccelerate", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Warning_PleaseWaitExecuteFinish {
            get {
                return ResourceManager.GetString("Warning_PleaseWaitExecuteFinish", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Warning_RefuseOperate {
            get {
                return ResourceManager.GetString("Warning_RefuseOperate", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Warning_SteamAuthPhoneBind {
            get {
                return ResourceManager.GetString("Warning_SteamAuthPhoneBind", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Warning_SteamGuardNotEmpty {
            get {
                return ResourceManager.GetString("Warning_SteamGuardNotEmpty", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Warning_TerminationAllAuth___ {
            get {
                return ResourceManager.GetString("Warning_TerminationAllAuth___", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Warning_UnbindFailed {
            get {
                return ResourceManager.GetString("Warning_UnbindFailed", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string WattToolKitV1 {
            get {
                return ResourceManager.GetString("WattToolKitV1", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string WattToolKitV2 {
            get {
                return ResourceManager.GetString("WattToolKitV2", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Welcome {
            get {
                return ResourceManager.GetString("Welcome", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Welcome_User_ {
            get {
                return ResourceManager.GetString("Welcome_User_", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string WinAuth {
            get {
                return ResourceManager.GetString("WinAuth", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string WorkingDir {
            get {
                return ResourceManager.GetString("WorkingDir", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string YouNeedSignInToGetUID_ {
            get {
                return ResourceManager.GetString("YouNeedSignInToGetUID_", resourceCulture);
            }
        }
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\App\IAppUpdateService.cs
/ </summary>
public interface IAppUpdateService
{
    static IAppUpdateService Instance => Ioc.Get<IAppUpdateService>();

    
/ </summary>
    static (string Path, byte[] SHA384) UpdatePackageInfo { get; internal set; }

    
/ </summary>
    const string PackDirName = "UpgradePackages";

    bool IsNotStartUpdateing { get; }

    
/ </summary>
    float ProgressValue { get; }

    
/ </summary>
    string ProgressString { get; }

    
/ 是否支持服务端分发，如果返回 <see langword="false"/> 将不能使用 DownloadAsync 与 OverwriteUpgradeAsync
    
/ <para>对于 iOS 平台，必须使用 App Store 分发</para>
    
/ </summary>
    bool IsSupportedServerDistribution { get; }

    
/ </summary>
    bool IsExistUpdate { get; }

    
/ </summary>
    AppVersionDTO? NewVersionInfo { get; }

    string NewVersionInfoDesc { get; }

    string NewVersionInfoTitle { get; }

    
/ <inheritdoc cref="CheckUpdateAsync(bool, bool)"/>
    async void CheckUpdate(bool force = false, bool showIsExistUpdateFalse = true)
    {
        await CheckUpdateAsync(force, showIsExistUpdateFalse);
    }

    
/ </summary>
    
/ <param name="force">是否强制检查，如果为 <see langword="false"/> 当有新版本内存中缓存时将跳过 api 请求</param>
    
/ <param name="showIsExistUpdateFalse">是否显示已是最新版本吐司提示</param>
    Task CheckUpdateAsync(bool force = false, bool showIsExistUpdateFalse = true);

    ICommand StartUpdateCommand { get; }

    
/ </summary>
    
/ <param name="m"></param>
    
/ <param name="isDirOrFile"></param>
    
/ <returns></returns>
    protected static string GetPackName(AppVersionDTO m, bool isDirOrFile) => $"{m.Version}@{Hashs.String.Crc32(m.Id.ToByteArray())}{(isDirOrFile ? "" : $"{FileEx.TAR_GZ}")}";

    
/ </summary>
    
/ <param name="onNotExistsCreateDirectory">当目录不存在时是否创建目录</param>
    
/ <param name="exists">目录是否存在</param>
    
/ <returns></returns>
    protected static string GetPackCacheDirPath(bool onNotExistsCreateDirectory, out bool exists)
    {
        var dirPath = Path.Combine(IOPath.CacheDirectory, PackDirName);
        exists = Directory.Exists(dirPath);
        if (!exists && onNotExistsCreateDirectory)
        {
            Directory.CreateDirectory(dirPath);

        }
        return dirPath;
    }

    
/ </summary>
    
/ <param name="clear">是否需要清理之前的缓存</param>
    
/ <returns></returns>
    protected static string GetPackCacheDirPath(bool clear)
    {
        var dirPath = GetPackCacheDirPath(true, out var exists);
        if (exists && clear)
        {
            var files = Directory.GetFiles(dirPath, "*" + FileEx.DownloadCache);
            foreach (var item in files)
            {
                IOPath.FileTryDelete(item);
            }
        }
        return dirPath;
    }

    
/ </summary>
    static void ClearAllPackCacheDir()
    {
        var dirPath = GetPackCacheDirPath(true, out var exists);
        if (exists)
        {
            var files = Directory.GetFiles(dirPath);
            foreach (var item in files)
            {
                IOPath.FileTryDelete(item);
            }
        }
    }

    
/ </summary>
    bool ShowNewVersionWindowOnMainOpen { get; }

    
/ </summary>
    void OnMainOpenTryShowNewVersionWindow();

#if WINDOWS
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static void GenerateOverwriteUpgradeScript(Stream stream, string dirPath)
    {
        var processPath = Environment.ProcessPath;
        processPath.ThrowIsNull();
        var programName = Encoding.UTF8.GetBytes(IApplication.ProgramName);
        var dirPath_ = Encoding.UTF8.GetBytes(dirPath);
        var baseDir = Encoding.UTF8.GetBytes(IOPath.BaseDirectory);
        var processPath_ = Encoding.UTF8.GetBytes(processPath);

        
/    tasklist|find /i "{0}"
        
/    taskkill /im "{0}" /f
        
/    taskkill /im "{0}" /f
        
/    xcopy /y /c /h /r /s "{1}\*.*" "{2}"
        
/    rmdir /s /q "{1}"
        
/    """;

        stream.Write("""
                chcp 65001
                @echo off
                :loop
                ping -n 1 127.0.0.1 
                tasklist|find /i "
                """u8);
        stream.Write(programName);
        stream.Write("""
                "

                """u8);
        stream.Write("""
                if %errorlevel%==0 (
                taskkill /im "
                """u8);
        stream.Write(programName);
        stream.Write("""
                " /f
                )
                else(
                taskkill /im "
                """u8);
        stream.Write(programName);
        stream.Write("""
                " /f
                xcopy /y /c /h /r /s "
                """u8);
        stream.Write(dirPath_);
        stream.Write("""
                \*.*" "
                """u8);
        stream.Write(baseDir);
        stream.Write("""
                "
                rmdir /s /q "
                """u8);
        stream.Write(dirPath_);
        stream.Write("""
                "
                "
                """u8);
        stream.Write(processPath_);
        stream.Write("""
                "
                del %0
                )
                goto :loop
                """u8);
        stream.Flush();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static void OverwriteUpgrade()
    {
        if (UpdatePackageInfo == default ||
            string.IsNullOrWhiteSpace(UpdatePackageInfo.Path) ||
            UpdatePackageInfo.SHA384 == null ||
            UpdatePackageInfo.SHA384.Length != Hashs.String.Lengths.SHA384)
            return;

        byte[]? sha384Data = null;
        using (var stream = new FileStream(UpdatePackageInfo.Path, FileMode.Open, FileAccess.Read, FileShare.ReadWrite | FileShare.Delete))
        {
            sha384Data = SHA384.HashData(stream);
        }
        if (!sha384Data.SequenceEqual(UpdatePackageInfo.SHA384))
            return;

        var dirPath = UpdatePackageInfo.Path.TrimEnd(Path.DirectorySeparatorChar);
        const string updateCommandFileName = $"{AssemblyInfo.Trademark} Upgrade.cmd";
        var updateCommandPath = Path.Combine(IOPath.CacheDirectory, updateCommandFileName);
        using (var stream = new FileStream(updateCommandPath, FileMode.OpenOrCreate, FileAccess.Write, FileShare.ReadWrite | FileShare.Delete))
        {
            GenerateOverwriteUpgradeScript(stream, dirPath);
            stream.SetLength(stream.Position);
        }

        ProcessStartInfo psi = new()
        {
            FileName = updateCommandFileName,
            UseShellExecute = false,
            CreateNoWindow = !AssemblyInfo.Debuggable, 
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services\App\IAppUpdateService.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\App\IPlatformService.App.cs
/ </summary>
    bool CurrentAppIsInstallVersion =>
#if IOS || ANDROID
        true;
#else
        false;
#endif
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services\App\IPlatformService.App.cs
DEBUG
IOS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Compression\ISevenZipHelper.cs
/ </summary>
    
/ <param name="filePath">要解压的压缩包文件路径</param>
    
/ <param name="dirPath">要解压的文件夹路径，文件夹必须不存在</param>
    
/ <param name="progress">进度值监听</param>
    
/ <param name="maxProgress">最大进度值，100%</param>
    
/ <returns></returns>
    bool Unpack(string filePath, string dirPath,
        IProgress<float>? progress = null,
        float maxProgress = 100f);
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Identity\IUserManager.cs
/ </summary>
public interface IUserManager : IAuthHelper
{
    
/ </summary>
    protected const string KEY_CURRENT_LOGIN_USER = "KEY_CURRENT_LOGIN_USER";

    static IUserManager Instance => Ioc.Get<IUserManager>();

    
/ <inheritdoc cref="GetCurrentUserAsync"/>
    CurrentUser? GetCurrentUser();

    
/ <para>如果[退出登录]则为 <see langword="null"/>，对于接收到的推送消息，要求在服务端时传入接收人用户Id，客户端根据Id读取用户信息，而不使用此值</para>
    
/ </summary>
    
/ <returns></returns>
    ValueTask<CurrentUser?> GetCurrentUserAsync();

    
/ 设置当前登录用户，当[退出登录]时可传入<see langword="null"/>
    
/ </summary>
    
/ <param name="value"></param>
    
/ <returns></returns>
    Task SetCurrentUserAsync(CurrentUser? value);

    
/ <para>如果[退出登录]则为 <see langword="null"/>，对于接收到的推送消息，要求在服务端时传入接收人用户Id，客户端根据Id读取用户信息，而不使用此值</para>
    
/ </summary>
    
/ <returns></returns>
    ValueTask<IdentityUserInfoDTO?> GetCurrentUserInfoAsync();

    
/ </summary>
    
/ <param name="value"></param>
    
/ <param name="updateToDataBase">更新到数据库中</param>
    
/ <returns></returns>
    Task SetCurrentUserInfoAsync(IdentityUserInfoDTO value, bool updateToDataBase);

    
/ </summary>
    
/ <param name="userId"></param>
    
/ <returns></returns>
    Task<IdentityUserInfoDTO?> GetUserInfoByIdAsync(Guid userId);

    
/ </summary>
    
/ <param name="user"></param>
    
/ <returns></returns>
    Task InsertOrUpdateAsync(IUserDTO user);

    
/ </summary>
    
/ <param name="notHideMiddleFour"></param>
    
/ <returns></returns>
    async Task<string> GetCurrentUserPhoneNumberAsync(bool notHideMiddleFour = false)
    {
        var phone_number = (await GetCurrentUserAsync())?.PhoneNumber;
        if (string.IsNullOrWhiteSpace(phone_number)) return string.Empty;
        return notHideMiddleFour ? phone_number : PhoneNumberHelper.ToStringHideMiddleFour(phone_number);
    }

    
/ </summary>
    event Action? OnSignOut;
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\IPC\IPCMainProcessService.cs
/ </summary>
public interface IPCMainProcessService : IAsyncDisposable
{
    static IPCMainProcessService Instance => Ioc.Get<IPCMainProcessService>();

    
/ </summary>
    
/ <param name="moduleName"></param>
    
/ <param name="delegate"></param>
    
/ <param name="callStart"></param>
    
/ <returns></returns>
    Process? AddDaemonWithStartSubProcess(string moduleName, Func<IPCMainProcessService, Process?> @delegate);

    
/ </summary>
    
/ <param name="moduleName"></param>
    
/ <param name="delegate"></param>
    
/ <param name="callStart"></param>
    
/ <returns></returns>
    ValueTask<Process?> AddDaemonWithStartSubProcessAsync(string moduleName, Func<IPCMainProcessService, ValueTask<Process?>> @delegate);

    
/ </summary>
    ValueTask<Process?> StartSubProcessAsync(
        string fileName,
        bool isAdministrator = false,
        Action<ProcessStartInfo>? configure = null);

    
/ </summary>
    void Run();

    
/ </summary>
    
/ <param name="moduleName"></param>
    
/ <returns></returns>
    Task StartModule(string moduleName);

    
/ </summary>
    
/ <param name="moduleName"></param>
    
/ <returns></returns>
    Task<bool> ExitModule(string moduleName);

    
/ </summary>
    
/ <param name="moduleNames"></param>
    
/ <returns></returns>
    Task<bool> ExitModules(IEnumerable<string> moduleNames);

    
/ </summary>
    
/ <typeparam name="T"></typeparam>
    
/ <param name="moduleName"></param>
    
/ <returns></returns>
    ValueTask<T?> GetServiceAsync<T>(string moduleName) where T : class;

    void WriteMessage(string? moduleName, byte[] bytes);
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\IPC\IPCSubProcessModuleService.cs
/ 子进程模块的 IPC 服务，调用 <see cref="IDisposable.Dispose"/> 退出子进程

/ </summary>
[IpcPublic(Timeout = AssemblyInfo.IpcTimeout, IgnoresIpcException = false)]
public interface IPCSubProcessModuleService : IDisposable
{
    internal static class Constants
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string GetClientPipeName(string moduleName, string pipeName)
            => $"{pipeName}_{moduleName}";

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string GetDirectoryName(string name)
        {
            var chars = GetDirectoryNameCore(name).ToArray();
            if (chars.Length > 0) return new string(chars);
            return $"{name.Length}_{Hashs.String.SHA256(name)}";

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            static IEnumerable<char> GetDirectoryNameCore(string name)
            {
                var chars = Path.GetInvalidFileNameChars();
                foreach (var item in name)
                {
                    if (!chars.Contains(item))
                    {
                        yield return item;
                    }
                }
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static string GetPluginsDirectory(string pluginName, string directory)
        {
            var dirName = GetDirectoryName(pluginName);
            directory = Path.Combine(directory, AssemblyInfo.Plugins, dirName);
            IOPath.DirCreateByNotExists(directory);
            return directory;
        }
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Mvvm\LogConsoleService.cs
/ </summary>
    public string? LogMessageAccelerator => logMessages[0];

    
/ </summary>
    public string? LogMessageBackEnd => logMessages[1];

    
/ </summary>
    readonly Dictionary<string, Source> sources = new();

    partial class Source
    {
        
/ </summary>
        public void AppendWithPropertyChanged(IReactiveObject o, byte[]? value,
            string propertyName, ref string? propertyValue)
        {
            if (value != null && value.Length > 0)
            {
                Append(value);

                var logAllMessage = ToString();
                propertyValue = logAllMessage;

                Dispatcher.UIThread.Invoke(() =>
                {
                    o.RaisePropertyChanged(propertyName);
                });

            }
        }
    }

    
/ </summary>
    
/ <param name="moduleName"></param>
    
/ <param name="value"></param>
    internal void WriteMessage(string? moduleName, byte[]? value)
    {
        if (!string.IsNullOrWhiteSpace(moduleName) &&
            value != null && value.Length > 0)
        {
            if (!sources.TryGetValue(moduleName, out var source))
            {
                source = new(
#if DEBUG
                    moduleName
#endif
                    );
                sources.Add(moduleName, source);
            }

            switch (moduleName)
            {
                case AssemblyInfo.Accelerator:
                    source.AppendWithPropertyChanged(this, value,
                        nameof(LogMessageAccelerator), ref logMessages[0]);
                    break;
                case IPlatformService.IPCRoot.moduleName:
                    source.AppendWithPropertyChanged(this, value,
                        nameof(LogMessageBackEnd), ref logMessages[1]);
                    break;
            }
        }
    }

    #endregion
}
#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services\Mvvm\LogConsoleService.cs
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Mvvm\LogConsoleService.Logger.cs
/ </summary>
    const int ConsoleMaxCharCount = 10_0000;

    static readonly int ConsoleMaxByteCount = Encoding.UTF8.GetMaxByteCount(ConsoleMaxCharCount);

    
/ </summary>
    [DebuggerDisplay("{DebuggerDisplay(),nq}")]
    internal sealed partial class Source
    {
        List<byte[]>? chunk;
        (string? str, long byteLength)? message = null;

#if DEBUG
        readonly string moduleName;

        public Source(string moduleName)
        {
            this.moduleName = moduleName;
        }

        string DebuggerDisplay() =>
$"""
moduleName: {moduleName}
ByteLength: {ByteLength}
{ToString()}
""";
#endif

        public long ByteLength { get; private set; }

        public void BuilderAppend(byte[] value)
        {
            (chunk ??= new()).Add(value);
            ByteLength += value.Length;
        }

        void BuilderClear()
        {
            if (chunk != null && chunk.Count > 1)
            {
                
/ </summary>
        public void Append(byte[]? value)
        {
            if (value != null && value.Length > 0)
            {
                if (ByteLength > ConsoleMaxByteCount)
                {
                    BuilderClear();
                }

                
/github.com/dotnet/extensions/blob/v3.1.5/src/Logging/Logging.Console/src/ConsoleLogger.cs
        
/github.com/dotnet/runtime/blob/v9.0.0-preview.7.24405.7/src/libraries/Microsoft.Extensions.Logging.Console/src/SimpleConsoleFormatter.cs

        if (!string.IsNullOrEmpty(message))
        {
            StringBuilder builder = new();
            CreateDefaultLogMessage(builder, logName, eventId, message, exception);

            var str = builder.ToString();
            return Encoding.UTF8.GetBytes(str);
        }
        else
        {
            using var buffer = Utf8String.CreateWriter(out var logBuilder);

            
/github.com/dotnet/extensions/blob/v3.1.5/src/Logging/shared/NullScope.cs</para>
    
/github.com/dotnet/runtime/blob/v5.0.0-rtm.20519.4/src/libraries/Common/src/Extensions/Logging/NullScope.cs</para>
    
/ </summary>
    sealed class NullScope : IDisposable
    {
        public static NullScope Instance { get; } = new();

        NullScope()
        {
        }

        public void Dispose()
        {
        }
    }

    internal sealed class Utf8StringLoggerProvider : ILoggerProvider
    {
        internal static string? ModuleName { get; private set; }

        public Utf8StringLoggerProvider(string moduleName)
        {
            ModuleName = moduleName;
        }

        public ILogger CreateLogger(string name)
        {
            return new Utf8StringLogger(name);
        }

        void IDisposable.Dispose()
        {
        }
    }

    #endregion
}
#endif

发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services\Mvvm\LogConsoleService.Logger.cs
DEBUG
APP
DEBUG
DEBUG
APP
APP
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services\Mvvm\NoticeService.cs
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Mvvm\ResourceService.cs
/ </summary>
    
/ <param name="cultureName"></param>
    public static void ChangeLanguage(string? cultureName) => MainThread2.BeginInvokeOnMainThread(() => ChangeLanguageCore(cultureName));

    static CultureInfo TryGetCultureInfo(string? cultureName, CultureInfo defaultCultureInfo)
    {
        if (string.IsNullOrWhiteSpace(cultureName))
        {
            return defaultCultureInfo;
        }
        try
        {
            return CultureInfo.GetCultureInfo(cultureName);
        }
        catch
        {
            return defaultCultureInfo;
        }
    }

    static void ChangeLanguageCore(string? cultureName)
    {
        if (cultureName == null || AppResources.Culture.IsMatch(cultureName)) return;
        AppResources.Culture = TryGetCultureInfo(cultureName, DefaultCurrentUICulture);
        Thread.CurrentThread.CurrentUICulture = AppResources.Culture;
        Thread.CurrentThread.CurrentCulture = AppResources.Culture;
        CultureInfo.DefaultThreadCurrentUICulture = AppResources.Culture;
        CultureInfo.DefaultThreadCurrentCulture = AppResources.Culture;
        CultureInfo.CurrentUICulture = AppResources.Culture;
        CultureInfo.CurrentCulture = AppResources.Culture;
        mAcceptLanguage = GetAcceptLanguageCore();
        mLanguage = GetLanguageCore();
        Current.Res = new();
        Current.RaisePropertyChanged(nameof(Res));
        ChangedHandler?.Invoke();
    }

    public static string GetCurrentCultureSteamLanguageName()
    {
        try
        {
            var culture = Culture;
            foreach (var item in SteamLanguages)
            {
                if (culture.IsMatch(item.Key))
                {
                    return item.Value;
                }
            }
            
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Mvvm\Advertisement\AdvertiseService.cs
/ </summary>
public sealed class AdvertiseService : ReactiveObject
{
    static readonly Lazy<AdvertiseService> mCurrent = new(() => new(), LazyThreadSafetyMode.ExecutionAndPublication);

    public static AdvertiseService Current => mCurrent.Value;

    [Reactive]
    public ObservableCollection<AdvertisementDTO>? HorizontalBannerAdvertisements { get; set; }

    [Reactive]
    public ObservableCollection<AdvertisementDTO>? VerticalBannerAdvertisements { get; set; }

    [Reactive]
    public bool IsInitialized { get; set; }

    [Reactive]
    public bool IsShowAdvertise { get; set; } = true;

    public ICommand ClickAdvertisementCommand { get; }

    AdvertiseService()
    {
        
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Mvvm\Identity\UserService.cs
/ </summary>
    public bool IsAuthenticated => User != null;

    [Reactive]
    public SteamUser? CurrentSteamUser { get; set; }

    [Reactive]
    public object? AvatarPath { get; set; }

    
/ </summary>
    [Reactive]
    public bool HasPhoneNumber { get; set; }

    
/ </summary>
    [Reactive]
    public string PhoneNumber { get; set; } = string.Empty;

    public async void ShowWindow()
    {
        var cUser = await userManager.GetCurrentUserAsync();
        if (cUser.HasValue()) return;

        
/ </summary>
    
/ <param name="url">跳转地址</param>
    
/ <returns></returns>
    public async Task OpenAuthUrl(string url)
    {

        await OpenAuthUrl(url, url.StartsWith(Constants.Urls.WattGame, StringComparison.OrdinalIgnoreCase) ? FastLoginWebChannel.WattGame : FastLoginWebChannel.OfficialWebsite);
        
/ </summary>
    
/ <param name="url">跳转地址</param>
    
/ <param name="channel">Web 跳转渠道</param>
    public async Task OpenAuthUrl(string url, FastLoginWebChannel channel = FastLoginWebChannel.OfficialWebsite)
    {
        switch (channel)
        {

            case FastLoginWebChannel.OfficialWebsite:
                var token = await userManager.GetAuthTokenAsync();
                if (token != null)
                {
                    await Browser2.OpenAsync(string.Format(Constants.Urls.OfficialWebsite_Fast_Login_, token.AccessToken, HttpUtility.UrlEncode(token.ExpiresIn.ToString("R")), HttpUtility.UrlEncode(url)));
                }
                return;
            case FastLoginWebChannel.WattGame:
                var shopToken = await userManager.GetShopAuthTokenAsync();
                if (shopToken != null)
                {
                    var cookieMaxAge = (shopToken.ExpiresIn - DateTimeOffset.Now).TotalSeconds;
                    await Browser2.OpenAsync(string.Format(Constants.Urls.WattGame_Fast_Login_, shopToken.AccessToken, HttpUtility.UrlEncode(cookieMaxAge.ToString()), HttpUtility.UrlEncode(url)));
                }
                return;
        }
        await Browser2.OpenAsync(url.ToString());
    }

    
/ </summary>
    
/ <param name="phoneNumber"></param>
    
/ <returns></returns>
    public async Task UpdateCurrentUserPhoneNumberAsync(string phoneNumber)
    {
        var user = await userManager.GetCurrentUserAsync();
        if (user == null) return;
        user.PhoneNumber = phoneNumber;
        await userManager.SetCurrentUserAsync(user);
        RefreshCurrentUser(user);
    }

    
/ </summary>
    
/ <param name="channel"></param>
    
/ <returns></returns>
    public async Task UnbundleAccountAfterUpdateAsync(ExternalLoginChannel channel)
    {
        var user = await userManager.GetCurrentUserInfoAsync();
        if (user == null) return;
        switch (channel)
        {
            case ExternalLoginChannel.Steam:
                user.SteamAccountId = null;
                break;
            case ExternalLoginChannel.Microsoft:
                user.MicrosoftAccountEmail = null;
                break;
            case ExternalLoginChannel.QQ:
                user.QQNickName = null;
                break;
            case ExternalLoginChannel.Apple:
                user.AppleAccountEmail = null;
                break;
            default:
                return;
        }
        if (user.AvatarUrl != null && user.AvatarUrl.ContainsKey(channel))
        {
            user.AvatarUrl.Remove(channel);
        }
        await userManager.SetCurrentUserInfoAsync(user, true);
        await RefreshUserAsync(user);
    }

    
/ </summary>
    
/ <param name="channel"></param>
    
/ <param name="rsp"></param>
    
/ <returns></returns>
    public async Task BindAccountAfterUpdateAsync(ExternalLoginChannel channel, LoginOrRegisterResponse rsp)
    {
        var user = await userManager.GetCurrentUserInfoAsync();
        if (user == null) return;
        switch (channel)
        {
            case ExternalLoginChannel.Steam:
                user.SteamAccountId = rsp.User?.SteamAccountId;
                break;
            case ExternalLoginChannel.Microsoft:
                user.MicrosoftAccountEmail = rsp.User?.MicrosoftAccountEmail;
                break;
            case ExternalLoginChannel.QQ:
                user.QQNickName = rsp.User?.QQNickName;
                if (string.IsNullOrEmpty(user.NickName)) user.NickName = user.QQNickName ?? "";
                break;
            case ExternalLoginChannel.Apple:
                user.AppleAccountEmail = rsp.User?.AppleAccountEmail;
                break;
            default:
                return;
        }
        if (rsp.User != null)
        {
            if (!string.IsNullOrEmpty(rsp.User.NickName) && string.IsNullOrEmpty(user.NickName)) user.NickName = rsp.User.NickName;
            if (rsp.User.Gender != default && user.Gender != rsp.User.Gender) user.Gender = rsp.User.Gender;
            if (rsp.User.AvatarUrl != null && rsp.User.AvatarUrl.ContainsKey(channel))
            {
                if (user.AvatarUrl == null)
                {
                    user.AvatarUrl = new()
                        {
                            { channel, rsp.User.AvatarUrl[channel] }
                        };
                }
                else if (user.AvatarUrl.ContainsKey(channel))
                {
                    user.AvatarUrl[channel] = rsp.User.AvatarUrl[channel];
                }
                else
                {
                    user.AvatarUrl.Add(channel, rsp.User.AvatarUrl[channel]);
                }
            }
        }
        await userManager.SetCurrentUserInfoAsync(user, true);
        await RefreshUserAsync(user);
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Mvvm\Steam\SteamConnectService.cs
/ </summary>
    public bool IsDisposedClient
    {
        get => _IsDisposedClient;
        set
        {
            if (_IsDisposedClient != value)
            {
                _IsDisposedClient = value;
                this.RaisePropertyChanged();
            }
        }
    }

    #endregion

    bool _IsLoadingGameList;

    public bool IsLoadingGameList
    {
        get => _IsLoadingGameList;
        set => this.RaiseAndSetIfChanged(ref _IsLoadingGameList, value);
    }

    #region 启用监听 Steam 下载

    bool _IsWatchSteamDownloading;

    public bool IsWatchSteamDownloading
    {
        get => _IsWatchSteamDownloading;
        set => this.RaiseAndSetIfChanged(ref _IsWatchSteamDownloading, value);
    }

    public HashSet<uint> WatchDownloadingSteamAppIds { get; } = new();

    #endregion

    public void RunAFKApps()
    {
        var aFKAppList = Ioc.Get_Nullable<IPartialGameLibrarySettings>()?.AFKAppList;
        if (aFKAppList?.Count > 0)
        {
            foreach (var item in aFKAppList)
            {
                RuningSteamApps.TryGetValue(item.Key, out var runState);
                if (runState == null)
                    RuningSteamApps.TryAdd(item.Key, new SteamApp
                    {
                        AppId = item.Key,
                        Name = item.Value,
                    });
            }
            Task2.InBackground(() =>
            {
                foreach (var item in RuningSteamApps.Values)
                {
                    if (item.Process == null || item.Process.HasExited)
                        item.StartSteamAppProcess();
                }
            });
        }
    }

    public void Initialize()
    {
        if (!stmService.IsRunningSteamProcess && SteamSettings.IsAutoRunSteam.Value)
            stmService.StartSteamWithParameter();

        Task2.InBackground(() =>
        {
            while (true)
            {
                try
                {
                    IsRunningSteamProcess = stmService.IsRunningSteamProcess;
                    if (IsRunningSteamProcess)
                    {
                        if (!IsConnectToSteam && IsDisposedClient)
                        {
                            if (swLocalService.Initialize())
                            {
                                IsDisposedClient = false;
                                var id = swLocalService.GetSteamId64();
                                if (id <= 0 || id == SteamIdConvert.UndefinedId)
                                {
                                    
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services\Mvvm\Steam\SteamConnectService.cs
LINUX
WINDOWS
WINDOWS
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Mvvm\UI\ViewModels\ViewModelManager.cs
/ </summary>
    public WindowViewModel? MainWindow { get; private set; }

    public void InitViewModels(IEnumerable<TabItemViewModel> tabItems, ImmutableArray<TabItemViewModel> footerTabItems)
    {
        MainWindow = new MainWindowViewModel(tabItems, footerTabItems);
    }

    public T Get<T>() where T : ViewModelBase
    {
        var vmType = typeof(T);
        if (viewModelCaches.TryGetValue(vmType, out var vmValue))
        {
            return (T)vmValue;
        }
        else
        {
            T vmValue2;
            if (viewModelDataCaches.TryGetValue(vmType, out var value))
            {
                var viewModel = Serializable.DMP2<T>(value);
                vmValue2 = viewModel.ThrowIsNull();
            }
            else
            {
                vmValue2 = Activator.CreateInstance<T>();
            }
            viewModelCaches[vmType] = vmValue2;
            return vmValue2;
        }
    }

    public ViewModelBase Get(Type vmType)
    {
        if (viewModelCaches.TryGetValue(vmType, out var vmValue))
        {
            return vmValue;
        }
        else
        {
            ViewModelBase? vmValue2;
            if (viewModelDataCaches.TryGetValue(vmType, out var value))
            {
                var viewModel = (ViewModelBase?)Serializable.DMP2(vmType, value);
                vmValue2 = viewModel.ThrowIsNull();
            }
            else
            {
                vmValue2 = (ViewModelBase)Activator.CreateInstance(vmType)!;
            }
            viewModelCaches[vmType] = vmValue2;
            return vmValue2;
        }
    }

    public void Dispose(ViewModelBase viewModel)
    {
        var vmType = viewModel.GetType();
        var value = Serializable.SMP2(vmType, viewModel);
        viewModelDataCaches[vmType] = value;
        viewModelDataCaches[vmType] = value;
        viewModelCaches.TryRemove(vmType, out var _);
    }

    void Dispose(bool disposing)
    {
        if (!disposedValue)
        {
            if (disposing)
            {
                
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Mvvm\UI\Widgets\ToastService.cs
/ </summary>
[Obsolete("不再使用常驻通知")]
public sealed class ToastService : ReactiveObject
{
    static readonly Lazy<ToastService> mCurrent = new(() => new(), LazyThreadSafetyMode.ExecutionAndPublication);

    public static ToastService Current => mCurrent.Value;

    static readonly Lazy<bool> mIsSupported = new(() => Ioc.Get<IToast>() is ToastImpl);

    public static bool IsSupported => mIsSupported.Value;

    readonly Subject<string> notifier;
    string persisitentMessage = "";
    string notificationMessage = "";

    #region Message 变更通知

    
/ </summary>
    public string Message
    {
        get => notificationMessage ?? persisitentMessage;
        set
        {
            notificationMessage = value;
            persisitentMessage = value;
            this.RaisePropertyChanged();
        }
    }

    #endregion

    
/ </summary>
    bool _IsVisible;

    public bool IsVisible
    {
        get => _IsVisible;
        set => this.RaiseAndSetIfChanged(ref _IsVisible, value);
    }

    ToastService()
    {
        notifier = new Subject<string>();
        notifier
            .Do(x =>
            {
                notificationMessage = x;
                RaiseMessagePropertyChanged();
            })
            .Throttle(TimeSpan.FromMilliseconds(5000))
            .Subscribe(_ =>
            {
                notificationMessage = string.Empty;
                RaiseMessagePropertyChanged();
            });

        this.WhenAnyValue(x => x.Message)
                 .Subscribe(x => IsVisible = !string.IsNullOrEmpty(x));
    }

    public void Set()
    {
        CloseBtn_Click();
    }

    [Obsolete("不再使用常驻通知")]
    public void Set(string message)
    {
        MainThread2.BeginInvokeOnMainThread(() => Message = message);
    }

    public void Notify(string message)
    {
        notifier.OnNext(message);
    }

    void RaiseMessagePropertyChanged()
    {
        this.RaisePropertyChanged(nameof(Message));
    }

    public void CloseBtn_Click()
    {
        Set("");
        IsVisible = false;
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Net\IHostsFileService.cs
/ </summary>
[IpcPublic(Timeout = AssemblyInfo.IpcTimeout, IgnoresIpcException = false)]
public interface IHostsFileService
{
    static class Constants
    {
        public static IHostsFileService Instance => Ioc.Get<IHostsFileService>();
    }

    
/ </summary>
    void OpenFile();

    
/ </summary>
    void OpenFileDir();

    
/ </summary>
    Task<bool> ResetFile();

    
/ </summary>
    
/ <returns></returns>
    OperationResult<List<(string ip, string domain)>> ReadHostsAllLines();

    
/ </summary>
    
/ <param name="ip"></param>
    
/ <param name="domain"></param>
    
/ <returns></returns>
    Task<OperationResult> UpdateHosts(string ip, string domain);

    
/ <inheritdoc cref="UpdateHosts(IReadOnlyDictionary{string, string})"/>
    Task<OperationResult> UpdateHosts(IEnumerable<(string ip, string domain)> hosts);

    
/ </summary>
    
/ <param name="hosts"></param>
    
/ <returns></returns>
    Task<OperationResult> UpdateHosts(IReadOnlyDictionary<string, string> hosts);

    
/ </summary>
    
/ <param name="ip"></param>
    
/ <param name="domain"></param>
    
/ <returns></returns>
    Task<OperationResult> RemoveHosts(string ip, string domain);

    
/ <inheritdoc cref="RemoveHosts(string, string)"/>
    Task<OperationResult> RemoveHosts(string domain);

    
/ </summary>
    
/ <returns></returns>
    Task<OperationResult> RemoveHostsByTag();

    
/ </summary>
    Task OnExitRestoreHosts();

    
/ 获取当前 hosts 文件是否包含修改过的标签，注意：产生异常时也将返回 <see langword="false"/>，并 <see cref="Toast"/> 显示 <see cref="Exception"/>
    
/ </summary>
    
/ <returns></returns>
    bool ContainsHostsByTag();

#if DEBUG
    Task<bool> OccupyHosts();
#endif
}

#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services\Net\IHostsFileService.cs
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPlatformService.Biometric.cs
/ <para>Windows Hello</para>
    
/ </summary>
    ValueTask<bool> IsSupportedBiometricAsync() => new(false);
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPlatformService.cs
/ </summary>
public partial interface IPlatformService : IPCPlatformService
{
    
/ </summary>
    static IPlatformService Instance => Ioc.Get<IPlatformService>();

    protected const string TAG = "PlatformS";

    static class IPCRoot
    {
        internal const string moduleName = "Administrator";
        internal const string args_PipeName = "-n";
        internal const string args_ProcessId = "-p";
        internal const string CommandName = "sudo";

        static readonly TaskCompletionSource<IPCPlatformService> tcs = new();

        
/ </summary>
        public static Task<IPCPlatformService> Instance => tcs.Task;

        internal static async Task SetIPC(IPCMainProcessService ipc)
        {
            try
            {
                var iPCPlatformService = await ipc.GetServiceAsync<IPCPlatformService>(moduleName);
                /*T: */
                iPCPlatformService.ThrowIsNull();
                
/                            Console.WriteLine($"DebugString/IPCPlatformService: {debugStringIPC}");
                
/{
                    debugStringIPC = iPCPlatformService.GetDebugString(/*stream*/);
                    
/}
                    debugStringIPC = $"Pid: {Environment.ProcessId}, Exe: {Environment.ProcessPath}, Asm: {Assembly.GetAssembly(typeof(IPlatformService))?.FullName}{Environment.NewLine}{debugStringIPC}";
                    Console.WriteLine($"DebugString/IPCPlatformService: {debugStringIPC}");
                }
                catch (Exception ex)
                {
                    Console.WriteLine(ex);
                    
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPlatformService.cs
DEBUG
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPlatformService.Encoding.cs
/ 在 Windows 上时使用 .NET Framework 中 <see cref="Encoding.Default"/> 行为。
    
/ <para></para>
    
/ 非 Windows 上等同于 <see cref="Encoding.Default"/>(UTF8)
    
/ </summary>
    Encoding Default => Encoding.Default;
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPlatformService.Explorer.cs
/ </summary>
    
/ <param name="path"></param>
    void OpenFolder(string path)
    {
        sbyte isDirectory = -1;
        FileInfo? fileInfo;
        DirectoryInfo directoryInfo = new(path);
        if (directoryInfo.Exists) 
/ </summary>
    
/ <param name="info"></param>
    void OpenFolderByDirectoryPath(DirectoryInfo info)
    {

    }

    
/ </summary>
    
/ <param name="info"></param>
    void OpenFolderSelectFilePath(FileInfo info)
    {

    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPlatformService.Font.cs
/ </summary>
    
/ <param name="fontWeight"></param>
    
/ <returns></returns>
    string GetDefaultFontFamily(FontWeight fontWeight = FontWeight.Normal)
        => DefaultGetDefaultFontFamily();

    protected static string DefaultGetDefaultFontFamily()
        => SkiaSharp.SKTypeface.Default.FamilyName;
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPlatformService.ForegroundService.cs
/ </summary>
    bool UsePlatformForegroundService => false;

    
/ </summary>
    
/ <param name="serviceName"></param>
    
/ <param name="startOrStop">启动或停止或取反</param>
    
/ <returns></returns>
    
/ <exception cref="PlatformNotSupportedException"></exception>
    Task StartOrStopForegroundServiceAsync(string serviceName, bool? startOrStop = null)
        => throw new PlatformNotSupportedException();
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPlatformService.IsAdministrator.cs
/ 当前程序是否以 Administrator/System(Windows) 或 Root(FreeBSD/Linux/MacOS/Android/iOS) 权限运行
    
/ </summary>
    bool IsAdministrator =>
#if NET8_0_OR_GREATER
        Environment.IsPrivilegedProcess;
#elif WINDOWS
        throw new NotImplementedException();
#else
        _IsAdministrator.Value;

    private static readonly Lazy<bool> _IsAdministrator = new(() =>
    {
#if WINDOWS
        using WindowsIdentity identity = WindowsIdentity.GetCurrent();
        return identity.IsSystem || new WindowsPrincipal(identity)
            .IsInRole(WindowsBuiltInRole.Administrator);
#elif MACCATALYST || MACOS || LINUX || IOS || ANDROID
        return Interop.Libc.GetEUID() == 0;
#else
        throw new PlatformNotSupportedException();
#endif
    });

#endif
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPlatformService.IsAdministrator.cs
NET
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPlatformService.NativeWindow.cs
/ </summary>
    
/ <param name="action">目标窗口回调</param>
    void GetMoveMouseDownWindow(Action<NativeWindowModel> action);

    
/ </summary>
    
/ <param name="window"></param>
    void BeautifyTheWindow(nint hWnd);

    
/ </summary>
    
/ <param name="window"></param>
    void BorderlessWindow(NativeWindowModel window);

    
/ </summary>
    
/ <param name="window"></param>
    void MaximizeWindow(NativeWindowModel window);

    
/ </summary>
    
/ <param name="window"></param>
    void NormalWindow(NativeWindowModel window);

    
/ </summary>
    
/ <param name="window"></param>
    void ShowWindow(NativeWindowModel window);

    
/ </summary>
    
/ <param name="window"></param>
    void HideWindow(NativeWindowModel window);

    
/ </summary>
    
/ <param name="window"></param>
    void ToWallerpaperWindow(NativeWindowModel window);

    
/ </summary>
    
/ <returns></returns>
    string? GetWallerpaperImagePath();

    
/ </summary>
    void ResetWallerpaper();

    void SetParentWindow(IntPtr source, IntPtr dest);

    void SetActiveWindow(NativeWindowModel window);

    
/ </summary>
    
/ <param name="dest"></param>
    void SetWindowPenetrate(IntPtr dest);

    
/ </summary>
    
/ <param name="dest"></param>
    
/ <param name="width"></param>
    
/ <param name="height"></param>
    
/ <returns></returns>
    IntPtr SetDesktopBackgroundToWindow(IntPtr dest, int width, int height);

    void BackgroundUpdate(IntPtr dest, int width, int height);

    void ReleaseBackground(IntPtr dest);

#endif
}

#if DEBUG
[Obsolete("use IPlatformService", true)]
public interface INativeWindowApiService
{

}
#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPlatformService.NativeWindow.cs
WINDOWS
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPlatformService.Net.Hosts.cs
/ </summary>
    string HostsFilePath =>
#if WINDOWS
        WINDOWS_HostsFilePath.HostsFilePath;
#else
        "/etc/hosts";
#endif

    
/ </summary>
    [Obsolete("use WriteDefaultHostsContent(Stream", true)]
    string DefaultHostsContent => string.Empty;

    
/ </summary>
    void WriteDefaultHostsContent()
    {
        using var fileStream = new FileStream(HostsFilePath,
            FileMode.OpenOrCreate,
            FileAccess.Write,
            FileShare.ReadWrite | FileShare.Delete);
        WriteDefaultHostsContent(fileStream);
    }

    
/ </summary>
    
/ <param name="stream"></param>
    void WriteDefaultHostsContent(Stream stream)
    {
        stream.SetLength(0);
    }
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPlatformService.Net.Hosts.cs
WINDOWS
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPlatformService.OS.Linux.cs
/ </summary>
    string? SystemUserPassword { get; set; }

    
/ 获取系统用户密码（密码将缓存在 <see cref="SystemUserPassword"/> 中）
    
/ </summary>
    
/ <param name="retry"></param>
    
/ <exception cref="PlatformNotSupportedException"></exception>
    async ValueTask<string?> GetSystemUserPasswordAsync(sbyte retry = GetSystemUserPasswordRetry)
    {
        if (SystemUserPassword != null)
            SystemUserPassword = await GetSystemUserPasswordIgnoreCacheAsync(retry) ?? "";
        return SystemUserPassword;
    }

    
/ <inheritdoc cref="GetSystemUserPasswordAsync(sbyte)"/>
    async void GetSystemUserPassword(sbyte retry = GetSystemUserPasswordRetry) => await GetSystemUserPasswordAsync(retry);

    
/ </summary>
    
/ <param name="retry"></param>
    
/ <returns></returns>
    
/ <exception cref="PlatformNotSupportedException"></exception>
    protected ValueTask<string?> GetSystemUserPasswordIgnoreCacheAsync(sbyte retry = GetSystemUserPasswordRetry)
        => throw new PlatformNotSupportedException();

#if DEBUG
    [Obsolete("use GetSystemUserPasswordAsync", true)]
    async void TryGetSystemUserPassword(sbyte retry = GetSystemUserPasswordRetry) => await GetSystemUserPasswordAsync(retry);
#endif
#endif

    #endregion
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPlatformService.OS.Linux.cs
LINUX
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPlatformService.OS.Linux.Etc.Os_Release.cs
/ ReSharper disable once CheckNamespace
namespace BD.WTTS.Services;

partial interface IPlatformService
{
    #region LinuxEtcOs_Release

#if LINUX || APP_REVERSE_PROXY

    private const string LinuxFilePath_EtcOSRelease = "/etc/os-release";

    private static IEnumerable<KeyValuePair<string, string>> ReadEtcOSRelease()
    {
        if (OperatingSystem.IsLinux())
        {
            var lines = File.ReadLines(LinuxFilePath_EtcOSRelease);
            foreach (var line in lines)
            {
                var array = line.Split('=', StringSplitOptions.None);
                if (array.Length >= 2)
                {
                    var value = array[1].Trim().TrimStart('"').TrimEnd('"');
                    if (!string.IsNullOrWhiteSpace(value))
                        yield return new KeyValuePair<string, string>(array[0], value);
                }
            }
        }
    }

    protected static readonly Lazy<IEnumerable<KeyValuePair<string, string>>> EtcOSRelease = new(() =>
    {
        try
        {
            var r = ReadEtcOSRelease();
            return r;
        }
        catch
        {
        }
        return Array.Empty<KeyValuePair<string, string>>();
    });

#pragma warning disable IDE1006 
/www.steampowered.com/"
        
/support.steampowered.com/"
        
/support.steampowered.com/"
        
/support.steampowered.com/"
        
/www.deepin.org/"
        
/bbs.deepin.org/"

        
/www.chinauos.com/"
        
/ </summary>
    static LinuxConstants.Distribution LinuxDistribution => _LinuxDistribution.Value;

#endif

    #endregion
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPlatformService.OS.Linux.Etc.Os_Release.cs
LINUX
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPlatformService.OS.macOS.cs
/support.apple.com/zh-cn/guide/remote-desktop/apdd0c5a2d5/mac
    
/ </summary>
    
/ <returns></returns>
    string[] GetMacOSNetworkSetup() => Array.Empty<string>();

#endif
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPlatformService.OS.macOS.cs
MACCATALYST
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPlatformService.OS.Windows.cs
/ </summary>
    void OpenDesktopIconsSettings() { }

    void OpenGameControllers() { }

    
/ </summary>
    
/ <param name="fileName"></param>
    
/ <param name="arguments"></param>
    
/ <returns></returns>
    Process? StartAsInvoker(string fileName, string? arguments = null)
        => Process2.Start(fileName, arguments);

    
/ </summary>
    
/ <param name="hWnd"></param>
    
/ <param name="isVisible"></param>
    void SetWindowSystemButtonsIsVisible(IntPtr hWnd, bool isVisible) { }

#if DEBUG

    
/docs.microsoft.com/zh-cn/windows/win32/api/dwmapi/nf-dwmapi-dwmiscompositionenabled</para>
    
/ </summary>
    [Obsolete("Windows 7 is no longer supported.")]
    bool DwmIsCompositionEnabled => true;

    
/ </summary>
    
/ <param name="hWnd"></param>
    [Obsolete("Windows 7 is no longer supported.")]
    void FixAvaloniaFluentWindowStyleOnWin7(IntPtr hWnd)
    {
        if (DwmIsCompositionEnabled)
        {
            SetWindowSystemButtonsIsVisible(hWnd, true);
        }
    }

#endif

    
/ </summary>
    string WindowsProductName => string.Empty;

    
/ </summary>
    int WindowsVersionRevision => default;

    
/ 获取当前 Windows 10/11 系统显示版本，例如 21H1
    
/ </summary>
    string WindowsReleaseIdOrDisplayVersion => string.Empty;
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPlatformService.OS.Windows.cs
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPlatformService.Process.cs
/ 与 <see cref="Environment.GetCommandLineArgs"/> 一样，使用此方法获取的参数是包含应用程序路径的
    
/ 关于 <see cref="Environment.GetCommandLineArgs"/> 可参见：
    
/blog.walterlv.com/post/when-will-the-command-line-args-contain-the-executable-path.html
    
/ </summary>
    
/ <param name="process">一个正在运行的进程</param>
    
/ <returns>表示应用程序运行命令行参数的字符串</returns>
    string GetCommandLineArgs(Process process)
    {
        if (process.Id == Environment.ProcessId)
        {
            return Environment.CommandLine;
        }
        return string.Empty;
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPlatformService.SystemBoot.cs
/ </summary>
    void SystemLock(int waitSecond = 30) { }

    
/ </summary>
    
/ <param name="waitSecond">等待秒数</param>
    void SystemShutdown(int waitSecond = 30) { }

    
/ </summary>
    
/ <param name="waitSecond">等待秒数</param>
    void SystemSleep(int waitSecond = 30) { }

    
/ </summary>
    
/ <param name="waitSecond">等待秒数</param>
    void SystemHibernate(int waitSecond = 30) { }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPlatformService.SystemOnOff.cs
/ </summary>
    void SetSystemSessionEnding(Action action) { }

    
/ </summary>
    
/ <param name="isAutoStart">开启<see langword="true"/>、关闭<see langword="false"/></param>
    
/ <param name="name"></param>
    void SetBootAutoStart(bool isAutoStart, string name) { }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPlatformService.SystemProxy.cs
/ </summary>
    protected static string[] GetNoProxyHostName => new string[] {
        "10.*",
        "172.16.*",
        "172.17.*",
        "172.18.*",
        "172.19.*",
        "172.20.*",
        "172.21.*",
        "172.22.*",
        "172.23.*",
        "172.24.*",
        "172.25.*",
        "172.26.*",
        "172.27.*",
        "172.28.*",
        "172.29.*",
        "172.30.*",
        "172.31.*",
        "192.168.*",
        Constants.Urls.OfficialApiHostName,
        Constants.Urls.OfficialShopApiHostName,
    };

    
/ </summary>
    Task<bool> SetAsSystemProxyAsync(bool state, IPAddress? ip = null, int port = -1) => Task.FromResult(false);

    
/ </summary>
    
/ <param name="state"></param>
    
/ <param name="url"></param>
    
/ <returns></returns>
    Task<bool> SetAsSystemPACProxyAsync(bool state, string? url = null) => Task.FromResult(false);
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPlatformService.TextReader.cs
/ </summary>
    
/ <param name="filePath"></param>
    void OpenFileByTextReader(string filePath)
    {
#if (WINDOWS || MACCATALYST || MACOS || LINUX) && !(IOS || ANDROID)
        TextReaderProvider? userProvider = null;
        var p = GeneralSettings.TextReaderProvider.Value;
        if (p != null)
        {
            var platform = DeviceInfo2.Platform();
            if (p.ContainsKey(platform))
            {
                var value = p[platform];
                if (!string.IsNullOrWhiteSpace(value))
                {
                    if (Enum.TryParse<TextReaderProvider>(value, out var enumValue))
                    {
                        userProvider = enumValue;
                    }
                    else
                    {
                        try
                        {
                            Process2.StartPath(value, filePath);
                            return;
                        }
                        catch (Exception e)
                        {
                            Log.Error(TAG, e, "UserSettings OpenFileByTextReader Fail.");
                        }
                    }
                }
            }
        }

        var providers = new List<TextReaderProvider>()
            {
                TextReaderProvider.VSCode,
                TextReaderProvider.Notepad,
            };

        if (userProvider.HasValue)
        {
            providers.Remove(userProvider.Value);
            providers.Insert(0, userProvider.Value);
        }

        foreach (var item in providers)
        {
            if (item == TextReaderProvider.VSCode && !OperatingSystem.IsWindows())
            {
                
/ </summary>
    
/ <param name="provider"></param>
    
/ <returns></returns>
    string? GetFileName(TextReaderProvider provider) => null;
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPlatformService.Theme.cs
/ 是否应使用 亮色主题 <see langword="true"/> / 暗色主题 <see langword="false"/>
    
/ </summary>
    bool? IsLightOrDarkTheme { get; }

    
/ </summary>
    
/ <param name="enable"></param>
    void SetLightOrDarkThemeFollowingSystem(bool enable);
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPlatformService.UnixSetFileAccess.cs
/ ReSharper disable once CheckNamespace
namespace BD.WTTS.Services;

partial interface IPlatformService
{
    const UnixFileMode Combined755 = UnixFileMode.UserRead | UnixFileMode.UserWrite |
        UnixFileMode.UserExecute | UnixFileMode.GroupRead |
        UnixFileMode.GroupExecute | UnixFileMode.OtherRead |
        UnixFileMode.OtherExecute;

    const UnixFileMode Combined777 = UnixFileMode.UserRead | UnixFileMode.UserWrite |
            UnixFileMode.UserExecute | UnixFileMode.GroupRead |
            UnixFileMode.GroupWrite | UnixFileMode.GroupExecute |
            UnixFileMode.OtherRead | UnixFileMode.OtherWrite |
            UnixFileMode.OtherExecute;

#if DEBUG
    [Obsolete("use System.IO.UnixFileMode")]
    [Flags]
    enum UnixPermission : ushort
    {
        OtherExecute = 0x1,
        OtherWrite = 0x2,
        OtherRead = 0x4,
        GroupExecute = 0x8,
        GroupWrite = 0x10,
        GroupRead = 0x20,
        UserExecute = 0x40,
        UserWrite = 0x80,
        UserRead = 0x100,
        [Obsolete("use IPlatformService.Combined755")]
        Combined755 = UserRead | UserWrite |
            UserExecute | GroupRead |
            GroupExecute | OtherRead |
            OtherExecute,
        [Obsolete("use IPlatformService.Combined777")]
        Combined777 = UserRead | UserWrite |
            UserExecute | GroupRead |
            GroupWrite | GroupExecute |
            OtherRead | OtherWrite |
            OtherExecute,
    }

    [Obsolete("use UnauthorizedAccessException/DirectoryNotFoundException/FileNotFoundException", true)]
    enum UnixSetFileAccessResult
    {
        PathIsNullOrEmpty = -3,
        PathInvalid,
        Failure,
        Success,
    }

    [Obsolete("use System.IO.File.SetUnixFileMode", true)]
    UnixSetFileAccessResult UnixSetFileAccess(string? path, UnixPermission permission)
    {
        throw new NotImplementedException();
    }
#endif
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPlatformService.UnixSetFileAccess.cs
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPC\IPCPlatformService.AppUpdate.cs
/ </summary>
    
/ <param name="path"></param>
    
/ <param name="sha384"></param>
    void SetUpdatePackageInfo(string path, byte[] sha384)
    {
#if !LIB_CLIENT_IPC
        IAppUpdateService.UpdatePackageInfo = (path, sha384);
#endif
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPC\IPCPlatformService.Certificate.cs
/ </summary>
    
/ <param name="certificate2"></param>
    
/ <returns></returns>
    bool IsCertificateInstalled(byte[] certificate2)
        => throw new PlatformNotSupportedException();

    
/ </summary>
    
/ <param name="filePath"></param>
    
/ <returns></returns>
    bool? TrustRootCertificateAsync(string filePath)
        => throw new PlatformNotSupportedException();

    
/ </summary>
    void RemoveCertificate(byte[] certificate2)
        => throw new PlatformNotSupportedException();
}

public static partial class IPCPlatformServiceExtensions
{
    
/ <inheritdoc cref="IPCPlatformService.IsCertificateInstalled(byte[])"/>
    public static bool IsCertificateInstalled(
        this IPCPlatformService platformService,
        X509CertificatePackable certificate2)
    {
        var certificate2_ = Serializable.SMP2(certificate2);
        return platformService.IsCertificateInstalled(certificate2_);
    }

    
/ <inheritdoc cref="IPCPlatformService.RemoveCertificate(byte[])"/>
    public static void RemoveCertificate(
        this IPCPlatformService platformService,
        X509CertificatePackable certificate2)
    {
        var certificate2_ = Serializable.SMP2(certificate2);
        platformService.RemoveCertificate(certificate2_);
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPC\IPCPlatformService.cs
/ </summary>
[IpcPublic(Timeout = AssemblyInfo.IpcTimeout, IgnoresIpcException = false)]
public partial interface IPCPlatformService
{
#if DEBUG
    string GetDebugString()
    {
        return $"Pid: {Environment.ProcessId}, Exe: {Environment.ProcessPath}, Asm: {Assembly.GetAssembly(GetType())?.FullName}";
    }
#endif
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPC\IPCPlatformService.cs
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPC\IPCPlatformService.IOPath.File.cs
/ <inheritdoc cref="IOPath.CopyFile(string, string, bool)"/>
    void CopyFile(string source, string dest, bool overwrite = true);

    
/ <inheritdoc cref="IOPath.CopyFilesRecursive(string?, string, bool)"/>
    bool CopyFilesRecursive(string? inputFolder, string outputFolder, bool overwrite = true);

    
/ <inheritdoc cref="IOPath.ReadAllText(string, Encoding?)"/>
    string ReadAllText(string path, int? encoding = null);

    
/ <inheritdoc cref="IOPath.ReadAllTextAsync(string, Encoding?, CancellationToken)"/>
    Task<string> ReadAllTextAsync(string path, int? encoding, CancellationToken cancellationToken = default);

    
/ <inheritdoc cref="IOPath.FileTryDelete(string)"/>
    bool FileTryDelete(string filePath);

    #region WriteAll

    
/ <inheritdoc cref="File.WriteAllText(string, string?, Encoding)"/>
    bool WriteAllText(string path, string? contents, int? encoding = null);

    
/ <inheritdoc cref="File.WriteAllTextAsync(string, string?, Encoding, CancellationToken)"/>
    Task<bool> WriteAllTextAsync(string path, string? contents, int? encoding = null, CancellationToken cancellationToken = default);

    
/ <inheritdoc cref="File.WriteAllLines(string, IEnumerable{string}, Encoding)"/>
    bool WriteAllLines(string path, IEnumerable<string> contents, int? encoding = null);

    
/ <inheritdoc cref="File.WriteAllLinesAsync(string, IEnumerable{string}, Encoding, CancellationToken)"/>
    Task<bool> WriteAllLinesAsync(string path, IEnumerable<string> contents, int? encoding = null, CancellationToken cancellationToken = default);

    
/ <inheritdoc cref="File.WriteAllBytes(string, byte[])"/>
    bool WriteAllBytes(string path, byte[] bytes);

    
/ <inheritdoc cref="File.WriteAllBytesAsync(string, byte[], CancellationToken)"/>
    Task<bool> WriteAllBytesAsync(string path, byte[] bytes, CancellationToken cancellationToken = default);

    #endregion
}

public static partial class IPCPlatformServiceExtensions
{
    
/ <inheritdoc cref="IOPath.ReadAllText(string, Encoding?)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static string ReadAllText(
        this IPCPlatformService s,
        string path, Encoding? encoding = null)
    {
        int? encoding_ = encoding?.CodePage;
        return s.ReadAllText(path, encoding_);
    }

    
/ <inheritdoc cref="IOPath.ReadAllTextAsync(string, Encoding?, CancellationToken)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Task<string> ReadAllTextAsync(
        this IPCPlatformService s,
        string path, Encoding? encoding, CancellationToken cancellationToken = default)
    {
        int? encoding_ = encoding?.CodePage;
        return s.ReadAllTextAsync(path, encoding_, cancellationToken);
    }

    
/ <inheritdoc cref="IOPath.ReadAllTextAsync(string, Encoding?, CancellationToken)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Task<string> ReadAllTextAsync(
        this IPCPlatformService s,
        string path, CancellationToken cancellationToken = default)
    {
        return s.ReadAllTextAsync(path, null, cancellationToken);
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPC\IPCPlatformService.IOPath.RegexSearch.cs
/ <inheritdoc cref="IOPath.RegexSearchFile(string, string)"/>
    string RegexSearchFile(string filePath, string pattern);

    
/ <inheritdoc cref="IOPath.RegexSearchFolder(string, string, string)"/>
    string RegexSearchFolder(string dirPath, string pattern, string wildcard = "");
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPC\IPCPlatformService.OS.Windows.Registry.cs
/ <inheritdoc cref="WindowsPlatformServiceImpl.StartProcessRegeditAsync(string, string, int)"/>
#endif
    [SupportedOSPlatform("windows")]

#if !LIB_CLIENT_IPC && WINDOWS
    async
#endif
    Task<byte> StartProcessRegeditCoreIPCAsync(
        string? markKey,
        string? markValue,
        string path,
        int millisecondsDelay)
    {
        const byte Code_Ok = 200;
#if !LIB_CLIENT_IPC && WINDOWS

        switch (markKey)
        {
            case nameof(WindowsPlatformServiceImpl.SetAsSystemProxyAsync):
                if (markValue == bool.TrueString)
                {
                    WindowsPlatformServiceImpl.SetAsSystemProxyStatus = true;
                }
                else if (markValue == bool.FalseString)
                {
                    WindowsPlatformServiceImpl.SetAsSystemProxyStatus = false;
                }
                break;
            case nameof(WindowsPlatformServiceImpl.SetAsSystemPACProxyAsync):
                if (markValue == bool.TrueString)
                {
                    WindowsPlatformServiceImpl.SetAsSystemPACProxyStatus = true;
                }
                else if (markValue == bool.FalseString)
                {
                    WindowsPlatformServiceImpl.SetAsSystemPACProxyStatus = false;
                }
                break;
        }

        await WindowsPlatformServiceImpl.StartProcessRegeditCoreAsync(path, millisecondsDelay);
        return Code_Ok;
#else
        return Task.FromResult(Code_Ok);
#endif
    }

    #region Registry2

    
/ <inheritdoc cref="Registry2.ReadRegistryKey(string, RegistryView)"/>
    [SupportedOSPlatform("windows")]
    string? ReadRegistryKey(string encodedPath, RegistryView view = Registry2.DefaultRegistryView)
    {
#if !LIB_CLIENT_IPC && WINDOWS
        var result = WindowsPlatformServiceImpl.ReadRegistryKeyCore(encodedPath, view);
        return result;
#else
        return default;
#endif
    }

    
/ <inheritdoc cref="Registry2.SetRegistryKey(string, RegistryView, string?)"/>
    [SupportedOSPlatform("windows")]
    bool SetRegistryKey(string encodedPath, RegistryView view, string? value = null)
    {
#if !LIB_CLIENT_IPC && WINDOWS
        var result = WindowsPlatformServiceImpl.SetRegistryKeyCore(encodedPath, view, value);
        return result;
#else
        return default;
#endif
    }

    
/ <inheritdoc cref="Registry2.DeleteRegistryKey(string, RegistryView)"/>
    [SupportedOSPlatform("windows")]
    bool DeleteRegistryKey(string encodedPath, RegistryView view = Registry2.DefaultRegistryView)
    {
#if !LIB_CLIENT_IPC && WINDOWS
        var result = WindowsPlatformServiceImpl.DeleteRegistryKeyCore(encodedPath, view);
        return result;
#else
        return default;
#endif
    }

    #endregion
}

public static partial class IPCPlatformServiceExtensions
{
    #region Registry2

    
/ <inheritdoc cref="Registry2.TryReadRegistryKey(string, RegistryView, out object?)"/>
    [SupportedOSPlatform("windows")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool TryReadRegistryKey(
        this IPCPlatformService s,
        string encodedPath,
        RegistryView view,
        [NotNullWhen(true)] out string? value)
    {
        value = s.ReadRegistryKey(encodedPath, view);
        return value != null;
    }

    
/ <inheritdoc cref="Registry2.TryReadRegistryKey(string, out object?)"/>
    [SupportedOSPlatform("windows")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool TryReadRegistryKey(
        this IPCPlatformService s,
        string encodedPath,
        [NotNullWhen(true)] out string? value)
    {
        value = s.ReadRegistryKey(encodedPath);
        return value != null;
    }

    
/ <inheritdoc cref="Registry2.SetRegistryKey(string, string?)"/>
    [SupportedOSPlatform("windows")]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool SetRegistryKey(
        this IPCPlatformService s,
        string encodedPath,
        string? value = null)
    {
        var result = s.SetRegistryKey(encodedPath, Registry2.DefaultRegistryView, value);
        return result;
    }

    #endregion
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPC\IPCPlatformService.OS.Windows.ScheduledTask.cs
/ <inheritdoc cref="IScheduledTaskService.SetBootAutoStart(bool, string, bool?)"/>
    [SupportedOSPlatform("windows")]
    void SetBootAutoStart(bool isAutoStart, string name, bool? isPrivilegedProcess = null)
    {
#if !LIB_CLIENT_IPC && WINDOWS
        IScheduledTaskService.Instance?.SetBootAutoStart(isAutoStart, name, isPrivilegedProcess);
#else
#endif
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPC\IPCPlatformService.Process.cs
/ </summary>
    
/ <param name="processStartInfo"></param>
    
/ <returns></returns>
    Task<int> StartProcessAsAdministratorAsync(byte[]? processStartInfo_)
    {
        if (processStartInfo_ == default)
            return Task.FromResult(0);
        var processStartInfo = Serializable.DMP2<ProcessStartInfo>(processStartInfo_);
        if (processStartInfo == default)
            return Task.FromResult(0);
        var process = Process.Start(processStartInfo);
        if (process == null)
            return Task.FromResult(0);
        return Task.FromResult(process.Id);
    }

    
/ </summary>
    
/ <param name="processNames"></param>
    bool? KillProcesses(params string[] processNames)
    {
        var processes = processNames.Select(static x =>
        {
            try
            {
                var process = Process.GetProcessesByName(x);
                return process;
            }
            catch
            {
                return Array.Empty<Process>();
            }
        }).SelectMany(static x => x).ToArray();

        static ApplicationException? KillProcess(Process? process)
        {
            if (process == null)
                return default;
            try
            {
                if (!process.HasExited)
                {
                    process.Kill();
                    process.WaitForExit();
                }
            }
            catch (Exception ex)
            {
                return new ApplicationException(
                    $"KillProcesses fail, name: {process?.ProcessName}", ex);
            }
            return default;
        }

        try
        {
            if (processes.Any())
            {
                var tasks = processes.Select(x =>
                {
                    return Task.Run(() =>
                    {
                        return KillProcess(x);
                    });
                }).ToArray();
                Task.WaitAll(tasks);

                var innerExceptions = tasks.Select(x => x.Result!)
                    .Where(x => x != null).ToArray();
                if (innerExceptions.Any())
                {
                    throw new AggregateException(
                        "KillProcess fail", innerExceptions);
                }
            }
        }
        catch (Exception ex)
        {
            Log.Error(nameof(IPCPlatformService), ex, "KillSteamProcess fail");
            return false;
        }

        return true;
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Platform\IPC\IPCPlatformService.RunShell.cs
/ </summary>
    
/ <param name="script">要运行的脚本字符串</param>
    
/ <param name="requiredAdministrator">是否以管理员或 Root 权限运行</param>
    async void RunShell(string script, bool requiredAdministrator = false)
        => await RunShellAsync(script, requiredAdministrator);

    
/ <inheritdoc cref="RunShell(string, bool)"/>
    ValueTask RunShellAsync(string script, bool requiredAdministrator = false) => default;

    ValueTask<bool?> RunShellReturnAsync(string script, bool requiredAdministrator = false) => default;
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\Platform\Windows\IScheduledTaskService.cs
/ </summary>
    
/ <param name="isAutoStart">开启或关闭</param>
    
/ <param name="name">任务名词</param>
    
/ <param name="isPrivilegedProcess">是否需要管理员权限启动，为 <see langword="null"/> 时将使用当前执行进程的权限判断</param>
    
/ <returns></returns>
    bool SetBootAutoStart(bool isAutoStart, string name, bool? isPrivilegedProcess = null);
}
#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services\Platform\Windows\IScheduledTaskService.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\UI\IFontManager.cs
/ </summary>
public interface IFontManager
{
    static IFontManager Instance => Ioc.Get<IFontManager>();

    static KeyValuePair<string, string> Default { get; } = new(AppResources.Default, KEY_Default);

    IReadOnlyCollection<KeyValuePair<string, string>> GetFonts();

    const string KEY_Default = "Default";
    
/docs.microsoft.com/en-us/uwp/api/windows.ui.xaml.media.fontfamily.xamlautofontfamily?view=winrt-22000
    
/ </summary>
    public const string KEY_WinUI = "XamlAutoFontFamily";
}

partial interface IPlatformService
{
    
/ </summary>
    
/ <returns></returns>
    public IReadOnlyCollection<KeyValuePair<string, string>> GetFonts()
    {
        
/docs.microsoft.com/zh-cn/typography/font-list
        var list = SkiaSharp.SKFontManager.Default.GetFontFamilies()
            .Select(x => new KeyValuePair<string, string>(x, x))
            .ToList();
        list.Insert(0, IFontManager.Default);
        return list;
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\UI\ViewModels\IViewModelManager.cs
/ </summary>
public interface IViewModelManager : IDisposable
{
    static IViewModelManager Instance => Ioc.Get<IViewModelManager>();

    
/ </summary>
    
/ <typeparam name="T"></typeparam>
    
/ <returns></returns>
    T Get<T>() where T : ViewModelBase;

    
/ </summary>
    
/ <param name="vmType"></param>
    
/ <returns></returns>
    ViewModelBase Get(Type vmType);

    
/ </summary>
    
/ <param name="viewModel"></param>
    void Dispose(ViewModelBase viewModel);

    
/ </summary>
    WindowViewModel? MainWindow { get; }

    
/ </summary>
    MainWindowViewModel? MainWindow2 => MainWindow as MainWindowViewModel;

    
/ </summary>
    
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\UI\Views\Windows\IWindowManager.cs
/ </summary>
public interface IWindowManager
{
    static IWindowManager Instance => Ioc.Get<IWindowManager>();

    
/ </summary>
    
/ <typeparam name="TPageViewModel"></typeparam>
    
/ <param name="viewModel"></param>
    
/ <param name="title"></param>
    
/ <param name="subHeader"></param>
    
/ <param name="isDialog"></param>
    
/ <param name="isFooterExpanded"></param>
    
/ <returns></returns>
    Task<bool> ShowTaskDialogAsync<TPageViewModel>(
        TPageViewModel viewModel,
        string title = "",
        string? header = null,
        string? subHeader = null,
        bool isDialog = false,
        bool showProgressBar = false,
        bool isRememberChooseFooter = false,
        bool isOkButton = true,
        bool isCancelButton = false,
        bool isRetryButton = false,
        object? pageContent = null,
        string? okButtonText = null,
        string? retryButtonText = null,
        string? moreInfoText = null,
        Func<bool>? cancelCloseAction = null,
        bool disableScroll = false)
        where TPageViewModel : ViewModelBase;

    
/ </summary>
    
/ <typeparam name="TWindowViewModel"></typeparam>
    
/ <param name="appEndPoint"></param>
    
/ <param name="viewModel"></param>
    
/ <param name="title"></param>
    
/ <param name="resizeMode"></param>
    
/ <param name="isDialog"></param>
    
/ <param name="isParent"></param>
    
/ <returns></returns>
    Task ShowAsync<TWindowViewModel>(
        AppEndPoint appEndPoint,
        TWindowViewModel? viewModel = null,
        string title = "",
        ResizeMode resizeMode = ResizeMode.NoResize,
        bool isDialog = false,
        bool isParent = true)
        where TWindowViewModel : WindowViewModel, new();

    
/ </summary>
    
/ <param name="typeWindowViewModel"></param>
    
/ <param name="appEndPoint"></param>
    
/ <param name="viewModel"></param>
    
/ <param name="title"></param>
    
/ <param name="resizeMode"></param>
    
/ <param name="isDialog"></param>
    
/ <param name="isParent"></param>
    
/ <returns></returns>
    Task ShowAsync(Type typeWindowViewModel,
        AppEndPoint appEndPoint,
        WindowViewModel? viewModel = null,
        string title = "",
        ResizeMode resizeMode = ResizeMode.NoResize,
        bool isDialog = false,
        bool isParent = true);

    
/ </summary>
    
/ <param name="appEndPoint"></param>
    
/ <param name="viewModel"></param>
    
/ <param name="title"></param>
    
/ <param name="resizeMode"></param>
    
/ <param name="isDialog"></param>
    
/ <param name="isParent"></param>
    
/ <returns></returns>
    Task ShowAsync(AppEndPoint appEndPoint,
        WindowViewModel? viewModel = null,
        string title = "",
        ResizeMode resizeMode = ResizeMode.NoResize,
        bool isDialog = false,
        bool isParent = true);

    
/ 显示一个弹窗，返回 <see langword="true"/> 确定(仅当ViewModel继承自<see cref="DialogWindowViewModel"/>时生效)，<see langword="false"/> 取消
    
/ </summary>
    
/ <typeparam name="TWindowViewModel"></typeparam>
    
/ <param name="appEndPoint"></param>
    
/ <param name="viewModel"></param>
    
/ <param name="title"></param>
    
/ <param name="resizeMode"></param>
    
/ <param name="isDialog"></param>
    
/ <param name="isParent"></param>
    
/ <returns></returns>
    Task<bool> ShowDialogAsync<TWindowViewModel>(
        AppEndPoint appEndPoint,
        TWindowViewModel? viewModel = null,
        string title = "",
        ResizeMode resizeMode = ResizeMode.NoResize,
        bool isDialog = true,
        bool isParent = true)
        where TWindowViewModel : WindowViewModel, new();

    
/ 显示一个弹窗，返回 <see langword="true"/> 确定(仅当ViewModel继承自<see cref="DialogWindowViewModel"/>时生效)，<see langword="false"/> 取消
    
/ </summary>
    
/ <param name="typeWindowViewModel"></param>
    
/ <param name="appEndPoint"></param>
    
/ <param name="viewModel"></param>
    
/ <param name="title"></param>
    
/ <param name="resizeMode"></param>
    
/ <param name="isDialog"></param>
    
/ <returns></returns>
    Task ShowDialogAsync(Type typeWindowViewModel,
        AppEndPoint appEndPoint,
        WindowViewModel? viewModel = null,
        string title = "",
        ResizeMode resizeMode = ResizeMode.NoResize,
        bool isDialog = true);

    
/ 显示一个弹窗，返回 <see langword="true"/> 确定(仅当ViewModel继承自<see cref="DialogWindowViewModel"/>时生效)，<see langword="false"/> 取消
    
/ </summary>
    
/ <param name="appEndPoint"></param>
    
/ <param name="viewModel"></param>
    
/ <param name="title"></param>
    
/ <param name="resizeMode"></param>
    
/ <param name="isDialog"></param>
    
/ <returns></returns>
    Task ShowDialogAsync(AppEndPoint appEndPoint,
        WindowViewModel? viewModel = null,
        string title = "",
        ResizeMode resizeMode = ResizeMode.NoResize,
        bool isDialog = true);

    
/ </summary>
    
/ <param name="vm"></param>
    void CloseWindow(WindowViewModel vm) { }

    
/ </summary>
    
/ <param name="vm"></param>
    
/ <returns></returns>
    bool IsVisibleWindow(WindowViewModel vm) => false;

    
/ </summary>
    
/ <param name="vm"></param>
    void HideWindow(WindowViewModel vm) { }

    
/ </summary>
    
/ <param name="vm"></param>
    async void ShowWindow(WindowViewModel vm)
    {
        var windowName = vm.GetType().Name.TrimEnd(nameof(WindowViewModel));
        if (Enum.TryParse<AppEndPoint>(windowName, out var appEndPoint))
        {
            await ShowAsync(appEndPoint, vm);
        }
    }
}


/ <inheritdoc cref="IWindowManager"/>
public interface IWindowManagerImpl : IWindowManager
{
    Type? WindowType { get; }

    Type GetWindowType(AppEndPoint appEndPoint, params Assembly[]? assemblies)
    {
        IEnumerable<Assembly>? assemblies_ = assemblies;
        return GetWindowType(appEndPoint, assemblies_);
    }

    Type GetWindowType(AppEndPoint appEndPoint, IEnumerable<Assembly>? assemblies)
    {
        var typeName = $"BD.WTTS.UI.Views.Windows.{appEndPoint}Window";
        const string errMsg = "GetWindowType fail.";
        return GetType(typeName, WindowType, errMsg, appEndPoint, assemblies);
    }

    Type GetWindowViewModelType(AppEndPoint appEndPoint, params Assembly[]? assemblies)
    {
        IEnumerable<Assembly>? assemblies_ = assemblies;
        return GetWindowViewModelType(appEndPoint, assemblies_);
    }

    Type GetWindowViewModelType(AppEndPoint appEndPoint, IEnumerable<Assembly>? assemblies)
    {
        var typeName = $"BD.WTTS.UI.ViewModels.{appEndPoint}WindowViewModel";
        const string errMsg = "GetWindowViewModelType fail.";
        return GetType(typeName, typeof(WindowViewModel), errMsg, appEndPoint, assemblies);
    }

    private static Type GetType(string typeName, Type? baseType, string errMsg,
        AppEndPoint appEndPoint, IEnumerable<Assembly>? assemblies)
    {
        Type? type = null;
        if (assemblies.Any_Nullable())
        {
            foreach (var item in assemblies!)
            {
                type = item.GetType(typeName);
                if (type != null) break;
            }
        }
        else
        {
            type = Type.GetType(typeName);
        }
        if (type != null && (baseType == null || baseType.IsAssignableFrom(type))) return type;
        throw new ArgumentOutOfRangeException(nameof(appEndPoint), appEndPoint, errMsg);
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\UI\Widgets\IJumpListService.cs
/docs.microsoft.com/zh-cn/dotnet/api/system.windows.shell.jumplist</para>

/docs.microsoft.com/zh-cn/uwp/api/Windows.UI.StartScreen.JumpList</para>

/ <para>Taskbar Extensions</para>

/docs.microsoft.com/zh-cn/windows/win32/shell/taskbar-extensions</para>

/ </summary>
public interface IJumpListService
{
    protected const string TAG = "JumpListS";

    static IJumpListService Instance => Ioc.Get<IJumpListService>();

    ValueTask AddJumpItemsAsync(IEnumerable<(string title, string applicationPath, string iconResourcePath, string arguments, string description, string customCategory)> items);

    ValueTask AddJumpItemsAsync(params (string title, string applicationPath, string iconResourcePath, string arguments, string description, string customCategory)[] items) => AddJumpItemsAsync(items.AsEnumerable());
}
#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services\UI\Widgets\IJumpListService.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\UI\Widgets\IMessageBoxService.cs
/ </summary>
public interface IMessageBoxService
{
    static IMessageBoxService? Instance => Ioc.Get_Nullable<IMessageBoxService>();

    
/ </summary>
    
/ <param name="messageBoxText">一个 <see cref="string"/>，用于指定要显示的文本。</param>
    
/ <param name="caption">一个 <see cref="string"/>，用于指定要显示的标题栏标题。</param>
    
/ <param name="button">一个 <see cref="MessageBox.Button"/> 值，用于指定要显示哪个按钮或哪些按钮。</param>
    
/ <param name="icon">一个 <see cref="MessageBox.Image"/> 值，用于指定要显示的图标。</param>
    
/ <returns>一个 <see cref="MessageBox.Result"/> 值，用于指定用户单击了哪个消息框按钮。</returns>
    Task<MessageBox.Result> ShowAsync(string messageBoxText, string caption, MessageBox.Button button, MessageBox.Image icon);
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\UI\Widgets\INotificationService.cs
/ </summary>
    
/ <returns></returns>
    bool AreNotificationsEnabled() => true;

    
/ 显示本地通知，使用 new <see cref="NotificationBuilder"/>() 构建参数
    
/ </summary>
    
/ <param name="builder"></param>
    
/ </summary>
    
/ <param name="text">通知内容</param>
    
/ <param name="notificationType">通知类型</param>
    
/ <param name="autoCancel"></param>
    
/ <param name="title">通知标题</param>
    
/ <param name="entrance">点击通知的入口点</param>
    
/ <param name="requestUri">入口点为 <see cref="Entrance.Browser"/> 时的 HttpUrl</param>
    void Notify(
        string text,
        NotificationType notificationType,
        bool autoCancel = true,
        string? title = default,
        Entrance entrance = default,
        string? requestUri = default);
    
/ </summary>
    
/ <param name="notificationType"></param>
    void Cancel(NotificationType notificationType);

    
/ </summary>
    void CancelAll();

    
/ </summary>
    bool IsSupportNotifyDownload => false;

    
/ </summary>
    Progress<float> NotifyDownload(
        Func<string> text,
        NotificationType notificationType,
        string? title = default) => throw new PlatformNotSupportedException();

    
/ </summary> 
    
/ NotifyIcon / TrayIcon 右下角托盘菜单助手类
    
/ </summary>
    abstract class NotifyIconHelper
    {
        protected NotifyIconHelper() => throw new NotSupportedException();

        
/ <para>注意：在 Windows 上托盘初始化之前调用气泡消息会导致托盘不显示</para>
        
/ </summary>
        public static bool IsInitialized { get; protected set; }
    }

    interface ILifeCycle
    {
        static ILifeCycle? Instance => INotificationService.Instance is ILifeCycle value ? value : null;

        void OnStartup();

        void OnShutdown();
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\UI\Widgets\IToastService.cs
/ </summary>
public interface IToastService : IToast
{
    static IToastService Instance => Ioc.Get<IToastService>();

}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services\UI\Widgets\IPC\IPCToastService.cs
/ </summary>
[IpcPublic(Timeout = AssemblyInfo.IpcTimeout, IgnoresIpcException = true)]
public interface IPCToastService
{
    enum ToastText
    {
        CreateCertificateFaild = 1,
        CommunityFix_DNSErrorNotify,

        [Obsolete]
        CommunityFix_OnRunCatch,
    }

    
/ </summary>
    enum ToastIcon : byte
    {
        
/ </summary>
        None,

        
/ </summary>
        Info,

        
/ </summary>
        Success,

        
/ </summary>
        Warning,

        
/ </summary>
        Error,
    }

    void Show(ToastIcon icon, ToastText text, int? duration = null);

    void Show(ToastIcon icon, ToastText text, ToastLength duration);

    void Show(ToastIcon icon, ToastText text, int? duration = null, params string?[] args);

    void Show(ToastIcon icon, ToastText text, ToastLength duration, params string?[] args);

    void Show(ToastIcon icon, ToastText text, params string?[] args);

    void ShowAppend(ToastIcon icon, ToastText text, int? duration = null, string? appendText = null);

    void ShowAppend(ToastIcon icon, ToastText text, ToastLength duration, string? appendText);

    void ShowAppend(ToastIcon icon, ToastText text, string? appendText);
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\MicroServiceClient.cs
NETCOREAPP
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\App\AppUpdateServiceBaseImpl.cs
/ </summary>
    protected virtual async void OnExistNewVersion()
    {
        var hasActiveWindow = HasActiveWindow();
        if (hasActiveWindow)
        {
            await ShowNewVersionWindowAsync();
        }
        else
        {
            ShowNewVersionWindowOnMainOpen = true;
            ShowNewVersionNotifyAsync();
        }
    }

    static bool isCheckUpdateing;

    public async Task CheckUpdateAsync(bool force, bool showIsExistUpdateFalse = true)
    {
        if (!force && IsExistUpdate)
        {
            if (NewVersionInfo.HasValue())
            {
                OnExistNewVersion();
                return;
            }
            else
            {
                IsExistUpdate = false;
            }
        }

        if (isCheckUpdateing) return;
        isCheckUpdateing = true;

        var platform = DeviceInfo2.Platform();
        var deviceIdiom = DeviceInfo2.Idiom();
        if (deviceIdiom == DeviceIdiom.Tablet && platform == Platform.Apple)
        {
            deviceIdiom = DeviceIdiom.Phone;
        }
        var osVersion = OSVersion;
        var architecture = OperatingSystem2.IsWindows() ?
            RuntimeInformation.ProcessArchitecture :
            RuntimeInformation.OSArchitecture;
        var deploymentMode = application.DeploymentMode;
        var rsp = await client.Version.CheckUpdate(
            platform, deviceIdiom,
            osVersion,
            architecture,
            deploymentMode);
        if (rsp.IsSuccess)
        {
            static bool IsNewVersion(AppVersionDTO? value)
            {
                if (value.HasValue())
                {
                    if (value.Version != AssemblyInfo.FileVersion)
                    {
                        if (Version.TryParse(value.Version, out var newVersion) &&
                            Version.TryParse(AssemblyInfo.FileVersion, out var thisVersion))
                        {
                            if (newVersion <= thisVersion)
                            {
                                return false;
                            }
                        }
                        return true;
                    }
                }
                return false;
            }

            if (!IsNewVersion(rsp.Content))
            {
                IsExistUpdate = false;
                if (showIsExistUpdateFalse) toast.Show(ToastIcon.None, AppResources.IsExistUpdateFalse);
            }
            else
            {
                IsExistUpdate = true;
                NewVersionInfo = rsp.Content;
                OnExistNewVersion();
            }
        }
        else
        {
            
/ </summary>
    const bool isSupportedResume = false;

    bool _IsNotStartUpdateing = true;

    public bool IsNotStartUpdateing
    {
        get => _IsNotStartUpdateing;
        protected set => this.RaiseAndSetIfChanged(ref _IsNotStartUpdateing, value);
    }

    float _ProgressValue;

    public float ProgressValue
    {
        get => _ProgressValue;
        protected set => this.RaiseAndSetIfChanged(ref _ProgressValue, value);
    }

    string _ProgressString = string.Empty;

    public string ProgressString
    {
        get => _ProgressString;
        protected set => this.RaiseAndSetIfChanged(ref _ProgressString, value);
    }

    protected void OnReportDownloading3(float value, int current, int count) => OnReport(value, AppResources.Downloading3__.Format(MathF.Round(value, 2), current, count));

    protected void OnReportCalcHashing3(float value, int current, int count) => OnReport(value, AppResources.CalcHashing3__.Format(MathF.Round(value, 2), current, count));

    protected void OnReportDownloading(float value) => OnReport(value, AppResources.Downloading_.Format(MathF.Round(value, 2)));

    protected void OnReportCalcHashing(float value) => OnReport(value, AppResources.CalcHashing_.Format(MathF.Round(value, 2)));

    protected void OnReportDecompressing(float value) => OnReport(value, AppResources.Decompressing_.Format(MathF.Round(value, 2)));

    protected void OnReport(float value = 0f) => OnReport(value, string.Empty);

    protected IProgress<float>? progress;

    protected virtual void OnReport(float value, string str)
    {
        ProgressValue = value;
        ProgressString = str;

        if (notification.IsSupportNotifyDownload)
        {
            if (value == 0)
            {
                progress?.Report(100f);
                progress = notification.NotifyDownload(() => ProgressString,
                    NotificationType.NewVersion);
            }
            else if (value == 100f)
            {
                progress?.Report(100f);
                progress = null;
            }
            else
            {
                progress?.Report(value);
            }
        }
    }

    bool UpdatePackVerification(string filePath, string sha256, int current = 0, int count = 0)
    {
        void OnReportCalcHashing_(float value) => OnReportCalcHashing(value);
        void OnReportCalcHashing3_(float value) => OnReportCalcHashing3(value, current, count);

        Action<float> onReportCalcHashing = current > 0 && count > 0 ? OnReportCalcHashing3_ : OnReportCalcHashing_;
        onReportCalcHashing(0);
        try
        {
            using var fs = File.OpenRead(filePath);
            var sha256_ = Hashs.String.SHA256(fs);  
/ </summary>
    protected async void DownloadUpdate()
    {
        var isCallOverwriteUpgrade = false;

        if (isDownloading)
            return;

        if (!IsSupportedServerDistribution)
            throw new PlatformNotSupportedException();

        isDownloading = true;

        var newVersionInfo = NewVersionInfo;

        if (newVersionInfo.HasValue())
        {
            if (newVersionInfo!.DisableAutomateUpdate)
            {
                OpenInAppStore();
                goto end;
            }

            var isAndroid = OperatingSystem.IsAndroid();
            var isDesktop = IApplication.IsDesktop();
            if (!isAndroid && !isDesktop)
            {
                OpenInAppStore();
                goto end;
            }

            AppVersionDTODownload? download = null;
            if (newVersionInfo.Downloads != null)
            {
                if (isAndroid)
                {
                    CloudFileType apk = (CloudFileType)265;
                    download = GetByDownloadChannelSettings(
                        newVersionInfo.Downloads.Where(x => x.DownloadType == apk));
                }
                else if (isDesktop)
                {
                    download = GetByDownloadChannelSettings(
                        newVersionInfo.Downloads.Where(x => x.DownloadType == CloudFileType.SevenZip));
                    download ??= GetByDownloadChannelSettings(
                        newVersionInfo.Downloads.Where(x => x.DownloadType == CloudFileType.TarGzip));
                }
                else
                {
                    throw new PlatformNotSupportedException();
                }
            }
            if (download.HasValue()) 
/ <para>Android：打开apk包即可</para>
    
/ <para>isIncrement==<see langword="true"/> 增量更新，value值为下载缓存所在文件夹路径</para>
    
/ <para>isIncrement==<see langword="false"/> 全量更新，value值为压缩包文件名</para>
    
/ </summary>
    
/ <param name="value"></param>
    
/ <param name="isIncrement"></param>
    
/ <param name="downloadType"></param>
    protected virtual async void OverwriteUpgrade(string value, bool isIncrement, CloudFileType downloadType = default)
    {
        if (isIncrement) 
/ </summary>
    protected virtual async void OpenInAppStore()
    {
#if WINDOWS
        if (DesktopBridge.IsRunningAsUwp)
        {
            await Browser2.OpenAsync(Constants.Urls.MicrosoftStoreProtocolLink);
            return;
        }
#endif
        await Browser2.OpenAsync(Constants.Urls.OfficialWebsite);
    }

#if DEBUG
    public
#endif
    void StartUpdate()
    {
        if (IsSupportedServerDistribution &&
            NewVersionInfo.HasValue() &&
            !NewVersionInfo!.DisableAutomateUpdate)
        {
            IsNotStartUpdateing = false;
            DownloadUpdate();
        }
        else
        {
            OpenInAppStore();
        }
    }

    
/ </summary>
    [Obsolete]
    public static UpdateChannelType UpdateChannelType
    {
        get
        {
            var channel = GeneralSettings.UpdateChannel.Value;
            
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\App\AppUpdateServiceBaseImpl.cs
WINDOWS
DEBUG
WINDOWS
DEBUG
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Compression\SevenZipHelper.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Identity\UserManager.cs
/ <inheritdoc cref="IUserManager"/>
partial class UserManager : IUserManager
{
    protected const string TAG = "UserManager";

    protected readonly ISecureStorage storage;
    protected readonly ILogger logger;
    protected readonly IUserRepository userRepository;
    protected readonly ISecurityService security;

    public UserManager(
        ILoggerFactory loggerFactory,
        ISecureStorage storage,
        IUserRepository userRepository,
        ISecurityService security)
    {
        logger = loggerFactory.CreateLogger(TAG);
        this.storage = storage;
        this.userRepository = userRepository;
        this.security = security;
    }

    protected bool isAnonymous;
    protected CurrentUser? currentUser;
    protected IdentityUserInfoDTO? currentUserInfo;

    protected CurrentUser? CurrentUser
    {
        set
        {
            currentUser = value;
            isAnonymous = value == null;
        }
    }

    [Conditional("DEBUG")]
    void PrintCurrentUser(string name)
    {
        logger.LogDebug("name: {name}, PhoneNumber: {phoneNumber}",
            name, currentUser?.ToStringHideMiddleFour());
    }

    protected async ValueTask<CurrentUser?> GetCurrentUserAsync(bool clone)
    {
        if (currentUser == null && !isAnonymous)
        {
            try
            {
                CurrentUser = await storage.GetAsync<CurrentUser>(KEY_CURRENT_LOGIN_USER);
            }
            catch (Exception e)
            {
                logger.LogError(e, nameof(GetCurrentUserAsync));
            }
            PrintCurrentUser(nameof(GetCurrentUserAsync));
        }
        return clone ? currentUser?.Clone() : currentUser;
    }

    public CurrentUser? GetCurrentUser()
    {
        var hasCurrentUser = currentUser != null;
#if DEBUG
        var read_cache = Random2.Next(100) % 2 == 0;
        hasCurrentUser = read_cache && hasCurrentUser;
#endif
        CurrentUser? result;
        if (hasCurrentUser)
        {
            result = currentUser?.Clone();
        }
        else
        {
            Func<ValueTask<CurrentUser?>> func = GetCurrentUserAsync;
            result = func.RunSync();
        }
#if DEBUG
        logger.LogDebug("read_cache: {read_cache}, PhoneNumber: {phoneNumber}", read_cache, result?.ToStringHideMiddleFour());
#endif
        return result;
    }

    public ValueTask<CurrentUser?> GetCurrentUserAsync()
    {
        return GetCurrentUserAsync(true);
    }

    public async Task SetCurrentUserAsync(CurrentUser? value)
    {
        await storage.SetAsync(KEY_CURRENT_LOGIN_USER, value);
        CurrentUser = value;
        PrintCurrentUser("SetCurrentUser");
    }

    public async ValueTask<IdentityUserInfoDTO?> GetCurrentUserInfoAsync()
    {
        if (currentUserInfo == null && !isAnonymous)
        {
            var cUser = await GetCurrentUserAsync();
            if (cUser != null)
            {
                currentUserInfo = await GetUserInfoByIdAsync(cUser.UserId);
            }
        }
        return currentUserInfo;
    }

    public async Task SetCurrentUserInfoAsync(IdentityUserInfoDTO value, bool updateToDataBase)
    {
        currentUserInfo = value;
        if (updateToDataBase)
        {
            await InsertOrUpdateAsync(value);
        }
    }

    public async ValueTask<JWTEntity?> GetAuthTokenAsync()
    {
        var value = await GetCurrentUserAsync(false);
        return value?.AuthToken;
    }

    public async ValueTask<JWTEntity?> GetShopAuthTokenAsync()
    {
        var value = await GetCurrentUserAsync(false);
        return value?.ShopAuthToken;
    }

    public event Action? OnSignOut;

    public async Task SignOutAsync()
    {
        PrintCurrentUser("SignOut");
        currentUserInfo = default;
        await SetCurrentUserAsync(null);
        OnSignOut?.Invoke();
    }

    ValueTask<User?> GetUserTableByIdAsync(Guid userId)
    {
        return userRepository.FindAsync(userId);
    }

    static async Task<TUserDTO?> GetUserByTableAsync<TUserDTO>(User? user, Func<User, Task<TUserDTO?>> binding) where TUserDTO : IUserDTO
    {
        if (user == null) return default;
        var value = await binding(user);
        return value;
    }

    async Task<TUserDTO?> BindingUserAsync<TUserDTO>(User user) where TUserDTO : IUserDTO, new()
    {
        var nickName = await security.D(user.NickName);

        var value = new TUserDTO
        {
            Id = user.Id,
            NickName = nickName ?? string.Empty,
            Avatar = user.Avatar ?? default,
        };
        return value;
    }

    
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Identity\UserManager.cs
DEBUG
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\IPC\IPCMainProcessServiceImpl.cs
/ </summary>
public sealed partial class IPCMainProcessServiceImpl : IPCMainProcessService
{
    bool disposedValue;
    IpcProvider? ipcProvider;
    readonly ILogger logger;
    readonly List<string> moduleNames = new();
    readonly ILoggerFactory loggerFactory;

    public IPCMainProcessServiceImpl(ILoggerFactory loggerFactory)
    {
        this.loggerFactory = loggerFactory;
        logger = loggerFactory.CreateLogger<IPCMainProcessServiceImpl>();
    }

    sealed class IpcLogger_ : IpcLogger
    {
        readonly ILogger logger;

        public IpcLogger_(ILoggerFactory loggerFactory, string name) : base(name)
        {
            logger = loggerFactory.CreateLogger(name);
        }

        static MSEXLogLevel Convert(IPCLogLevel logLevel)
        {
            if (logLevel <= IPCLogLevel.Debug)
                return MSEXLogLevel.Debug;
            return (MSEXLogLevel)logLevel;
        }

        protected override void Log<TState>(
            IPCLogLevel logLevel,
            TState state,
            Exception? exception,
            Func<TState, Exception?, string> formatter)
        {
            logger.Log(Convert(logLevel), default, state, exception, formatter);
        }
    }

    readonly ConcurrentDictionary<string, Process> subProcesses = new();
    readonly ConcurrentDictionary<string, Func<IPCMainProcessService, ValueTask<Process?>>> startSubProcesses = new();
    readonly ConcurrentBag<string> isReconnected = new();

    void AddSubProcess(string moduleName, Process? process)
    {
        if (process == null)
            return;

        if (subProcesses.TryGetValue(moduleName, out var process1))
        {
            bool hasExited = false;
            try
            {
                hasExited = process1.HasExited;
            }
            catch
            {

            }
            if (!hasExited)
            {
                try
                {
                    subProcesses.TryRemove(moduleName, out var _);
                    process1.KillEntireProcessTree();
                }
                catch
                {

                }
            }
            subProcesses[moduleName] = process;
        }
        else
        {
            subProcesses.TryAdd(moduleName, process);
        }
    }

    public Process? AddDaemonWithStartSubProcess(string moduleName, Func<IPCMainProcessService, Process?> @delegate)
    {
        ValueTask<Process?> StartSubProcessDelegate(IPCMainProcessService ipc)
        {
            var process = @delegate(ipc);
            return ValueTask.FromResult(process);
        }

        if (startSubProcesses.ContainsKey(moduleName))
        {
            startSubProcesses[moduleName] = StartSubProcessDelegate;
        }
        else
        {
            startSubProcesses.TryAdd(moduleName, StartSubProcessDelegate);
        }
        var process = @delegate?.Invoke(this);
        AddSubProcess(moduleName, process);
        return process;
    }

    public async ValueTask<Process?> AddDaemonWithStartSubProcessAsync(string moduleName, Func<IPCMainProcessService, ValueTask<Process?>> @delegate)
    {
        if (startSubProcesses.ContainsKey(moduleName))
        {
            startSubProcesses[moduleName] = @delegate;
        }
        else
        {
            startSubProcesses.TryAdd(moduleName, @delegate);
        }
        var process = await @delegate.Invoke(this);
        AddSubProcess(moduleName, process);
        return process;
    }

    public async ValueTask<Process?> StartSubProcessAsync(
        string fileName,
        bool isAdministrator = false,
        Action<ProcessStartInfo>? configure = null)
    {
        var pipeName = ipcProvider.ThrowIsNull().IpcContext.PipeName;
        var pid = Environment.ProcessId;
        
/ Linux 启动子模块前需要判断是否有 Exec 执行权限 
        Process.Start(Process2.BinBash, new string[]
        {
            "-c",
            shellStr,
        }).WaitForExit();

#endif

        var psi = new ProcessStartInfo
        {
            FileName = fileName,
            UseShellExecute = useShellExecute,
            CreateNoWindow = createNoWindow,
        };
        psi.ArgumentList.Add(pipeName);
        psi.ArgumentList.Add(pid.ToString());
        psi.ArgumentList.Add(mSubProcessArgumentIndex2Model.Value);
        configure?.Invoke(psi);
#if !MACOS
        DotNetRuntimeHelper.AddEnvironment(psi);
#endif
        var nativeLibraryPath = Startup.NativeLibraryPath;
        if (!string.IsNullOrWhiteSpace(nativeLibraryPath))
        {
            psi.Environment.TryAdd(
                IPCSubProcessService.EnvKey_NativeLibraryPath,
                nativeLibraryPath);
        }
        if (isAdministrator
#if WINDOWS
            && !WindowsPlatformServiceImpl.IsPrivilegedProcess
#endif
            )
        {
            var psi_ = Serializable.SMP2(psi);
            var startPid = await IPlatformService.Instance.StartProcessAsAdministratorAsync(psi_);
            if (startPid == default)
                return default;
            try
            {
                var process = Process.GetProcessById(startPid);
                return process;
            }
            catch
            {
                return default;
            }
        }
        else
        {
            var process = Process.Start(psi);
            return process;
        }
    }

    readonly Lazy<string> mSubProcessArgumentIndex2Model = new(() =>
    {
        var m = new SubProcessArgumentIndex2Model
        {
            AppDataDirectory = IOPath.AppDataDirectory,
            CacheDirectory = IOPath.CacheDirectory,
        };
        var b = Serializable.SMP2(m);
        var s = b.Base64UrlEncode();
        return s;
    });

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static string _()
    {
#if DEBUG
        return "000";
#else
        return Random2.GenerateRandomString(randomChars: String2.LowerCaseLetters);
#endif
    }

    public void Run()
    {
        var tickCount64 = Environment.TickCount64;
        var pid = Environment.ProcessId;
        ipcProvider = new IpcProvider(
            $"ipc_{_()}{tickCount64}{pid / 3}{pid % 3}",
            new IpcConfiguration
            {
                AutoReconnectPeers = true, 
/ </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void ConfigureServices()
    {
        RegisterService<IPCPlatformService, IPlatformService>();
#if (WINDOWS || MACCATALYST || MACOS || LINUX) && !(IOS || ANDROID)
        IHostsFileService? hostsFileService = Ioc.Get_Nullable<IHostsFileService>();
        if (hostsFileService != null)
            RegisterService(hostsFileService);
#endif
        RegisterService<IPCToastService>(this);

        var s = Startup.Instance;
        if (s.TryGetPlugins(out var plugins))
        {

            foreach (var plugin in plugins)
            {
                try
                {
                    plugin.ConfigureServices(ipcProvider!, s);
                }
                catch (Exception ex)
                {
                    
/ </summary>
    
/ <typeparam name="T"></typeparam>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void RegisterService<T>()
        where T : class
        => ipcProvider!.CreateIpcJoint(Ioc.Get<T>());

    
/ </summary>
    
/ <typeparam name="T"></typeparam>
    
/ <typeparam name="TImpl"></typeparam>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void RegisterService<T, TImpl>()
        where T : class
        where TImpl : T
        => ipcProvider!.CreateIpcJoint<T>(Ioc.Get<TImpl>());

    
/ </summary>
    
/ <typeparam name="T"></typeparam>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void RegisterService<T>(T value)
        where T : class
        => ipcProvider!.CreateIpcJoint(value);

    public async ValueTask DisposeAsync()
    {
        await DisposeAsyncCore().ConfigureAwait(false);
        GC.SuppressFinalize(this);
    }

    async ValueTask DisposeAsyncCore()
    {
        if (!disposedValue)
        {
            if (moduleNames.Any())
            {
                await ExitModules(moduleNames);
            }

            
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\IPC\IPCMainProcessServiceImpl.cs
DEBUG
DEBUG
LINUX
WINDOWS
DEBUG
WINDOWS
DEBUG
DEBUG
DEBUG
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Net\HostsFileServiceImpl.cs
/ </summary>
    
/ <param name="line_split_array"></param>
    
/ <returns></returns>
    static string? GetMarkValue(string[] line_split_array)
    {
        if (line_split_array.Length == 3 || line_split_array.Length == 4)
        {
            var value = string.Join(' ', line_split_array);
            if (line_split_array.Length == 3)
            {
                if (string.Equals(value, MarkStart, StringComparison.OrdinalIgnoreCase))
                {
                    return MarkStart;
                }
                if (string.Equals(value, MarkEnd, StringComparison.OrdinalIgnoreCase))
                {
                    return MarkEnd;
                }
            }
            else /*if (array.Length == 4)*/
            {
                if (string.Equals(value, BackupMarkStart, StringComparison.OrdinalIgnoreCase))
                {
                    return BackupMarkStart;
                }
                if (string.Equals(value, BackupMarkEnd, StringComparison.OrdinalIgnoreCase))
                {
                    return BackupMarkEnd;
                }
            }
        }
        return default;
    }

    #endregion

    #region FileVerify

    
/ </summary>
    const long MaxFileLength = 52428800;

    
/ </summary>
    
/ <param name="message"></param>
    
/ <param name="fileInfo"></param>
    
/ <param name="removeReadOnly"></param>
    
/ <param name="checkReadOnly"></param>
    
/ <param name="checkMaxLength"></param>
    
/ <returns></returns>
    bool TryOperation([NotNullWhen(false)] out string? message,
        [NotNullWhen(true)] out FileInfo? fileInfo,
        out bool removeReadOnly,
        bool checkReadOnly = false,
        bool checkMaxLength = true)
    {
        try
        {
            message = null;
            removeReadOnly = false;
            fileInfo = new FileInfo(s.HostsFilePath);
            if (!fileInfo.Exists)
            {
                try
                {
                    using var stream = fileInfo.Create();
                    s.WriteDefaultHostsContent(stream);
                    return true;
                }
                catch (Exception ex)
                {
                    message = ex.GetAllMessage();
                    return false;
                }
            }
            
/ </summary>
    
/ <param name="fileInfo"></param>
    static void SetReadOnly(FileInfo fileInfo)
    {
        try
        {
            var attr = fileInfo.Attributes;
            if (!attr.HasFlag(FileAttributes.ReadOnly))
            {
                attr |= FileAttributes.ReadOnly;
                fileInfo.Attributes = attr;
            }
        }
        catch
        {
        }
    }

    #endregion

    #region Handle

    static string[] GetLineSplitArray(string line_value) => line_value.Split(' ', StringSplitOptions.RemoveEmptyEntries);

    internal static bool IsV1Format(string[] line_split_array) => line_split_array.Length == 3 && line_split_array[2] == "#Steam++";

    enum HandleLineResult
    {
        
/ </summary>
        IncorrectFormatNoneHandleWrite_W_False,

        
/ </summary>
        CorrectFormatStartHandle,

        
/ </summary>
        IncorrectFormatNoneHandleNoWrite_Null,

        
/ </summary>
        Duplicate,
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static bool? Convert(HandleLineResult handleLineResult)
    {
        return handleLineResult switch
        {
            HandleLineResult.IncorrectFormatNoneHandleWrite_W_False => false,
            HandleLineResult.CorrectFormatStartHandle => true,
            HandleLineResult.IncorrectFormatNoneHandleNoWrite_Null => null,
            _ => throw new ArgumentOutOfRangeException(nameof(handleLineResult), handleLineResult, null),
        };
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static HandleLineResult HandleLineV2(int line_num, HashSet<string> domains, string line_value, out string[] line_split_array, Func<string[], bool?>? func = null)
    {
        static bool Contains(HashSet<string> hs, string value) => !hs.Add(value);
        return HandleLineV2(Contains, line_num, domains, line_value, out line_split_array, func);
    }

    
/ <para><see langword="false"/> 当前行格式不正确，不处理直接写入</para>
    
/ <para><see langword="true"/> 当前行格式正确，开始处理</para>
    
/ <para><see langword="null"/> 当前行格式不正确，不处理也不写入</para>
    
/ </summary>
    
/ <param name="contains"></param>
    
/ <param name="line_num"></param>
    
/ <param name="domains"></param>
    
/ <param name="line_value"></param>
    
/ <param name="line_split_array"></param>
    
/ <param name="func"></param>
    
/ <returns></returns>
    static HandleLineResult HandleLineV2<T>(Func<T, string, bool> contains, int line_num, T domains, string line_value, out string[] line_split_array, Func<string[], bool?>? func = null)
    {
        line_split_array = GetLineSplitArray(line_value);
        if (func != null)
        {
            var r = func.Invoke(line_split_array);
            if (!r.HasValue) return HandleLineResult.IncorrectFormatNoneHandleNoWrite_Null;
            if (!r.Value) return HandleLineResult.IncorrectFormatNoneHandleWrite_W_False;
        }
        if (line_split_array.Length < 2) return HandleLineResult.IncorrectFormatNoneHandleWrite_W_False;
        if (line_split_array[0].StartsWith('#')) return HandleLineResult.IncorrectFormatNoneHandleWrite_W_False;
        if (line_split_array.Length > 2 && !line_split_array[2].StartsWith('#')) return HandleLineResult.IncorrectFormatNoneHandleWrite_W_False;
        if (IsV1Format(line_split_array)) return HandleLineResult.IncorrectFormatNoneHandleNoWrite_Null; 
/ </summary>
    
/ <returns></returns>
    Encoding GetEncoding() => GeneralSettings.HostsFileEncodingType.Value switch
    {
        EncodingType.ANSICodePage => s.Default,
        EncodingType.UTF8 => Encoding.Default,
        EncodingType.UTF8WithBOM => Encoding.UTF8,
        _ => OperatingSystem.IsWindows() ? Encoding.UTF8 : Encoding.Default,
    };

    static Dictionary<string, string> ReadHostsAllLines(StreamReader? fileReader)
    {
        Dictionary<string, string> dict = new();
        if (fileReader == null) return dict;
        int index = 0;
        static bool Contains(Dictionary<string, string> d, string v) => d.ContainsKey(v);
        while (true)
        {
            index++;
            var line = fileReader.ReadLine();
            if (line == null) break;
            if (string.IsNullOrWhiteSpace(line)) continue;
            var is_effective_value_v2 = HandleLineV2(Contains, index, dict, line, out var array);
            if (is_effective_value_v2 == HandleLineResult.Duplicate)
            {
                dict[array[1]] = array[0];
            }
            else
            {
                var is_effective_value = Convert(is_effective_value_v2);
                if (!is_effective_value.HasValue || !is_effective_value.Value) continue;
                dict.Add(array[1], array[0]);
            }
        }
        return dict;
    }

    public OperationResult<List<(string ip, string domain)>> ReadHostsAllLines()
    {
        lock (lockObj)
        {
            static IEnumerable<(string ip, string domain)> ReadHostsAllLines_(StreamReader? fileReader)
            {
                var value = ReadHostsAllLines(fileReader);
                return value.Select(x => (x.Value, x.Key));
            }
            OperationResult<List<(string ip, string domain)>> result;
            if (!TryOperation(out var errmsg, out var fileInfo, out var _))
            {
                result = new(OperationResultType.Error, errmsg);
                return result;
            }
            try
            {
                var result_read = TryReadHosts(() => fileInfo.OpenText(GetEncoding()), nameof(HandleHosts));
                if (result_read.ResultType != OperationResultType.Success)
                {
                    return result = new(result_read.ResultType, result_read.Message);
                }
                using var fileReader = result_read.AppendData;
                result = new()
                {
                    AppendData = new(ReadHostsAllLines_(fileReader)),
                    ResultType = OperationResultType.Success,
                    Message = AppResources.Hosts_ReadSuccess,
                };
            }
            catch (Exception ex)
            {
                Log.Error(TAG, ex, "ReadHostsAllLines catch.");
                result = new(OperationResultType.Error, ex.GetAllMessage());
            }
            return result;
        }
    }

    public IOperationResult<Dictionary<string, string>> ReadHostsAllLinesV2()
    {
        lock (lockObj)
        {
            OperationResult<Dictionary<string, string>> result;
            if (!TryOperation(out var errmsg, out var fileInfo, out var _))
            {
                result = new(OperationResultType.Error, errmsg);
                return result;
            }
            try
            {
                var result_read = TryReadHosts(() => fileInfo.OpenText(GetEncoding()), nameof(HandleHosts));
                if (result_read.ResultType != OperationResultType.Success)
                {
                    return result = new(result_read.ResultType, result_read.Message);
                }
                using var fileReader = result_read.AppendData;
                result = new()
                {
                    AppendData = ReadHostsAllLines(fileReader),
                    ResultType = OperationResultType.Success,
                    Message = AppResources.Hosts_ReadSuccess,
                };
            }
            catch (Exception ex)
            {
                Log.Error(TAG, ex, "ReadHostsAllLinesV2 catch.");
                result = new(OperationResultType.Error, ex.GetAllMessage());
            }
            return result;
        }
    }

    static OperationResult GetOperationResultByIpcResult(OperationResult? result)
    {
        if (result == null)
            return new OperationResult
            {
                ResultType = OperationResultType.Error,
                Message = "Ipc call error",
            };
        return result;
    }

    public async Task<OperationResult> UpdateHosts(string ip, string domain)
    {
        var privilegedThis = await GetPrivilegedThisAsync();
        if (privilegedThis != null)
        {
            var r = await privilegedThis.UpdateHosts(ip, domain);
            return GetOperationResultByIpcResult(r);
        }
        var dict = new Dictionary<string, string>
            {
                { domain, ip },
            };
        var r2 = await UpdateHosts(dict);
        return r2;
    }

    public async Task<OperationResult> UpdateHosts(IEnumerable<(string ip, string domain)> hosts)
    {
        var privilegedThis = await GetPrivilegedThisAsync();
        if (privilegedThis != null)
        {
            var r = await privilegedThis.UpdateHosts(hosts);
            return GetOperationResultByIpcResult(r);
        }
        
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Net\HostsFileServiceImpl.cs
WINDOWS
WINDOWS
WINDOWS
WINDOWS
WINDOWS
WINDOWS
WINDOWS
WINDOWS
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Linux\LinuxClientHttpPlatformHelperServiceImpl.cs
/ ReSharper disable once CheckNamespace
namespace BD.WTTS.Services.Implementation;

sealed class LinuxClientHttpPlatformHelperServiceImpl : ClientHttpPlatformHelperServiceImpl
{
    const string mUserAgent =
        "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/" +
        AppleWebKitCompatVersion +
        " (KHTML, like Gecko) Chrome/" +
        ChromiumVersion + " Safari/" +
        AppleWebKitCompatVersion;

    public override string UserAgent => mUserAgent;
}
#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Linux\LinuxClientHttpPlatformHelperServiceImpl.cs
LINUX
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Linux\LinuxPlatformServiceImpl.Certificate.cs
/退出码 404 500 被使用
                var shellStr = $"CERT_NAME=\"{CertificateConstants.CertificateName}\"; CERT_RESULT=$(certutil -L -d $HOME/.pki/nssdb | grep \"$CERT_NAME\"); if [ -n \"$CERT_RESULT\" ]; then echo \"证书 '$CERT_NAME' 存在。\"; exit 200; else echo \"证书 '$CERT_NAME' 不存在。\"; exit 10; fi";
                var p = Process.Start(Process2.BinBash, new string[] { "-c", shellStr });
                p.WaitForExit();
                return p.ExitCode == 200;
            }
            catch (Exception e)
            {
                Toast.Show(ToastIcon.Error, $"检测证书安装错误:{e}");
                return false;
            }
        }

        public bool? TrustRootCertificateAsync(string cerPath)
        {
            
/ 使用  Certutil  NSS 工具 添加到 $HOME/.pki/nssdb Chrome 信任此储存区
            Process.Start(Process2.BinBash, new string[] {
                        "-c",
                        $"{Certutil} -A -d $HOME/.pki/nssdb -n \"{CertificateConstants.CertificateName}\" -t C,, -i \"{cerPath}\""
                    }).WaitForExit();
            return RunRootCommand(PkexecPath, new string[] { GetAppHostPath(), "linux", "-ceri", CertificateConstants.AppDataDirectory }) == 0;
        }

        public void RemoveCertificate(byte[] certificate2)
        {
            
/ 使用  Certutil  NSS 工具 从 $HOME/.pki/nssdb 中删除证书
            Process.Start(Process2.BinBash, new string[] {
                        "-c",
                        $"{Certutil} -D -d $HOME/.pki/nssdb -n \"{CertificateConstants.CertificateName}\""
                    }).WaitForExit();
            RunRootCommand(PkexecPath, new string[] { GetAppHostPath(), "linux", "-cerd", CertificateConstants.AppDataDirectory });
        }

        public static int RunRootCommand(string path, string[] args)
        {
            var psi = new ProcessStartInfo
            {
                FileName = path,
                UseShellExecute = false,
                CreateNoWindow = false
            };
            args.ForEach(psi.ArgumentList.Add);
            DotNetRuntimeHelper.AddEnvironment(psi);
            var p = Process.Start(psi);
            p.WaitForExit();
            return p.ExitCode;
        }

        
/}

        public static bool? TrustRootCertificateCore(string cerPath)
        {
            if (!File.Exists(cerPath))
                return false;
            try
            {
                var path = GetCertStore();
                var destCertFilePath = Path.Combine(path.CaCertStorePath, CertificateConstants.CerFileName);
                if (File.Exists(destCertFilePath) && File.ReadAllBytes(cerPath).SequenceEqual(File.ReadAllBytes(destCertFilePath)))
                {
                    return true;
                }
                var sslCertFilePath = Path.Combine("/etc/ssl/certs", CertificateConstants.CerFileName);
                if (!Directory.Exists(sslCertFilePath))
                    File.Copy(cerPath, sslCertFilePath, overwrite: true);
                if (!Directory.Exists(path.CaCertStorePath))
                    return null;
                File.Copy(cerPath, destCertFilePath, overwrite: true);
                
/ 如果存在 /bin/trust 则直接用该命令执行
                if (File.Exists(TrustPath))
                {
                    Process.Start(TrustPath, new string[] {
                        "anchor",
                        "--store",
                        cerPath
                    }).WaitForExit();
                }
                return true;
            }
            catch (Exception e)
            {
                Toast.Show(ToastIcon.Error, $"安装证书错误:{e}");
                return false;
            }
        }

        public static void RemoveCertificate(string cerPath)
        {
            
/ 不存在证书则直接跳过
            if (!File.Exists(cerPath))
                return;
            try
            {
                var path = GetCertStore();
                var destCertFilePath = Path.Combine(path.CaCertStorePath, CertificateConstants.CerFileName);
                if (File.Exists(destCertFilePath) && File.ReadAllBytes(cerPath).SequenceEqual(File.ReadAllBytes(destCertFilePath)))
                {
                    File.Delete(destCertFilePath);
                }
                var sslCertFilePath = Path.Combine("/etc/ssl/certs", CertificateConstants.CerFileName);
                if (File.Exists(sslCertFilePath) && File.ReadAllBytes(cerPath).SequenceEqual(File.ReadAllBytes(sslCertFilePath)))
                {
                    File.Delete(sslCertFilePath);
                }

                
/ 如果存在 /bin/trust 则直接用该命令执行
                if (File.Exists(TrustPath))
                {
                    Process.Start(TrustPath, new string[] {
                        "anchor",
                        "--remove",
                        cerPath
                    }).WaitForExit();
                }
                return;
            }
            catch (Exception e)
            {
                Toast.Show(ToastIcon.Error, $"删除证书错误:{e}");
                return;
            }
        }

        public static (string CaCertUpdatePath, string CaCertStorePath) GetCertStore()
        {
            if (File.Exists(DebianCaCertUpdatePath))
            {
                return (DebianCaCertUpdatePath, DebianCaCertStorePath);
            }
            else
            {
                return (RedHatCaCertUpdatePath, RedHatCaCertStorePath);
            }
        }

        
/ </summary>
        const string Certutil = "certutil";

        const string PkexecPath = "pkexec";

        #region trust
        const string TrustPath = "/usr/bin/trust";
        #endregion

        #region Debian
        const string DebianCaCertUpdatePath = "/usr/sbin/update-ca-certificates";

        const string DebianCaCertStorePath = "/usr/local/share/ca-certificates";

        #endregion

        #region RedHat
        const string RedHatCaCertUpdatePath = "/usr/bin/update-ca-trust";

        const string RedHatCaCertStorePath = "/etc/pki/ca-trust/source/anchors";
        #endregion
    }
}

#endif

发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Linux\LinuxPlatformServiceImpl.Certificate.cs
LINUX
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Linux\LinuxPlatformServiceImpl.cs
LINUX
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Linux\LinuxPlatformServiceImpl.Explorer.cs
LINUX
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Linux\LinuxPlatformServiceImpl.Font.cs
/    fontWeightValue = ExtraBold;
        else /*if (fontWeightValue >= 950)*/
            fontWeightValue = Black;

        var culture = ResourceService.Culture;
        if (culture.IsMatch(AssemblyInfo.CultureName_SimplifiedChinese))
        {
            return fontWeightValue switch
            {
                Thin => "Noto Sans CJK SC Thin",
                ExtraLight => "Noto Sans CJK SC DemiLight",
                Light => "Noto Sans CJK SC Light",
                Medium => "Noto Sans CJK SC Medium",
                Black => "Noto Sans CJK SC Black",
                _ or Normal => "Noto Sans CJK SC",
            };
        }
        else if (culture.IsMatch("zh-HK"))
        {
            return fontWeightValue switch
            {
                Thin => "Noto Sans CJK HK Thin",
                ExtraLight => "Noto Sans CJK HK DemiLight",
                Light => "Noto Sans CJK HK Light",
                Medium => "Noto Sans CJK HK Medium",
                Black => "Noto Sans CJK HK Black",
                _ or Normal => "Noto Sans CJK HK",
            };
        }
        else if (culture.IsMatch(AssemblyInfo.CultureName_TraditionalChinese))
        {
            return fontWeightValue switch
            {
                Thin => "Noto Sans CJK TC Thin",
                ExtraLight => "Noto Sans CJK TC DemiLight",
                Light => "Noto Sans CJK TC Light",
                Medium => "Noto Sans CJK TC Medium",
                Black => "Noto Sans CJK TC Black",
                _ or Normal => "Noto Sans CJK TC",
            };
        }
        else if (culture.IsMatch(AssemblyInfo.CultureName_Japanese))
        {
            return fontWeightValue switch
            {
                Thin => "Noto Sans CJK JP Thin",
                ExtraLight => "Noto Sans CJK JP DemiLight",
                Light => "Noto Sans CJK JP Light",
                Medium => "Noto Sans CJK JP Medium",
                Black => "Noto Sans CJK JP Black",
                _ or Normal => "Noto Sans CJK JP",
            };
        }
        else if (culture.IsMatch(AssemblyInfo.CultureName_Korean))
        {
            return fontWeightValue switch
            {
                Thin => "Noto Sans CJK KR Thin",
                ExtraLight => "Noto Sans CJK KR DemiLight",
                Light => "Noto Sans CJK KR Light",
                Medium => "Noto Sans CJK KR Medium",
                Black => "Noto Sans CJK KR Black",
                _ or Normal => "Noto Sans CJK KR",
            };
        }
        return IPlatformService.DefaultGetDefaultFontFamily();
    }
}
#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Linux\LinuxPlatformServiceImpl.Font.cs
LINUX
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Linux\LinuxPlatformServiceImpl.MachineUniqueIdentifier.cs
/ ReSharper disable once CheckNamespace
namespace BD.WTTS.Services.Implementation;

partial class LinuxPlatformServiceImpl
{
    static string GetMachineSecretKey()
    {
        const string filePath = $"/etc/machine-id";
        return File.ReadAllText(filePath);
    }

    static readonly Lazy<(byte[] key, byte[] iv)> mMachineSecretKey =
        IPlatformService.GetMachineSecretKey(GetMachineSecretKey);

    public (byte[] key, byte[] iv) MachineSecretKey => mMachineSecretKey.Value;
}
#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Linux\LinuxPlatformServiceImpl.MachineUniqueIdentifier.cs
LINUX
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Linux\LinuxPlatformServiceImpl.Net.Hosts.cs
LINUX
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Linux\LinuxPlatformServiceImpl.RunShell.cs
LINUX
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Linux\LinuxPlatformServiceImpl.SystemBoot.cs
/ ReSharper disable once CheckNamespace
namespace BD.WTTS.Services.Implementation;

partial class LinuxPlatformServiceImpl
{
    async void IPlatformService.SystemShutdown(int waitSecond)
    {
        await Task.Delay(waitSecond);
        RunShell(nameof(IPlatformService.SystemShutdown),
            $"echo \"{SystemUserPassword}\" | sudo shutdown -h now");
    }

    async void IPlatformService.SystemSleep(int waitSecond)
    {
        await Task.Delay(waitSecond);
        RunShell(nameof(IPlatformService.SystemSleep),
            $"echo \"{SystemUserPassword}\" | sudo sh -c \" echo mem > /sys/pwoer/state\"");
    }

    async void IPlatformService.SystemHibernate(int waitSecond)
    {
        await Task.Delay(waitSecond);
        RunShell(nameof(IPlatformService.SystemHibernate),
            $"echo \"{SystemUserPassword}\" | sudo sh -c \" echo disk > /sys/pwoer/state\"");
    }

    static string RunShell(string shellCallName, string shell)
    {
        try
        {
            using var p = new Process();
            p.StartInfo.FileName = Process2.BinBash;
            p.StartInfo.Arguments = "";
            p.StartInfo.RedirectStandardOutput = true;
            p.StartInfo.RedirectStandardInput = true;
            p.StartInfo.UseShellExecute = false;
            p.Start();
            p.StandardInput.WriteLine(shell);
            
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Linux\LinuxPlatformServiceImpl.SystemBoot.cs
LINUX
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Linux\LinuxPlatformServiceImpl.SystemProxy.cs
LINUX
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Linux\LinuxPlatformServiceImpl.TextReader.cs
LINUX
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Linux\LinuxPlatformServiceImpl.Theme.cs
LINUX
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\MacCatalyst\MacCatalystClientHttpPlatformHelperServiceImpl.cs
/ ReSharper disable once CheckNamespace
namespace BD.WTTS.Services.Implementation;

sealed class MacCatalystClientHttpPlatformHelperServiceImpl : ClientHttpPlatformHelperServiceImpl
{
    static readonly Lazy<string> mUserAgent = new(() =>
    {
        var v = Environment.OSVersion.Version;
#if IOS || MACCATALYST
        const string ios = "(iPhone; CPU iPhone OS {0}_{1}_{2} like Mac OS X)";
#endif
#if MACOS || MACCATALYST
        const string macos = "(Macintosh; Intel Mac OS X; {0}_{1}_{2})";
#endif
#if !MACCATALYST
        const
#endif
        string value =
        "Mozilla/5.0 " +
#if MACOS
        macos
#elif IOS
        ios
#else
        (OperatingSystem.IsMacOS() ? macos : ios)
#endif
        + " AppleWebKit/" +
        AppleWebKitCompatVersion +
        " (KHTML, like Gecko) Chrome/" +
        ChromiumVersion +
        " Safari/" +
        AppleWebKitCompatVersion;
        return string.Format(value, v.Major, v.Minor, v.Build);
    });

    public override string UserAgent => mUserAgent.Value;
}
#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\MacCatalyst\MacCatalystClientHttpPlatformHelperServiceImpl.cs
MACOS
IOS
MACOS
MACOS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\MacCatalyst\MacCatalystNotificationServiceImpl.cs
/docs.microsoft.com/zh-cn/xamarin/xamarin-forms/app-fundamentals/local-notifications#create-the-ios-interface-implementation

/github.com/davidortinau/WeatherTwentyOne/blob/main/src/WeatherTwentyOne/Platforms/MacCatalyst/NotificationService.cs

/docs.microsoft.com/en-us/dotnet/api/usernotifications.unusernotificationcenter?view=xamarin-ios-sdk-12


/ <inheritdoc cref="INotificationService"/>
sealed class MacCatalystNotificationServiceImpl : INotificationService
{
    const string TAG = "MacCatalystNotificationS";

    void INotificationService.Cancel(NotificationType notificationType)
    {
        UNUserNotificationCenter.Current.RemoveDeliveredNotifications(new[] { notificationType.ToString() });
    }

    void INotificationService.CancelAll()
    {
        UNUserNotificationCenter.Current.RemoveAllDeliveredNotifications();
    }

    void INotificationService.Notify(string text, NotificationType notificationType, bool autoCancel, string? title, Entrance entrance, string? requestUri)
    {
        title ??= INotificationService.DefaultTitle;
        UNUserNotificationCenter.Current.RequestAuthorization(UNAuthorizationOptions.Alert, (approved, err) =>
        {
            if (!approved)
                return;

            var content = new UNMutableNotificationContent
            {
                Title = title,
                Body = text,
            };

            var trigger = UNTimeIntervalNotificationTrigger.CreateTrigger(0.25, false);
            var request = UNNotificationRequest.FromIdentifier(notificationType.ToString(), content, trigger);
            UNUserNotificationCenter.Current.AddNotificationRequest(request, (err) =>
            {
                if (err != null)
                {
                    Log.Error(TAG, $"Failed to schedule notification: {err}");
                }
            });
        });
    }
}
#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\MacCatalyst\MacCatalystNotificationServiceImpl.cs
MACOS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\MacCatalyst\MacCatalystPlatformServiceImpl.Certificate.cs
/ ReSharper disable once CheckNamespace
namespace BD.WTTS.Services.Implementation;

partial class MacCatalystPlatformServiceImpl
{
    const string SecurityPath = "/usr/bin/security";

    internal static bool IsCertificateInstalledCore(X509CertificatePackable certificate2)
    {
        
/var script = $"security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain \"{filePath}\"";
        
/路径不需要包裹 参数传入不需要像控制台包裹
        var code = RunRootCommand(SecurityPath, new string[] {
                   "add-trusted-cert",
                   "-d",
                   "-r",
                   "trustRoot",
                   "-k",
                   "/Library/Keychains/System.keychain",
                   filePath
                   });
        ShowRootCommandError(code, "安装证书：{0}");
        return code == 0;
    }

    
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\MacCatalyst\MacCatalystPlatformServiceImpl.Certificate.cs
MACOS
DEBUG
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\MacCatalyst\MacCatalystPlatformServiceImpl.cs
MACOS
MACCATALYST
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\MacCatalyst\MacCatalystPlatformServiceImpl.Explorer.cs
MACOS
MACOS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\MacCatalyst\MacCatalystPlatformServiceImpl.Font.cs
/support.apple.com/zh-cn/HT213266

        var culture = ResourceService.Culture;
        if (culture.IsMatch(AssemblyInfo.CultureName_SimplifiedChinese))
        {
            return "PingFang SC";
        }
        else if (culture.IsMatch("zh-HK"))
        {
            return "PingFang HK";
        }
        else if (culture.IsMatch(AssemblyInfo.CultureName_TraditionalChinese))
        {
            return "PingFang TC";
        }
        return IPlatformService.DefaultGetDefaultFontFamily();
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\MacCatalyst\MacCatalystPlatformServiceImpl.MachineUniqueIdentifier.cs
/blog.csdn.net/lipingqingqing/article/details/8843606
    
/forums.xamarin.com/discussion/54210/iokit-framework
    
/gist.github.com/chamons/82ab06f5e83d2cb10193

    [LibraryImport("/System/Library/Frameworks/IOKit.framework/IOKit")]
    private static partial uint IOServiceGetMatchingService(uint masterPort, IntPtr matching);

    [DllImport("/System/Library/Frameworks/IOKit.framework/IOKit")]
    static extern IntPtr IOServiceMatching(string s);

    [LibraryImport("/System/Library/Frameworks/IOKit.framework/IOKit")]
    private static partial IntPtr IORegistryEntryCreateCFProperty(uint entry, IntPtr key, IntPtr allocator, uint options);

    [LibraryImport("/System/Library/Frameworks/IOKit.framework/IOKit")]
    private static partial int IOObjectRelease(uint o);

    static string GetIOPlatformExpertDevice(string keyName)
    {
        var value = string.Empty;
        var platformExpert = IOServiceGetMatchingService(0, IOServiceMatching("IOPlatformExpertDevice"));
        if (platformExpert != 0)
        {
            var key = (NSString)keyName;
            var valueIntPtr = IORegistryEntryCreateCFProperty(platformExpert, key.Handle, IntPtr.Zero, 0);
            if (valueIntPtr != IntPtr.Zero)
            {
#pragma warning disable CS0618 
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\MacCatalyst\MacCatalystPlatformServiceImpl.MachineUniqueIdentifier.cs
MACOS
DEBUG
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\MacCatalyst\MacCatalystPlatformServiceImpl.RunShell.cs
MACOS
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\MacCatalyst\MacCatalystPlatformServiceImpl.SystemBoot.cs
MACOS
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\MacCatalyst\MacCatalystPlatformServiceImpl.SystemProxy.cs
MACOS
MACOS
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\MacCatalyst\MacCatalystPlatformServiceImpl.TextReader.cs
MACOS
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\MacCatalyst\MacCatalystPlatformServiceImpl.Theme.cs
MACOS
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\MacCatalyst\MacCatalystPlatformServiceImpl.XPC.cs
MACOS
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\ScheduledTaskServiceImpl.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\ScheduledTaskServiceImpl.PowerShell.cs
/github.com/PowerShell/PowerShell/issues/13540
    
/schemas.microsoft.com/windows/2004/02/mit/task\"><!-- {comment} --><RegistrationInfo><Description>{description}</Description></RegistrationInfo><Triggers><LogonTrigger><Enabled>true</Enabled><UserId>{userName}</UserId></LogonTrigger></Triggers><Principals><Principal id=\"Author\"><UserId>{userId}</UserId><LogonType>InteractiveToken</LogonType><RunLevel>{(isPrivileged ? "HighestAvailable" : "LeastPrivilege")}</RunLevel></Principal></Principals><Settings><MultipleInstancesPolicy>IgnoreNew</MultipleInstancesPolicy><DisallowStartIfOnBatteries>false</DisallowStartIfOnBatteries><StopIfGoingOnBatteries>false</StopIfGoingOnBatteries><AllowHardTerminate>false</AllowHardTerminate><StartWhenAvailable>false</StartWhenAvailable><RunOnlyIfNetworkAvailable>false</RunOnlyIfNetworkAvailable><IdleSettings><Duration>PT10M</Duration><WaitTimeout>PT1H</WaitTimeout><StopOnIdleEnd>true</StopOnIdleEnd><RestartOnIdle>false</RestartOnIdle></IdleSettings><AllowStartOnDemand>true</AllowStartOnDemand><Enabled>true</Enabled><Hidden>false</Hidden><RunOnlyIfIdle>false</RunOnlyIfIdle><WakeToRun>false</WakeToRun><ExecutionTimeLimit>PT0S</ExecutionTimeLimit><Priority>5</Priority></Settings><Actions Context=\"Author\"><Exec><Command>{programName}</Command><Arguments>{arguments}</Arguments><WorkingDirectory>{workingDirectory}</WorkingDirectory></Exec></Actions></Task>";
        return xml;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static async Task RegisterScheduledTask(string taskName, string xml)
    {
        taskName = Escape(taskName);
        xml = Escape(xml);
        await RunPowerShellSinglePipeAsync($"Register-ScheduledTask -Force -TaskName '{taskName}' -Xml '{xml}';exit");
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static async Task UnregisterScheduledTask(IEnumerable<string>? taskNames)
    {
        if (!taskNames.Any_Nullable()) return;

        StringBuilder builder = new();
        foreach (var taskName in taskNames)
        {
            var taskName_ = Escape(taskName);
            builder.Append($"Unregister-ScheduledTask -TaskName '{taskName_}' -Confirm:$false");
            builder.Append(';');
        }
        builder.Append("exit");
        var arguments = builder.ToString();
        await RunPowerShellSinglePipeAsync(arguments);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static Task UnregisterScheduledTask(params string[] taskNames) => UnregisterScheduledTask(taskNames.AsEnumerable());

    
/docs.microsoft.com/en-us/powershell/module/scheduledtasks</para>
    
/ </summary>
    
/ <param name="isAutoStart"></param>
    
/ <param name="name"></param>
    
/ <param name="userId"></param>
    
/ <param name="userName"></param>
    
/ <param name="taskName"></param>
    
/ <param name="programName"></param>
    static async void SetBootAutoStartByPowerShell(bool isAutoStart, string name, string userId, string userName, string taskName, string programName, bool? isPrivilegedProcess = null)
    {
        if (isAutoStart)
        {
            name = SecurityElement.Escape(name);
            userId = SecurityElement.Escape(userId);
            programName = SecurityElement.Escape(programName);
            var workingDirectory = SecurityElement.Escape(AppContext.BaseDirectory);
            var arguments = SecurityElement.Escape(IPlatformService.SystemBootRunArguments);
            if (string.IsNullOrWhiteSpace(userName)) userName = userId;
            else userName = SecurityElement.Escape(userName);
            var description = SecurityElement.Escape(GetDescription(name));
            isPrivilegedProcess ??= WindowsPlatformServiceImpl.IsPrivilegedProcess;
            var xml = GetScheduledTaskXml(nameof(SetBootAutoStartByPowerShell), description, userName, userId, isPrivilegedProcess.Value, programName, arguments, workingDirectory);
            await RegisterScheduledTask(taskName, xml);
        }
        else
        {
            await UnregisterScheduledTask(name, taskName);
        }
    }

    static string Escape(string value) => value.Replace("'", "''");

    static CancellationTokenSource? cts_runPowerShellSinglePipe = null;

    static async Task RunPowerShellSinglePipeAsync(string arguments)
    {
        Process? process = null;
        try
        {
            cts_runPowerShellSinglePipe?.Cancel();
            cts_runPowerShellSinglePipe = new CancellationTokenSource(9000);

            var psi = new ProcessStartInfo
            {
                FileName = "powershell.exe",
                UseShellExecute = false,
                Arguments = "-NoLogo",
                
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\ScheduledTaskServiceImpl.PowerShell.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\Windows10DataProtectionProvider.cs
/github.com/xamarin/Essentials/blob/1.6.1/Xamarin.Essentials/SecureStorage/SecureStorage.uwp.cs
using System.Runtime.InteropServices.WindowsRuntime;
using Windows.Security.Cryptography.DataProtection;
using IDataProtectionProvider = BD.Common.Services.ILocalDataProtectionProvider.IDataProtectionProvider;


/docs.microsoft.com/en-us/uwp/api/windows.security.cryptography.dataprotection.dataprotectionprovider?view=winrt-10240

/ </summary>
sealed class Windows10DataProtectionProvider : IDataProtectionProvider
{
    const string TAG = nameof(Windows10DataProtectionProvider);

    static DataProtectionProvider GetDataProtectionProvider(string? protectionDescriptor = null)
    {
        try
        {
            DataProtectionProvider provider = protectionDescriptor == null ? new() : new(protectionDescriptor);
            return provider;
        }
        catch (Exception e)
        {
            Log.Error(TAG, e,
                "DPP ctor fail, desc: {0}, cl: {1}",
                protectionDescriptor,
                string.Join(' ', Environment.GetCommandLineArgs()));
            throw;
        }
    }

    public async Task<byte[]> ProtectAsync(byte[] data)
    {
        try
        {
            return await ProtectCoreAsync(data);
        }
        catch
        {
            return await ProtectCore2Async(data);
        }
    }

    static async Task<byte[]> ProtectCoreAsync(byte[] data)
    {
        
/appcenter.ms/orgs/BeyondDimension/apps/Steam/crashes/errors/842356268u/overview
        
/appcenter.ms/orgs/BeyondDimension/apps/Steam/crashes/errors/1550045210u/overview
        
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\Windows10DataProtectionProvider.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\Windows10NotificationServiceImpl.cs
/ <inheritdoc cref="INotificationService"/>
sealed class Windows10NotificationServiceImpl : INotificationService, INotificationService.ILifeCycle
{
    bool INotificationService.AreNotificationsEnabled()
    {
        var notifier = ToastNotificationManagerCompat.CreateToastNotifier();
        return notifier.Setting == NotificationSetting.Enabled;
    }

    void INotificationService.Cancel(NotificationType notificationType)
    {
        (var tag, var group) = GetTagAndGroup(notificationType);
        ToastNotificationManagerCompat.History.Remove(tag, group);
    }

    void INotificationService.CancelAll()
    {
        ToastNotificationManagerCompat.History.Clear();
    }

    static (string tag, string group) GetTagAndGroup(NotificationType notificationType)
    {
        var tag = notificationType.ToString();
        var group = notificationType.GetChannel().ToString();
        return (tag, group);
    }

    
/docs.microsoft.com/zh-cn/windows/apps/design/shell/tiles-and-notifications/toast-progress-bar?tabs=builder-syntax

        
/ since last update, or assign 0 for updating regardless of order
                var data = new NotificationData();
                data.Values["progressValue"] = (current / 100f).ToString("0.00");
                BindingText(text(), data);

                
/ Update the existing notification's data by using tag/group
                
/docs.microsoft.com/zh-cn/windows/apps/design/shell/tiles-and-notifications/send-local-toast?tabs=desktop#step-3-handling-activation
        
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\Windows10NotificationServiceImpl.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsClientHttpPlatformHelperServiceImpl.cs
/ ReSharper disable once CheckNamespace
namespace BD.WTTS.Services.Implementation;

internal sealed class WindowsClientHttpPlatformHelperServiceImpl : ClientHttpPlatformHelperServiceImpl
{
    static readonly Lazy<string> mUserAgent = new(() =>
    {
        var v = Environment.OSVersion.Version;
        var value = $"Mozilla/5.0 (Windows NT {v.Major}.{v.Minor}{(Environment.Is64BitOperatingSystem ? "; Win64; x64" : null)}) AppleWebKit/" +
        AppleWebKitCompatVersion +
        " (KHTML, like Gecko) Chrome/" +
        ChromiumVersion +
        " Safari/" +
        AppleWebKitCompatVersion;
        return value;
    });

    protected override bool IsConnected => true;

    public override Task<bool> IsConnectedAsync() => Task.FromResult(true);

    public override string UserAgent => mUserAgent.Value;
}
#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsClientHttpPlatformHelperServiceImpl.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsNotificationServiceImpl.cs
/ <inheritdoc cref="INotificationService"/>
sealed class WindowsNotificationServiceImpl : INotificationService
{
    
/NotifyIcon?.HideBalloonTip();
    }

    static void ShowBalloonTip(string title, string text/*, ToolTipIcon icon*/)
    {
        
发现 Windows 特有的库：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsNotificationServiceImpl.cs
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsNotificationServiceImpl.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsPlatformServiceImpl.Biometric.cs
/docs.microsoft.com/zh-cn/windows/uwp/security/microsoft-passport#3-implementing-windows-hello
        var keyCredentialAvailable = await KeyCredentialManager.IsSupportedAsync();
        return keyCredentialAvailable;
    }
}

#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsPlatformServiceImpl.Biometric.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsPlatformServiceImpl.BypassUAC.cs
/msdn.microsoft.com/en-us/library/windows/desktop/bb530717.aspx
    struct TOKEN_ELEVATION
    {
        public BOOL TokenIsElevated;
    }

    
/ </summary>
    
/ </remarks>
    enum BOOL : int
    {
        FALSE = 0,
        TRUE = 1,
    }

    public bool IsAdministrator =>
#if NET8_0_OR_GREATER
        Environment.IsPrivilegedProcess;

    public static bool IsPrivilegedProcess => Environment.IsPrivilegedProcess;
#else
        _IsAdministrator.Value;

    static readonly Lazy<bool> _IsAdministrator = new(() =>
    {
        var isPrivilegedProcess = IsProcessElevated(Process.GetCurrentProcess());
        return isPrivilegedProcess;
    });

    public static bool IsPrivilegedProcess => _IsAdministrator.Value;
#endif

    
/ </summary>
    
/ <param name="process"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static unsafe bool IsProcessElevated(Process process)
    {
        try
        {
            var handle = process.Handle;

            
/github.com/dotnet/runtime/pull/77355/files#diff-1c6f0e5208d48036e96fcc9c0243d93595f3ce16f2d1a50f51ba604d930ca69dR87
            PInvoke.Kernel32.SafeObjectHandle? token = null;
            try
            {
                if (PInvoke.AdvApi32.OpenProcessToken(handle,
                    PInvoke.AdvApi32.TokenAccessRights.TOKEN_READ,
                    out token))
                {
                    TOKEN_ELEVATION elevation = default;
                    if (PInvoke.AdvApi32.GetTokenInformation(
                        token,
                        PInvoke.AdvApi32.TOKEN_INFORMATION_CLASS.TokenElevation,
                        &elevation,
                        sizeof(TOKEN_ELEVATION),
                        out _))
                    {
                        return elevation.TokenIsElevated != BOOL.FALSE;
                    }
                }
            }
            finally
            {
                token?.Dispose();
            }

            var error = Marshal.GetLastPInvokeError();
            throw new Win32Exception(error);

            
/return principal.IsInRole(WindowsBuiltInRole.Administrator);
        }
        catch (Win32Exception ex)
        {
            /* “process.Handle”引发了类型“System.ComponentModel.Win32Exception”的异常
             * Data: {System.Collections.ListDictionaryInternal}
             * ErrorCode: -2147467259
             * HResult: -2147467259
             * HelpLink: null
             * InnerException: null
             * Message: "拒绝访问。"
             * NativeErrorCode: 5
             * Source: "System.Diagnostics.Process"
             */
            if (ex.NativeErrorCode == 5)
                return true;
        }
        return false;
    }

    
/ </summary>
    
/ <param name="fileName"></param>
    
/ <param name="arguments"></param>
    
/ <returns></returns>
    internal static /*async*/ ValueTask<Process?> StartAsAdministrator(string fileName, string? arguments = null)
    {
#if !DEBUG
        if (IsPrivilegedProcess)
            return ValueTask.FromResult(Process2.Start(fileName, arguments));
#endif
        
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsPlatformServiceImpl.BypassUAC.cs
WINDOWS
NET
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsPlatformServiceImpl.cs
/ 用于 <see cref="IOPath.GetCacheFilePath(string, string, string)"/> 中 dirName，临时文件夹名称，在程序退出时将删除整个文件夹
    
/ </summary>
    internal const string CacheTempDirName = "Temporary";

    public WindowsPlatformServiceImpl()
    {
        
/ </summary>
    static readonly Lazy<string> _windir = new(() =>
    {
        var windir = Environment.GetFolderPath(Environment.SpecialFolder.Windows);
        return windir.ThrowIsNull();
    });

    static readonly Lazy<string> _explorer_exe = new(() => Path.Combine(_windir.Value, "explorer.exe"));

    
/ </summary>
    public static string Explorer => _explorer_exe.Value;

    
/ 带参数(可选/null)启动 %windir%\explorer.exe
    
/ </summary>
    
/ <param name="args"></param>
    
/ <returns></returns>
    public static Process? StartProcessExplorer(string args)
    {
        var process = Process2.Start(Explorer, args, workingDirectory: _windir.Value);
        return process;
    }

    
/ </summary>
    
/ <param name="fileName"></param>
    
/ <param name="arguments"></param>
    
/ <returns></returns>
    public static Process? StartAsInvokerByExplorer(string fileName, string? arguments = null)
    {
        if (string.IsNullOrEmpty(arguments))
            return StartProcessExplorer($"\"{fileName}\"");
        
/ runas /trustlevel:0x20000 没有真正的降权，只是作为具有限制特权，使用 explorer 最好，但不接受参数，可以创建一个临时cmd脚本启动
            
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsPlatformServiceImpl.cs
WINDOWS
DEBUG
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsPlatformServiceImpl.Encoding.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsPlatformServiceImpl.Explorer.cs
/ ReSharper disable once CheckNamespace
namespace BD.WTTS.Services.Implementation;

partial class WindowsPlatformServiceImpl
{
    public void OpenFolderByDirectoryPath(DirectoryInfo info)
        => StartProcessExplorer($"\"{info.FullName}\"");

    public void OpenFolderSelectFilePath(FileInfo info)
        => StartProcessExplorer($"/select,\"{info.FullName}\"");
}
#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsPlatformServiceImpl.Explorer.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsPlatformServiceImpl.Font.cs
/docs.microsoft.com/zh-cn/typography/font-list
        var culture = ResourceService.Culture;
        InstalledFontCollection ifc = new();
        var list = ifc.Families
            .Where(x => x.IsStyleAvailable(FontStyle.Regular))
            .Select(x => new KeyValuePair<string, string>(x.GetName(culture.LCID), x.GetName(1033)))
            .ToList();
        list.Insert(0, IFontManager.Default);
        return list;
    }

    static readonly IReadOnlyDictionary<FontWeight, Lazy<string?>> mDefaultFontFamily = Enum2.GetAll<FontWeight>().Distinct().ToDictionary(k => k, v => new Lazy<string?>(() => GetDefaultFontFamily(v)));

    static string? GetDefaultFontFamily(FontWeight fontWeight)
    {
        
/docs.microsoft.com/en-us/typography/font-list/microsoft-yahei
            
/docs.microsoft.com/en-us/typography/fonts/windows_81_font_list
            FontWeight.Light => "msyhl.ttc",
            FontWeight.Bold => "msyhbd.ttc",
            _ => "msyh.ttc",
        });
        if (File.Exists(msyh_ttc))
        {
            return fontWeight switch
            {
                FontWeight.Light => "Microsoft YaHei UI Light",
                FontWeight.Bold => "Microsoft YaHei UI Bold",
                _ => "Microsoft YaHei UI",
            };
        }
        
/docs.microsoft.com/en-us/typography/fonts/windows_8_font_list
        
/docs.microsoft.com/en-us/typography/fonts/windows_7_font_list
        
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsPlatformServiceImpl.Font.cs
WINDOWS
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsPlatformServiceImpl.IDisposable.cs
WINDOWS
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsPlatformServiceImpl.MachineUniqueIdentifier.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsPlatformServiceImpl.NativeWindow.cs
/ </summary>
    
/ <param name="updateWindowCallback">目标窗口回调</param>
    public void GetMoveMouseDownWindow(Action<NativeWindowModel> updateWindowCallback)
    {
        void MouseHook_OnMouseUp(object? sender, PointD p)
        {
            
/ </summary>
    
/ <param name="window"></param>
    public void BeautifyTheWindow(nint hWnd)
    {
        if (hWnd != nint.Zero)
        {
            var windowStyle = User32.GetWindowLong(hWnd, User32.WindowLongIndexFlags.GWL_STYLE);

            
/ </summary>
    
/ <param name="window"></param>
    public void BorderlessWindow(NativeWindowModel window)
    {
        if (!window.IsHasProcessExits())
        {
            int p1 = User32.GetWindowLong(window.Handle,
                User32.WindowLongIndexFlags.GWL_STYLE);
            p1 &= ~13500416;
            User32.SetWindowLong(window.Handle,
                User32.WindowLongIndexFlags.GWL_STYLE,
                (User32.SetWindowLongFlags)p1);
        }
    }

    public void MaximizeWindow(NativeWindowModel window)
    {
        if (!window.IsHasProcessExits())
        {
            
/ </summary>
    
/ <param name="window"></param>
    public void SetActiveWindow(NativeWindowModel window)
    {
        Interop.User32.SetActiveWindow(window.Handle);
        User32.SetForegroundWindow(window.Handle);
    }

    
/ </summary>
    
/ <param name="dest"></param>
    public void SetWindowPenetrate(IntPtr dest)
    {
        var style = (User32.SetWindowLongFlags)User32.GetWindowLong(dest, User32.WindowLongIndexFlags.GWL_EXSTYLE);
        User32.SetWindowLong(dest,
            User32.WindowLongIndexFlags.GWL_EXSTYLE,
            style | User32.SetWindowLongFlags.WS_EX_TRANSPARENT | User32.SetWindowLongFlags.WS_EX_LAYERED);
        Interop.User32.SetLayeredWindowAttributes(dest, 0, 255, 0x2);
        
/ </summary>
    public IntPtr SetDesktopBackgroundToWindow(IntPtr dest, int width, int height)
    {
        
发现 Windows 特有的库：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsPlatformServiceImpl.NativeWindow.cs
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsPlatformServiceImpl.NativeWindow.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsPlatformServiceImpl.Net.Hosts.cs
/ ReSharper disable once CheckNamespace
namespace BD.WTTS.Services.Implementation;

partial class WindowsPlatformServiceImpl
{
    static readonly Lazy<string> mHostsFilePath = new(() =>
    {
        return Path.Combine(Environment.SystemDirectory, "drivers", "etc", "hosts");
    });

    public string HostsFilePath => mHostsFilePath.Value;

    public void WriteDefaultHostsContent(Stream stream)
    {
        stream.Position = 0;
        stream.Write(
"""
# Copyright (c) 1993-2009 Microsoft Corp.
#
# This is a sample HOSTS file used by Microsoft TCP/IP for Windows.
#
# This file contains the mappings of IP addresses to host names. Each
# entry should be kept on an individual line. The IP address should
# be placed in the first column followed by the corresponding host name.
# The IP address and the host name should be separated by at least one
# space.
#
# Additionally, comments (such as these) may be inserted on individual
# lines or following the machine name denoted by a '#' symbol.
#
# For example:
#
#      102.54.94.97     rhino.acme.com          # source server
#       38.25.63.10     x.acme.com              # x client host

# localhost name resolution is handled within DNS itself.
#	127.0.0.1       localhost
#	::1             localhost

"""u8);
        stream.Flush();
        stream.SetLength(stream.Position);
    }
}
#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsPlatformServiceImpl.Net.Hosts.cs
WINDOWS
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsPlatformServiceImpl.OSVersion.cs
WINDOWS
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsPlatformServiceImpl.Process.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsPlatformServiceImpl.Registry.cs
/ </summary>
    public static string Regedit => _regedit_exe.Value;

    
/ 带参数(可选/null)启动 %windir%\regedit.exe
    
/ </summary>
    
/ <param name="args"></param>
    
/ <returns></returns>
    [Obsolete("use StartProcessRegedit(string path, string content, int millisecondsDelay)", true)]
    public static Process? StartProcessRegedit(string? args)
        => Process2.Start(Regedit, args, workingDirectory: _windir.Value);

    
/ 带参数(可选/null)启动 %windir%\regedit.exe 并等待退出后删除文件
    
/ </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static async Task<byte> StartProcessRegeditAsync(
        string path,
        string contents,
        int millisecondsDelay = 3700,
        string? markKey = null,
        string? markValue = null)
    {
        File.WriteAllText(path, contents, Encoding.UTF8);
        if (IsPrivilegedProcess)
        {
            
/ <inheritdoc cref="StartProcessRegedit(string, string, int)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static async Task StartProcessRegeditCoreAsync(
        string path,
        int millisecondsDelay = 3700)
    {
        var args = $"/s \"{path}\"";
        var p = Process2.Start(Regedit, args, workingDirectory: _windir.Value);
        await IOPath.TryDeleteInDelayAsync(p, path, millisecondsDelay, millisecondsDelay);
    }

    #region Registry2

    
/ <inheritdoc cref="Registry2.ReadRegistryKey(string, RegistryView)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static string? ReadRegistryKeyCore(string encodedPath, RegistryView view = Registry2.DefaultRegistryView)
    {
        var result = Registry2.ReadRegistryKey(encodedPath, view);
        var str = result?.ToString();
        return str;
    }

    
/ <inheritdoc cref="Registry2.ReadRegistryKey(string, RegistryView)"/>
    public string? ReadRegistryKey(string encodedPath, RegistryView view)
    {
        if (IsPrivilegedProcess)
        {
            
/ <inheritdoc cref="Registry2.SetRegistryKey(string, RegistryView, string?)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static bool SetRegistryKeyCore(string encodedPath, RegistryView view, string? value = null)
    {
        var result = Registry2.SetRegistryKey(encodedPath, view, value);
        return result;
    }

    public bool SetRegistryKey(string encodedPath, RegistryView view, string? value)
    {
        var callIpc = !IsPrivilegedProcess;

        if (DesktopBridge.IsRunningAsUwp)
        {
            if (Startup.Instance.IsMainProcess)
            {
                callIpc = true;
            }
        }

        if (!callIpc)
        {
            
/ <inheritdoc cref="Registry2.DeleteRegistryKeyCore(string, RegistryView)"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static bool DeleteRegistryKeyCore(string encodedPath, RegistryView view = Registry2.DefaultRegistryView)
    {
        var result = Registry2.DeleteRegistryKey(encodedPath, view);
        return result;
    }

    public bool DeleteRegistryKey(string encodedPath, RegistryView view)
    {
        var callIpc = !IsPrivilegedProcess;

        if (DesktopBridge.IsRunningAsUwp)
        {
            if (Startup.Instance.IsMainProcess)
            {
                callIpc = true;
            }
        }

        if (!callIpc)
        {
            
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsPlatformServiceImpl.Registry.cs
WINDOWS
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsPlatformServiceImpl.Rundll32.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsPlatformServiceImpl.Shortcut.cs
/ </summary>
    
/ <param name="pathLink">快捷方式的保存路径</param>
    
/ <param name="targetPath">快捷方式的目标路径</param>
    
/ <param name="arguments">参数</param>
    
/ <param name="description">快捷键描述</param>
    
/ <param name="hotkey">设置快捷键</param>
    
/ <param name="iconLocation">快捷键方式图标路径</param>
    
/ <param name="workingDirectory">应用程序工作目录</param>
    public static void CreateShortcut(
        string pathLink,
        string targetPath,
        string? arguments = null,
        string? description = null,
        string? hotkey = null,
        string? iconLocation = null,
        string? workingDirectory = null)
    {
        try
        {
            CreateShortcutCore(pathLink, targetPath, arguments, description, hotkey, iconLocation, workingDirectory);
        }
        catch (Exception)
        {
            
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsPlatformServiceImpl.Shortcut.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsPlatformServiceImpl.SystemOnOff.cs
/ </summary>
    const string BootAutoStartTaskId = "BootAutoStartTask";

    public async void SetBootAutoStart(bool isAutoStart, string name)
    {
        if (DesktopBridge.IsRunningAsUwp)
        {
            
/blogs.windows.com/windowsdeveloper/2017/08/01/configure-app-start-log/
            
/blog.csdn.net/lh275985651/article/details/109360162
            
/www.cnblogs.com/wpinfo/p/uwp_auto_startup.html
            
/ </summary>
    async void IPlatformService.SystemLock(int waitSecond)
    {
        await Task.Delay(waitSecond * 1000);
        Process2.Start("rundll32.exe", "user32.dll,LockWorkStation", true);
    }

    
/ </summary>
    
/ <param name="waitSecond">等待秒数</param>
    async void IPlatformService.SystemShutdown(int waitSecond)
    {
        await Task.Delay(waitSecond * 1000);
        Process2.Start("shutdown", "/s /t 0", true);
    }

    
/ </summary>
    
/ <param name="waitSecond">等待秒数</param>
    async void IPlatformService.SystemSleep(int waitSecond)
    {
        await Task.Delay(waitSecond * 1000);
        Vanara.PInvoke.PowrProf.SetSuspendState(false, true, false);
    }

    
/ </summary>
    
/ <param name="waitSecond">等待秒数</param>
    async void IPlatformService.SystemHibernate(int waitSecond)
    {
        await Task.Delay(waitSecond * 1000);
        Vanara.PInvoke.PowrProf.SetSuspendState(true, true, false);
    }

    #endregion
}
#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsPlatformServiceImpl.SystemOnOff.cs
WINDOWS
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsPlatformServiceImpl.SystemProxy.cs
WINDOWS
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsPlatformServiceImpl.TextReader.cs
WINDOWS
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsPlatformServiceImpl.Theme.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsPlatformServiceImpl.WindowsServices.cs
/ </summary>
    
/ <param name="processId">进程 Id，为 <see langword="null"/> 则为当前进程</param>
    
/ <returns>如果进程作为 Windows 服务托管，则为 <see langword="true" />，否则为 <see langword="false" /></returns>
    public static bool IsWindowsService(int? processId = default)
    {
        
/github.com/dotnet/runtime/blob/v7.0.10/src/libraries/Microsoft.Extensions.Hosting.WindowsServices/src/WindowsServiceHelpers.cs#L20
        if (!processId.HasValue)
        {
            processId =
#if NET5_0_OR_GREATER
                Environment.ProcessId;
#else
                Process.GetCurrentProcess().Id;
#endif
        }
        var parent = GetParentProcess(processId.Value);
        if (parent == null)
        {
            return false;
        }
        return string.Equals("services", parent.ProcessName, StringComparison.OrdinalIgnoreCase);
    }

    static unsafe Process? GetParentProcess(int processId)
    {
        
/github.com/dotnet/runtime/blob/v7.0.10/src/libraries/Microsoft.Extensions.Hosting.WindowsServices/src/Internal/Win32.cs#L14

        PInvoke.Kernel32.SafeObjectHandle? snapshotHandle = default;
        try
        {
            
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsPlatformServiceImpl.WindowsServices.cs
WINDOWS
NET
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsPlatformServiceImpl.WindowTopRightButtons.cs
/stackoverflow.com/questions/339620/how-do-i-remove-minimize-and-maximize-from-a-resizable-window-in-wpf
    
/blog.magnusmontin.net/2014/11/30/disabling-or-hiding-the-minimize-maximize-or-close-button-of-a-wpf-window/
    
/straub.as/csharp/wpf/systembuttons.html

    public const int MF_BYCOMMAND = 0x00000000;
    public const int SC_CLOSE = 0xF060;
    public const int SC_MINIMIZE = 0xF020;
    public const int SC_MAXIMIZE = 0xF030;
    
/stackoverflow.com/questions/5114389/how-make-sure-aero-effect-is-enabled
        var value = User32.GetWindowLong(hWnd, User32.WindowLongIndexFlags.GWL_STYLE);
        if (isVisible)
        {
            value |= WS_SYSMENU;
        }
        else
        {
            value &= ~WS_SYSMENU;
        }
        _ = User32.SetWindowLong(hWnd,
            User32.WindowLongIndexFlags.GWL_STYLE,
            (User32.SetWindowLongFlags)value);
    }

    public const int WS_MAXIMIZEBOX = 0x10000;
    public const int WS_MINIMIZEBOX = 0x20000;
    public const int WS_CAPTION = 0x00C00000;
    public const int WS_BORDER = 0x00800000;
    public const int WS_SYSMENU = 0x80000;

    public static void EnableMinimizeButton(IntPtr hWnd)
    {
        _ = User32.SetWindowLong(hWnd, User32.WindowLongIndexFlags.GWL_STYLE, (User32.SetWindowLongFlags)(User32.GetWindowLong(hWnd, User32.WindowLongIndexFlags.GWL_STYLE) | WS_MINIMIZEBOX));
    }

    public static void EnableMaximizeButton(IntPtr hWnd)
    {
        _ = User32.SetWindowLong(hWnd, User32.WindowLongIndexFlags.GWL_STYLE, (User32.SetWindowLongFlags)(User32.GetWindowLong(hWnd, User32.WindowLongIndexFlags.GWL_STYLE) | WS_MAXIMIZEBOX));
    }

    public static void ShowMinimizeAndMaximizeButtons(IntPtr hWnd)
    {
        _ = User32.SetWindowLong(hWnd, User32.WindowLongIndexFlags.GWL_STYLE, (User32.SetWindowLongFlags)(User32.GetWindowLong(hWnd, User32.WindowLongIndexFlags.GWL_STYLE) | WS_MAXIMIZEBOX | WS_MINIMIZEBOX));
    }

    public static void ShowAllButtons(IntPtr hWnd)
    {
        _ = User32.SetWindowLong(hWnd, User32.WindowLongIndexFlags.GWL_STYLE, (User32.SetWindowLongFlags)(User32.GetWindowLong(hWnd, User32.WindowLongIndexFlags.GWL_STYLE) | WS_SYSMENU));
    }

    public static void HideMinimizeAndMaximizeButtons(IntPtr hWnd)
    {
        _ = User32.SetWindowLong(hWnd, User32.WindowLongIndexFlags.GWL_STYLE, (User32.SetWindowLongFlags)(User32.GetWindowLong(hWnd, User32.WindowLongIndexFlags.GWL_STYLE) & ~WS_MAXIMIZEBOX & ~WS_MINIMIZEBOX));
    }

    public static void DisableMinimizeButton(IntPtr hWnd)
    {
        _ = User32.SetWindowLong(hWnd, User32.WindowLongIndexFlags.GWL_STYLE, (User32.SetWindowLongFlags)(User32.GetWindowLong(hWnd, User32.WindowLongIndexFlags.GWL_STYLE) & ~WS_MINIMIZEBOX));
    }

    public static void DisableMaximizeButton(IntPtr hWnd)
    {
        _ = User32.SetWindowLong(hWnd, User32.WindowLongIndexFlags.GWL_STYLE, (User32.SetWindowLongFlags)(User32.GetWindowLong(hWnd, User32.WindowLongIndexFlags.GWL_STYLE) & ~WS_MAXIMIZEBOX));
    }

    public void SetResizeMode(IntPtr hWnd, ResizeMode value)
    {
        switch (value)
        {
            case ResizeMode.NoResize:
                _ = Interop.User32.DeleteMenu(User32.GetSystemMenu(hWnd, false), SC_MAXIMIZE, MF_BYCOMMAND);
                _ = Interop.User32.DeleteMenu(User32.GetSystemMenu(hWnd, false), SC_MINIMIZE, MF_BYCOMMAND);
                HideMinimizeAndMaximizeButtons(hWnd);
                break;
            case ResizeMode.CanMinimize:
                _ = Interop.User32.DeleteMenu(User32.GetSystemMenu(hWnd, false), SC_MAXIMIZE, MF_BYCOMMAND);
                DisableMaximizeButton(hWnd);
                break;
        }
    }
}
#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsPlatformServiceImpl.WindowTopRightButtons.cs
WINDOWS
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\WindowsProtectedData.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\App\WindowsPlatformServiceImpl.App.cs
/ <inheritdoc cref="IPlatformService.CurrentAppIsInstallVersion"/>
    public static bool CurrentAppIsInstallVersion => _CurrentAppIsInstallVersion.Value;

    bool IPlatformService.CurrentAppIsInstallVersion => CurrentAppIsInstallVersion;
}
#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\App\WindowsPlatformServiceImpl.App.cs
WINDOWS
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\Interop\Interop.cs
WINDOWS
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\Interop\Structures\Point.cs
/github.com/dotnet/wpf/blob/v6.0.0-rc.2.21501.7/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Point.cs

using System.Drawing;
using PointInt32 = System.Drawing.Point;


/ </summary>
public partial struct PointD
{
    #region Constructors

    
/ </summary>
    
/ <param name="x">The value for the X coordinate of the new Point</param>
    
/ <param name="y">The value for the Y coordinate of the new Point</param>
    public PointD(double x, double y)
    {
        _x = x;
        _y = y;
    }

    #endregion Constructors

    #region Public Methods

    
/ </summary>
    
/ <param name="offsetX"> The offset in the x dimension </param>
    
/ <param name="offsetY"> The offset in the y dimension </param>
    public void Offset(double offsetX, double offsetY)
    {
        _x += offsetX;
        _y += offsetY;
    }

    
/ </summary>
    
/ </returns>
    
/ <param name="point"> Point - the Point to convert to a Size </param>
    public static explicit operator Size(PointD point)
    {
        return new Size(Convert.ToInt32(Math.Abs(point._x)), Convert.ToInt32(Math.Abs(point._y)));
    }

    public static explicit operator PointInt32(PointD point)
    {
        return new PointInt32(Convert.ToInt32(point._x), Convert.ToInt32(point._y));
    }

    #endregion Public Methods
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Platform\Windows\Interop\Structures\Generated\Point.cs
/github.com/dotnet/wpf/blob/v6.0.0-rc.2.21501.7/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Generated/Point.cs

/ </summary>
    
/ </returns>
    
/ <param name='point1'>The first Point to compare</param>
    
/ <param name='point2'>The second Point to compare</param>
    public static bool operator ==(PointD point1, PointD point2)
    {
        return point1.X == point2.X &&
               point1.Y == point2.Y;
    }

    
/ </summary>
    
/ </returns>
    
/ <param name='point1'>The first Point to compare</param>
    
/ <param name='point2'>The second Point to compare</param>
    public static bool operator !=(PointD point1, PointD point2)
    {
        return !(point1 == point2);
    }

    
/ </summary>
    
/ </returns>
    
/ <param name='point1'>The first Point to compare</param>
    
/ <param name='point2'>The second Point to compare</param>
    public static bool Equals(PointD point1, PointD point2)
    {
        return point1.X.Equals(point2.X) &&
               point1.Y.Equals(point2.Y);
    }

    
/ </summary>
    
/ </returns>
    
/ <param name='o'>The object to compare to "this"</param>
    public override bool Equals(object? o)
    {
        if (o is null or not PointD)
        {
            return false;
        }

        PointD value = (PointD)o;
        return Equals(this, value);
    }

    
/ </summary>
    
/ </returns>
    
/ <param name='value'>The Point to compare to "this"</param>
    public bool Equals(PointD value)
    {
        return Equals(this, value);
    }

    
/ </summary>
    
/ </returns>
    public override int GetHashCode()
    {
        
/ </summary>
    public double X
    {
        get
        {
            return _x;
        }

        set
        {
            _x = value;
        }
    }

    
/ </summary>
    public double Y
    {
        get
        {
            return _y;
        }

        set
        {
            _y = value;
        }
    }

    #endregion Public Properties

    
/ </summary>
    
/ </returns>
    public override string ToString()
    {
        
/ Delegate to the internal method which implements all ToString calls.
        return ConvertToString(null /* format string */, null /* format provider */);
    }

    
/ </summary>
    
/ </returns>
    public string ToString(IFormatProvider provider)
    {
        
/ Delegate to the internal method which implements all ToString calls.
        return ConvertToString(null /* format string */, provider);
    }

    
/ </summary>
    
/ </returns>
    string IFormattable.ToString(string format, IFormatProvider provider)
    {
        
/ </summary>
    
/ </returns>
    internal string ConvertToString(string format, IFormatProvider provider)
    {
        
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Security\EmbeddedAesDataProtectionProvider.cs
/ <inheritdoc cref="EmbeddedAesDataProtectionProviderBase"/>
public class EmbeddedAesDataProtectionProvider : EmbeddedAesDataProtectionProviderBase
{
    const string TAG = nameof(EmbeddedAesDataProtectionProvider);

    protected readonly AppSettings settings;

    public EmbeddedAesDataProtectionProvider(IOptions<AppSettings> options)
    {
        settings = options.Value;
    }

    Aes[]? aes;
    bool isCallGetAes;

    public override Aes[]? Aes
    {
        get
        {
            if (aes != null)
            {
                return aes;
            }
            else if (isCallGetAes)
            {
                return null;
            }
            try
            {
                aes = new[] { settings.Aes };
                return aes;
            }
            catch (IsNotOfficialChannelPackageException e)
            {
                isCallGetAes = true;
                Log.Error(TAG, e, nameof(ApiRspCode.IsNotOfficialChannelPackage));
                return null;
            }
        }
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Security\LocalDataProtectionProvider.cs
/ <inheritdoc cref="ILocalDataProtectionProvider"/>
public class LocalDataProtectionProvider : LocalDataProtectionProviderBase
{
    readonly IPlatformService platformService;

    public LocalDataProtectionProvider(
        IProtectedData protectedData,
        IDataProtectionProvider dataProtectionProvider,
        IPlatformService platformService) : base(protectedData, dataProtectionProvider)
    {
        this.platformService = platformService;
    }

    protected override (byte[] key, byte[] iv) MachineSecretKey => platformService.MachineSecretKey;
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Services.Implementation\Steam\SteamServiceImpl2.cs
WINDOWS
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\UI\Widgets\NotificationServiceImpl.cs
/ <inheritdoc cref="INotificationService"/>
internal sealed class NotificationServiceImpl : INotificationService
{
    void INotificationService.Cancel(NotificationType notificationType)
    {

    }

    void INotificationService.CancelAll()
    {

    }

    void INotificationService.Notify(string text, NotificationType notificationType, bool autoCancel, string? title, Entrance entrance, string? requestUri)
    {

    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Services.Implementation\UI\Widgets\ToastImpl.cs
/ 使用 <see cref="IToastService"/> 实现的 <see cref="IToast"/>

/ </summary>
internal sealed class ToastImpl : ToastBaseImpl
{
    public ToastImpl(IToastIntercept intercept, IMainThreadPlatformService mainThread) : base(intercept, mainThread)
    {
    }

    protected override bool IsMainThread => MainThread2.IsMainThread();

    protected override void BeginInvokeOnMainThread(Action action) => MainThread2.BeginInvokeOnMainThread(action);

    protected override void PlatformShow(ToastIcon icon, string text, int duration)
    {
        
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Settings\GeneralSettings.cs
/ </auto-generated>

/ </summary>
    [MPKey(0), MP2Key(0), JsonPropertyOrder(0)]
    public bool AutoCheckAppUpdate { get; set; } = IGeneralSettings.DefaultAutoCheckAppUpdate;

    
/ </summary>
    [MPKey(1), MP2Key(1), JsonPropertyOrder(1)]
    public UpdateChannelType UpdateChannel { get; set; } = IGeneralSettings.DefaultUpdateChannel;

    
/ </summary>
    [MPKey(2), MP2Key(2), JsonPropertyOrder(2)]
    public bool AutoRunOnStartup { get; set; } = IGeneralSettings.DefaultAutoRunOnStartup;

    
/ </summary>
    [MPKey(3), MP2Key(3), JsonPropertyOrder(3)]
    public bool MinimizeOnStartup { get; set; } = IGeneralSettings.DefaultMinimizeOnStartup;

    
/ </summary>
    [MPKey(4), MP2Key(4), JsonPropertyOrder(4)]
    public bool TrayIcon { get; set; } = IGeneralSettings.DefaultTrayIcon;

    
/ </summary>
    [MPKey(5), MP2Key(5), JsonPropertyOrder(5)]
    public bool MessagePopupNotification { get; set; } = IGeneralSettings.DefaultMessagePopupNotification;

    
/ </summary>
    [MPKey(6), MP2Key(6), JsonPropertyOrder(6)]
    public bool GameListUseLocalCache { get; set; } = IGeneralSettings.DefaultGameListUseLocalCache;

    
/ </summary>
    [MPKey(7), MP2Key(7), JsonPropertyOrder(7)]
    public Dictionary<Platform, string>? TextReaderProvider { get; set; } = IGeneralSettings.DefaultTextReaderProvider;

    
/ </summary>
    [MPKey(8), MP2Key(8), JsonPropertyOrder(8)]
    public EncodingType HostsFileEncodingType { get; set; } = IGeneralSettings.DefaultHostsFileEncodingType;

    
/ </summary>
    [MPKey(9), MP2Key(9), JsonPropertyOrder(9)]
    public bool GPU { get; set; } = IGeneralSettings.DefaultGPU;

    
/ </summary>
    [MPKey(10), MP2Key(10), JsonPropertyOrder(10)]
    public bool NativeOpenGL { get; set; } = IGeneralSettings.DefaultNativeOpenGL;

    
/ 屏幕捕获/允许截图，在一些含有机密的页面上是否允许截图，默认为 <see langword="false"/>
    
/ </summary>
    [MPKey(11), MP2Key(11), JsonPropertyOrder(11)]
    public bool ScreenCapture { get; set; } = IGeneralSettings.DefaultScreenCapture;

    
/ </summary>
    [MPKey(12), MP2Key(12), JsonPropertyOrder(12)]
    public HashSet<string>? DisablePlugins { get; set; } = IGeneralSettings.DefaultDisablePlugins;

    
/ </summary>
    [MPKey(13), MP2Key(13), JsonPropertyOrder(13)]
    public bool PluginSafeMode { get; set; } = IGeneralSettings.DefaultPluginSafeMode;

    
/ </summary>
    [MPKey(14), MP2Key(14), JsonPropertyOrder(14)]
    public DateTimeOffset LastLookNoticeDateTime { get; set; } = IGeneralSettings.DefaultLastLookNoticeDateTime;

    #region 配置应用程序的 Web 代理

    
/ </summary>
    [MPKey(15), MP2Key(15), JsonPropertyOrder(15)]
    public AppWebProxyMode WebProxyMode { get; set; } = IGeneralSettings.DefaultWebProxyMode;

    
/ </summary>
    [MPKey(16), MP2Key(16), JsonPropertyOrder(16)]
    public string? CustomWebProxyModeHost { get; set; } = IGeneralSettings.DefaultCustomWebProxyModeHost;

    
/ </summary>
    [MPKey(17), MP2Key(17), JsonPropertyOrder(17)]
    public int CustomWebProxyModePort { get; set; } = IGeneralSettings.DefaultCustomWebProxyModePort;

    
/ </summary>
    [MPKey(18), MP2Key(18), JsonPropertyOrder(18)]
    public string? CustomWebProxyModeAddress { get; set; } = IGeneralSettings.DefaultCustomWebProxyModeAddress;

    
/ </summary>
    [MPKey(19), MP2Key(19), JsonPropertyOrder(19)]
    public bool CustomWebProxyModeBypassOnLocal { get; set; } = IGeneralSettings.DefaultCustomWebProxyModeBypassOnLocal;

    
/ </summary>
    [MPKey(20), MP2Key(20), JsonPropertyOrder(20)]
    public string? CustomWebProxyModeCredentialUserName { get; set; } = IGeneralSettings.DefaultCustomWebProxyModeCredentialUserName;

    
/ </summary>
    [MPKey(21), MP2Key(21), JsonPropertyOrder(21)]
    public string? CustomWebProxyModeCredentialPassword { get; set; } = IGeneralSettings.DefaultCustomWebProxyModeCredentialPassword;

    
/ </summary>
    [MPKey(22), MP2Key(22), JsonPropertyOrder(22)]
    public string? CustomWebProxyModeCredentialDomain { get; set; } = IGeneralSettings.DefaultCustomWebProxyModeCredentialDomain;

    #endregion

}

public static partial class GeneralSettings
{
    
/ </summary>
    public static SettingsStructProperty<bool, GeneralSettings_> AutoCheckAppUpdate { get; }
        = new(DefaultAutoCheckAppUpdate);

    
/ </summary>
    public static SettingsStructProperty<UpdateChannelType, GeneralSettings_> UpdateChannel { get; }
        = new(DefaultUpdateChannel);

    
/ </summary>
    public static SettingsStructProperty<bool, GeneralSettings_> AutoRunOnStartup { get; }
        = new(DefaultAutoRunOnStartup);

    
/ </summary>
    public static SettingsStructProperty<bool, GeneralSettings_> MinimizeOnStartup { get; }
        = new(DefaultMinimizeOnStartup);

    
/ </summary>
    public static SettingsStructProperty<bool, GeneralSettings_> TrayIcon { get; }
        = new(DefaultTrayIcon);

    
/ </summary>
    public static SettingsStructProperty<bool, GeneralSettings_> MessagePopupNotification { get; }
        = new(DefaultMessagePopupNotification);

    
/ </summary>
    public static SettingsStructProperty<bool, GeneralSettings_> GameListUseLocalCache { get; }
        = new(DefaultGameListUseLocalCache);

    
/ </summary>
    public static SettingsProperty<Platform, string, Dictionary<Platform, string>, GeneralSettings_> TextReaderProvider { get; }
        = new(DefaultTextReaderProvider);

    
/ </summary>
    public static SettingsStructProperty<EncodingType, GeneralSettings_> HostsFileEncodingType { get; }
        = new(DefaultHostsFileEncodingType);

    
/ </summary>
    public static SettingsStructProperty<bool, GeneralSettings_> GPU { get; }
        = new(DefaultGPU);

    
/ </summary>
    public static SettingsStructProperty<bool, GeneralSettings_> NativeOpenGL { get; }
        = new(DefaultNativeOpenGL);

    
/ 屏幕捕获/允许截图，在一些含有机密的页面上是否允许截图，默认为 <see langword="false"/>
    
/ </summary>
    public static SettingsStructProperty<bool, GeneralSettings_> ScreenCapture { get; }
        = new(DefaultScreenCapture);

    
/ </summary>
    public static SettingsProperty<string, HashSet<string>, GeneralSettings_> DisablePlugins { get; }
        = new(DefaultDisablePlugins);

    
/ </summary>
    public static SettingsStructProperty<bool, GeneralSettings_> PluginSafeMode { get; }
        = new(DefaultPluginSafeMode);

    
/ </summary>
    public static SettingsStructProperty<DateTimeOffset, GeneralSettings_> LastLookNoticeDateTime { get; }
        = new(DefaultLastLookNoticeDateTime);

    #region 配置应用程序的 Web 代理

    
/ </summary>
    public static SettingsStructProperty<AppWebProxyMode, GeneralSettings_> WebProxyMode { get; }
        = new(DefaultWebProxyMode);

    
/ </summary>
    public static SettingsProperty<string, GeneralSettings_> CustomWebProxyModeHost { get; }
        = new(DefaultCustomWebProxyModeHost);

    
/ </summary>
    public static SettingsStructProperty<int, GeneralSettings_> CustomWebProxyModePort { get; }
        = new(DefaultCustomWebProxyModePort);

    
/ </summary>
    public static SettingsProperty<string, GeneralSettings_> CustomWebProxyModeAddress { get; }
        = new(DefaultCustomWebProxyModeAddress);

    
/ </summary>
    public static SettingsStructProperty<bool, GeneralSettings_> CustomWebProxyModeBypassOnLocal { get; }
        = new(DefaultCustomWebProxyModeBypassOnLocal);

    
/ </summary>
    public static SettingsProperty<string, GeneralSettings_> CustomWebProxyModeCredentialUserName { get; }
        = new(DefaultCustomWebProxyModeCredentialUserName);

    
/ </summary>
    public static SettingsProperty<string, GeneralSettings_> CustomWebProxyModeCredentialPassword { get; }
        = new(DefaultCustomWebProxyModeCredentialPassword);

    
/ </summary>
    public static SettingsProperty<string, GeneralSettings_> CustomWebProxyModeCredentialDomain { get; }
        = new(DefaultCustomWebProxyModeCredentialDomain);

    #endregion

}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Settings\UISettings.cs
/ </auto-generated>

/ </summary>
    [MPKey(0), MP2Key(0), JsonPropertyOrder(0)]
    public AppTheme Theme { get; set; } = IUISettings.DefaultTheme;

    
/ </summary>
    [MPKey(1), MP2Key(1), JsonPropertyOrder(1)]
    public string? ThemeAccent { get; set; } = IUISettings.DefaultThemeAccent;

    
/ </summary>
    [MPKey(2), MP2Key(2), JsonPropertyOrder(2)]
    public bool UseSystemThemeAccent { get; set; } = IUISettings.DefaultUseSystemThemeAccent;

    #endregion

    
/ </summary>
    [MPKey(3), MP2Key(3), JsonPropertyOrder(3)]
    public string? Language { get; set; } = IUISettings.DefaultLanguage;

    
/ </summary>
    [MPKey(4), MP2Key(4), JsonPropertyOrder(4)]
    public HashSet<MessageBox.DontPromptType>? MessageBoxDontPrompts { get; set; } = IUISettings.DefaultMessageBoxDontPrompts;

    
/ </summary>
    [MPKey(5), MP2Key(5), JsonPropertyOrder(5)]
    public bool IsShowAdvertisement { get; set; } = IUISettings.DefaultIsShowAdvertisement;

    
/ </summary>
    [MPKey(6), MP2Key(6), JsonPropertyOrder(6)]
    public ConcurrentDictionary<string, SizePosition>? WindowSizePositions { get; set; } = IUISettings.DefaultWindowSizePositions;

    
/ </summary>
    [MPKey(7), MP2Key(7), JsonPropertyOrder(7)]
    public string? FontName { get; set; } = IUISettings.DefaultFontName;

    
/ </summary>
    [MPKey(8), MP2Key(8), JsonPropertyOrder(8)]
    public int GameListGridSize { get; set; } = IUISettings.DefaultGameListGridSize;

    
/ </summary>
    [MPKey(9), MP2Key(9), JsonPropertyOrder(9)]
    public bool Fillet { get; set; } = IUISettings.DefaultFillet;

    #region WindowBackground 窗口背景

    
/ </summary>
    [MPKey(10), MP2Key(10), JsonPropertyOrder(10)]
    public double WindowBackgroundOpacity { get; set; } = IUISettings.DefaultWindowBackgroundOpacity;

    
/ </summary>
    [MPKey(11), MP2Key(11), JsonPropertyOrder(11)]
    public WindowBackgroundMaterial WindowBackgroundMaterial { get; set; } = IUISettings.DefaultWindowBackgroundMaterial;

    
/ </summary>
    [MPKey(12), MP2Key(12), JsonPropertyOrder(12)]
    public bool WindowBackgroundDynamic { get; set; } = IUISettings.DefaultWindowBackgroundDynamic;

    
/ </summary>
    [MPKey(13), MP2Key(13), JsonPropertyOrder(13)]
    public bool WindowBackgroundCustomImage { get; set; } = IUISettings.DefaultWindowBackgroundCustomImage;

    
/ </summary>
    [MPKey(14), MP2Key(14), JsonPropertyOrder(14)]
    public string? WindowBackgroundCustomImagePath { get; set; } = IUISettings.DefaultWindowBackgroundCustomImagePath;

    
/ </summary>
    [MPKey(15), MP2Key(15), JsonPropertyOrder(15)]
    public double WindowBackgroundCustomImageOpacity { get; set; } = IUISettings.DefaultWindowBackgroundCustomImageOpacity;

    
/ </summary>
    [MPKey(16), MP2Key(16), JsonPropertyOrder(16)]
    public XamlMediaStretch WindowBackgroundCustomImageStretch { get; set; } = IUISettings.DefaultWindowBackgroundCustomImageStretch;

    #endregion

    
/ </summary>
    [MPKey(17), MP2Key(17), JsonPropertyOrder(17)]
    public HashSet<string>? SortMenuTabs { get; set; } = IUISettings.DefaultSortMenuTabs;

    
/ </summary>
    [MPKey(18), MP2Key(18), JsonPropertyOrder(18)]
    public string? StartDefaultPageName { get; set; } = IUISettings.DefaultStartDefaultPageName;

}

public static partial class UISettings
{
    #region 主题

    
/ </summary>
    public static SettingsStructProperty<AppTheme, UISettings_> Theme { get; }
        = new(DefaultTheme);

    
/ </summary>
    public static SettingsProperty<string, UISettings_> ThemeAccent { get; }
        = new(DefaultThemeAccent);

    
/ </summary>
    public static SettingsStructProperty<bool, UISettings_> UseSystemThemeAccent { get; }
        = new(DefaultUseSystemThemeAccent);

    #endregion

    
/ </summary>
    public static SettingsProperty<string, UISettings_> Language { get; }
        = new(DefaultLanguage);

    
/ </summary>
    public static SettingsProperty<MessageBox.DontPromptType, HashSet<MessageBox.DontPromptType>, UISettings_> MessageBoxDontPrompts { get; }
        = new(DefaultMessageBoxDontPrompts);

    
/ </summary>
    public static SettingsStructProperty<bool, UISettings_> IsShowAdvertisement { get; }
        = new(DefaultIsShowAdvertisement);

    
/ </summary>
    public static SettingsProperty<string, SizePosition, ConcurrentDictionary<string, SizePosition>, UISettings_> WindowSizePositions { get; }
        = new(DefaultWindowSizePositions);

    
/ </summary>
    public static SettingsProperty<string, UISettings_> FontName { get; }
        = new(DefaultFontName);

    
/ </summary>
    public static SettingsStructProperty<int, UISettings_> GameListGridSize { get; }
        = new(DefaultGameListGridSize);

    
/ </summary>
    public static SettingsStructProperty<bool, UISettings_> Fillet { get; }
        = new(DefaultFillet);

    #region WindowBackground 窗口背景

    
/ </summary>
    public static SettingsStructProperty<double, UISettings_> WindowBackgroundOpacity { get; }
        = new(DefaultWindowBackgroundOpacity);

    
/ </summary>
    public static SettingsStructProperty<WindowBackgroundMaterial, UISettings_> WindowBackgroundMaterial { get; }
        = new(DefaultWindowBackgroundMaterial);

    
/ </summary>
    public static SettingsStructProperty<bool, UISettings_> WindowBackgroundDynamic { get; }
        = new(DefaultWindowBackgroundDynamic);

    
/ </summary>
    public static SettingsStructProperty<bool, UISettings_> WindowBackgroundCustomImage { get; }
        = new(DefaultWindowBackgroundCustomImage);

    
/ </summary>
    public static SettingsProperty<string, UISettings_> WindowBackgroundCustomImagePath { get; }
        = new(DefaultWindowBackgroundCustomImagePath);

    
/ </summary>
    public static SettingsStructProperty<double, UISettings_> WindowBackgroundCustomImageOpacity { get; }
        = new(DefaultWindowBackgroundCustomImageOpacity);

    
/ </summary>
    public static SettingsStructProperty<XamlMediaStretch, UISettings_> WindowBackgroundCustomImageStretch { get; }
        = new(DefaultWindowBackgroundCustomImageStretch);

    #endregion

    
/ </summary>
    public static SettingsProperty<string, HashSet<string>, UISettings_> SortMenuTabs { get; }
        = new(DefaultSortMenuTabs);

    
/ </summary>
    public static SettingsProperty<string, UISettings_> StartDefaultPageName { get; }
        = new(DefaultStartDefaultPageName);

}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Settings\Abstractions\IGeneralSettings.cs
/ </auto-generated>

/ </summary>
    bool AutoCheckAppUpdate { get; set; }

    
/ </summary>
    UpdateChannelType UpdateChannel { get; set; }

    
/ </summary>
    bool AutoRunOnStartup { get; set; }

    
/ </summary>
    bool MinimizeOnStartup { get; set; }

    
/ </summary>
    bool TrayIcon { get; set; }

    
/ </summary>
    bool MessagePopupNotification { get; set; }

    
/ </summary>
    bool GameListUseLocalCache { get; set; }

    
/ </summary>
    Dictionary<Platform, string>? TextReaderProvider { get; set; }

    
/ </summary>
    EncodingType HostsFileEncodingType { get; set; }

    
/ </summary>
    bool GPU { get; set; }

    
/ </summary>
    bool NativeOpenGL { get; set; }

    
/ 屏幕捕获/允许截图，在一些含有机密的页面上是否允许截图，默认为 <see langword="false"/>
    
/ </summary>
    bool ScreenCapture { get; set; }

    
/ </summary>
    HashSet<string>? DisablePlugins { get; set; }

    
/ </summary>
    bool PluginSafeMode { get; set; }

    
/ </summary>
    DateTimeOffset LastLookNoticeDateTime { get; set; }

    #region 配置应用程序的 Web 代理

    
/ </summary>
    AppWebProxyMode WebProxyMode { get; set; }

    
/ </summary>
    string? CustomWebProxyModeHost { get; set; }

    
/ </summary>
    int CustomWebProxyModePort { get; set; }

    
/ </summary>
    string? CustomWebProxyModeAddress { get; set; }

    
/ </summary>
    bool CustomWebProxyModeBypassOnLocal { get; set; }

    
/ </summary>
    string? CustomWebProxyModeCredentialUserName { get; set; }

    
/ </summary>
    string? CustomWebProxyModeCredentialPassword { get; set; }

    
/ </summary>
    string? CustomWebProxyModeCredentialDomain { get; set; }

    #endregion

    
/ </summary>
    const bool DefaultAutoCheckAppUpdate = true;

    
/ </summary>
    const UpdateChannelType DefaultUpdateChannel = UpdateChannelType.Auto;

    
/ </summary>
    const bool DefaultAutoRunOnStartup = false;

    
/ </summary>
    const bool DefaultMinimizeOnStartup = false;

    
/ </summary>
    const bool DefaultTrayIcon = true;

    
/ </summary>
    const bool DefaultMessagePopupNotification = true;

    
/ </summary>
    const bool DefaultGameListUseLocalCache = false;

    
/ </summary>
    const Dictionary<Platform, string>? DefaultTextReaderProvider = null;

    
/ </summary>
    const EncodingType DefaultHostsFileEncodingType = EncodingType.Auto;

    
/ </summary>
    const bool DefaultGPU = true;

    
/ </summary>
    const bool DefaultNativeOpenGL = false;

    
/ 屏幕捕获/允许截图，在一些含有机密的页面上是否允许截图，默认为 <see langword="false"/>的默认值
    
/ </summary>
    const bool DefaultScreenCapture = false;

    
/ </summary>
    const HashSet<string>? DefaultDisablePlugins = null;

    
/ </summary>
    const bool DefaultPluginSafeMode = true;

    
/ </summary>
    static readonly DateTimeOffset DefaultLastLookNoticeDateTime = default;

    
/ </summary>
    const AppWebProxyMode DefaultWebProxyMode = default;

    
/ </summary>
    const string DefaultCustomWebProxyModeHost = default;

    
/ </summary>
    const int DefaultCustomWebProxyModePort = default;

    
/ </summary>
    const string DefaultCustomWebProxyModeAddress = default;

    
/ </summary>
    const bool DefaultCustomWebProxyModeBypassOnLocal = default;

    
/ </summary>
    const string DefaultCustomWebProxyModeCredentialUserName = default;

    
/ </summary>
    const string DefaultCustomWebProxyModeCredentialPassword = default;

    
/ </summary>
    const string DefaultCustomWebProxyModeCredentialDomain = default;

}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Settings\Abstractions\IPartialGameAccountSettings.cs
/ <console-tools-generated/>
#pragma warning restore SA1634 
/ </summary>
    ConcurrentDictionary<string, string?>? AccountRemarks { get; set; }

    
/ </summary>
    IReadOnlyCollection<DisableAuthorizedDevice>? DisableAuthorizedDevice { get; set; }

    
/ </summary>
    HashSet<string>? EnablePlatforms { get; set; }

}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Settings\Abstractions\IPartialGameLibrarySettings.cs
/ <console-tools-generated/>
#pragma warning restore SA1634 
/ </summary>
    bool GameInstalledFilter { get; set; }

    
/ </summary>
    bool GameCloudArchiveFilter { get; set; }

    
/ </summary>
    List<SteamAppType>? GameTypeFiltres { get; set; }

    
/ </summary>
    Dictionary<uint, string?>? HideGameList { get; set; }

    
/ </summary>
    Dictionary<uint, string?>? AFKAppList { get; set; }

    
/ </summary>
    bool IsAutoAFKApps { get; set; }

}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Settings\Abstractions\ISteamSettings.cs
/ </auto-generated>

/ </summary>
    string? SteamStratParameter { get; set; }

    
/ </summary>
    string? SteamSkin { get; set; }

#if (WINDOWS || MACCATALYST || MACOS || LINUX) && !(IOS || ANDROID)

    
/ </summary>
    string? SteamProgramPath { get; set; }

    
/ </summary>
    bool IsAutoRunSteam { get; set; }

    
/ </summary>
    bool IsRunSteamMinimized { get; set; }

    
/ </summary>
    bool IsRunSteamNoCheckUpdate { get; set; }

    
/ </summary>
    bool IsRunSteamChina { get; set; }

    
/ </summary>
    bool IsRunSteamVGUI { get; set; }

    
/ </summary>
    bool IsEnableSteamLaunchNotification { get; set; }

    
/ </summary>
    OSExitMode DownloadCompleteSystemEndMode { get; set; }

    
/ </summary>
    bool IsRunSteamAdministrator { get; set; }

#endif

    
/ </summary>
    const string? DefaultSteamStratParameter = null;

    
/ </summary>
    const string? DefaultSteamSkin = null;

    
/ </summary>
    static readonly string? DefaultSteamProgramPath = null;

    
/ </summary>
    const bool DefaultIsAutoRunSteam = false;

    
/ </summary>
    const bool DefaultIsRunSteamMinimized = false;

    
/ </summary>
    const bool DefaultIsRunSteamNoCheckUpdate = false;

    
/ </summary>
    const bool DefaultIsRunSteamChina = false;

    
/ </summary>
    const bool DefaultIsRunSteamVGUI = false;

    
/ </summary>
    const bool DefaultIsEnableSteamLaunchNotification = true;

    
/ </summary>
    const OSExitMode DefaultDownloadCompleteSystemEndMode = OSExitMode.Sleep;

    
/ </summary>
    const bool DefaultIsRunSteamAdministrator = false;

}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Settings\Abstractions\IUISettings.cs
/ </auto-generated>

/ </summary>
    AppTheme Theme { get; set; }

    
/ </summary>
    string? ThemeAccent { get; set; }

    
/ </summary>
    bool UseSystemThemeAccent { get; set; }

    #endregion

    
/ </summary>
    string? Language { get; set; }

    
/ </summary>
    HashSet<MessageBox.DontPromptType>? MessageBoxDontPrompts { get; set; }

    
/ </summary>
    bool IsShowAdvertisement { get; set; }

    
/ </summary>
    ConcurrentDictionary<string, SizePosition>? WindowSizePositions { get; set; }

    
/ </summary>
    string? FontName { get; set; }

    
/ </summary>
    int GameListGridSize { get; set; }

    
/ </summary>
    bool Fillet { get; set; }

    #region WindowBackground 窗口背景

    
/ </summary>
    double WindowBackgroundOpacity { get; set; }

    
/ </summary>
    WindowBackgroundMaterial WindowBackgroundMaterial { get; set; }

    
/ </summary>
    bool WindowBackgroundDynamic { get; set; }

    
/ </summary>
    bool WindowBackgroundCustomImage { get; set; }

    
/ </summary>
    string? WindowBackgroundCustomImagePath { get; set; }

    
/ </summary>
    double WindowBackgroundCustomImageOpacity { get; set; }

    
/ </summary>
    XamlMediaStretch WindowBackgroundCustomImageStretch { get; set; }

    #endregion

    
/ </summary>
    HashSet<string>? SortMenuTabs { get; set; }

    
/ </summary>
    string? StartDefaultPageName { get; set; }

    
/ </summary>
    const AppTheme DefaultTheme = AppTheme.FollowingSystem;

    
/ </summary>
    const string DefaultThemeAccent = "#FF0078D7";

    
/ </summary>
    const bool DefaultUseSystemThemeAccent = true;

    
/ </summary>
    const string? DefaultLanguage = null;

    
/ </summary>
    const HashSet<MessageBox.DontPromptType>? DefaultMessageBoxDontPrompts = null;

    
/ </summary>
    const bool DefaultIsShowAdvertisement = true;

    
/ </summary>
    const ConcurrentDictionary<string, SizePosition>? DefaultWindowSizePositions = null;

    
/ </summary>
    const string? DefaultFontName = null;

    
/ </summary>
    const int DefaultGameListGridSize = 150;

    
/ </summary>
    const bool DefaultFillet = false;

    
/ </summary>
    static readonly double DefaultWindowBackgroundOpacity = OperatingSystem2.IsWindows11AtLeast() ? .0 : .8;

    
/ </summary>
    static readonly WindowBackgroundMaterial DefaultWindowBackgroundMaterial = OperatingSystem2.IsWindows11AtLeast() ? Enums.WindowBackgroundMaterial.Mica : Enums.WindowBackgroundMaterial.AcrylicBlur;

    
/ </summary>
    const bool DefaultWindowBackgroundDynamic = false;

    
/ </summary>
    const bool DefaultWindowBackgroundCustomImage = false;

    
/ </summary>
    const string DefaultWindowBackgroundCustomImagePath = "avares:
/BD.WTTS.Client.Avalonia/UI/Assets/back.png";

    
/ </summary>
    const double DefaultWindowBackgroundCustomImageOpacity = .8;

    
/ </summary>
    const XamlMediaStretch DefaultWindowBackgroundCustomImageStretch = XamlMediaStretch.UniformToFill;

    
/ </summary>
    const HashSet<string>? DefaultSortMenuTabs = null;

    
/ </summary>
    const string? DefaultStartDefaultPageName = null;

}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Settings\Infrastructure\SettingsProperty.cs
/ </summary>

/ <typeparam name="TValue"></typeparam>

/ <typeparam name="TSettings"></typeparam>
public class SettingsProperty<TValue, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicProperties)] TSettings> : SettingsPropertyBase<TValue>, IDisposable, INotifyPropertyChanged
    where TValue : class
    where TSettings : new()
{
    readonly Action<TSettings, TValue?> setter;
    readonly Func<TSettings, TValue?> getter;
    IDisposable? disposable;
    readonly IOptionsMonitor<TSettings> monitor;
    bool disposedValue;

    protected sealed override TValue? ModelValue => getter(monitor.CurrentValue);

    public SettingsProperty(TValue? @default = default, bool autoSave = true, [CallerMemberName] string? propertyName = null)
    {
        var settingsType = typeof(TSettings);
        PropertyName = propertyName.ThrowIsNull();
        AutoSave = autoSave;
        Default = @default;
        ParameterExpression parameter = Expression.Parameter(settingsType, "obj");
        MemberExpression property = Expression.Property(parameter, PropertyName);
        ParameterExpression value = Expression.Parameter(typeof(TValue), "value");
        BinaryExpression assign = Expression.Assign(property, value);
        setter = Expression.Lambda<Action<TSettings, TValue?>>(assign, parameter, value).Compile();
        getter = Expression.Lambda<Func<TSettings, TValue?>>(property, parameter).Compile();
        monitor = Ioc.Get<IOptionsMonitor<TSettings>>();
#if DEBUG
        switch (propertyName)
        {
            case "WindowSizePositions":
                break;
        }
#endif
        this.value = getter(monitor.CurrentValue);
        SetProperties(settingsType, propertyName);
        disposable = monitor.OnChange(OnChange);
    }

    void OnChange(TSettings settings)
    {
        if (!CanOnChange(settings, PropertyName))
            return;

        SetValue(getter(settings), false);
    }

    public override string PropertyName { get; }

    protected virtual TValue? GetActualValue()
    {
        if (typeof(TValue) == typeof(string))
        {
            if (value == default || string.IsNullOrWhiteSpace(value?.ToString()))
                return Default;
            return value;
        }
        else
        {
            return value ?? Default;
        }
    }

    protected virtual void SetModelValue(TValue? value)
    {
        if (typeof(TValue) == typeof(string))
        {
            if (value != default && string.IsNullOrWhiteSpace(value?.ToString()))
                value = default;
        }
        setter(monitor.CurrentValue, value); 
/ </summary>

/ <typeparam name="TValue"></typeparam>

/ <typeparam name="TEnumerable"></typeparam>

/ <typeparam name="TSettings"></typeparam>
public class SettingsProperty<TValue, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] TEnumerable, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicProperties)] TSettings> : SettingsProperty<TEnumerable, TSettings>, ICollection<TValue>
    where TEnumerable : class, ICollection<TValue>, new()
    where TSettings : new()
{
    int ICollection<TValue>.Count => value?.Count ?? 0;

    bool ICollection<TValue>.IsReadOnly => value?.IsReadOnly ?? false;

    public SettingsProperty(TEnumerable? @default = default, bool autoSave = true, [CallerMemberName] string? propertyName = null) : base(@default, autoSave, propertyName)
    {

    }

    protected override bool Equals(TEnumerable? left, TEnumerable? right)
    {
        if (left == null)
        {
            return right == null;
        }
        else if (right == null)
        {
            return left == null;
        }

        if (EqualityComparer<TEnumerable>.Default.Equals(left, right))
        {
            return true;
        }

        return left.SequenceEqual(right);
    }

    static void AddRange(TEnumerable source, IEnumerable<TValue>? items)
    {
        if (items == null) return;

        switch (source)
        {
            case List<TValue> list:
                list.AddRange(items);
                break;
            case IExtendedList<TValue> extendedList:
                extendedList.AddRange(items);
                break;
            default:
                items.ForEach(source.Add);
                break;
        }
    }

    public virtual void Add(TValue item, bool raiseValueChanged = true, bool notSave = false)
    {
        if (value == null)
        {
            value = Activator.CreateInstance<TEnumerable>();
            AddRange(value, Default);
        }
        value.Add(item);
        if (raiseValueChanged)
            RaiseValueChanged(notSave);
    }

    public virtual void AddRange(IEnumerable<TValue> items, bool raiseValueChanged = true, bool notSave = false)
    {
        if (value == null)
        {
            value = Activator.CreateInstance<TEnumerable>();
            AddRange(value, Default);
        }
        AddRange(value, items);
        if (raiseValueChanged)
            RaiseValueChanged(notSave);
    }

    public virtual bool Remove(TValue item, bool raiseValueChanged = true, bool notSave = false)
    {
        bool result;
        if (value == null)
        {
            if (Default.Any_Nullable())
            {
                value = Activator.CreateInstance<TEnumerable>();
                AddRange(value, Default);

                result = value.Remove(item);
                if (raiseValueChanged)
                    RaiseValueChanged(notSave);

                return result;
            }
            return false;
        }

        result = value.Remove(item);
        if (raiseValueChanged)
            RaiseValueChanged(notSave);

        return result;
    }

    public virtual bool Contains(TValue item)
    {
        if (value == null)
        {
            if (Default.Any_Nullable())
            {
                return Default.Contains(item);
            }
            return false;
        }

        return value.Contains(item);
    }

    public virtual void Clear(bool raiseValueChanged = true, bool notSave = false)
    {
        if (value == null)
        {
            value = Activator.CreateInstance<TEnumerable>();
            if (raiseValueChanged)
                RaiseValueChanged(notSave);
            return;
        }

        value = null;
        if (raiseValueChanged)
            RaiseValueChanged(notSave);
    }

    void ICollection<TValue>.Add(TValue item) => Add(item);

    void ICollection<TValue>.Clear() => Clear();

    void ICollection<TValue>.CopyTo(TValue[] array, int arrayIndex)
    {
        if (value == null) return;

        value.CopyTo(array, arrayIndex);
    }

    bool ICollection<TValue>.Remove(TValue item) => Remove(item);

    IEnumerator<TValue> IEnumerable<TValue>.GetEnumerator()
    {
        if (value == null)
            return (IEnumerator<TValue>)Array.Empty<TValue>().GetEnumerator();
        return value.GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        if (value == null)
            return Array.Empty<TValue>().GetEnumerator();
        return value.GetEnumerator();
    }
}


/ </summary>

/ <typeparam name="TKey"></typeparam>

/ <typeparam name="TValue"></typeparam>

/ <typeparam name="TDictionary"></typeparam>

/ <typeparam name="TSettings"></typeparam>
public class SettingsProperty<TKey, TValue,
    [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] TDictionary,
    [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicProperties)] TSettings> : SettingsProperty<KeyValuePair<TKey, TValue>, TDictionary, TSettings>, IDictionary<TKey, TValue>
    where TDictionary : class, IDictionary<TKey, TValue>, new()
    where TSettings : new()
{
    public SettingsProperty(TDictionary? @default = default, bool autoSave = true, [CallerMemberName] string? propertyName = null) : base(@default, autoSave, propertyName)
    {

    }

    TValue IDictionary<TKey, TValue>.this[TKey key]
    {
        get
        {
            if (value == null)
            {
                if (Default != null)
                {
                    if (Default.TryGetValue(key, out var value))
                    {
                        return value;
                    }
                }
                return default!;
            }
            try
            {
                return value[key];
            }
            catch
            {
                return default!;
            }
        }

        set
        {
            if (this.value == null)
            {
                this.value = Activator.CreateInstance<TDictionary>();
                if (Default != null)
                {
                    foreach (var item in Default)
                    {
                        this.value.Add(item.Key, item.Value);
                    }
                }
            }
            this.value.Add(key, value);
        }
    }

    ICollection<TKey> IDictionary<TKey, TValue>.Keys
    {
        get
        {
            if (value == null)
            {
                if (Default != null)
                {
                    return Default.Keys;
                }
                else
                {
                    return Array.Empty<TKey>();
                }
            }
            return value.Keys;
        }
    }

    ICollection<TValue> IDictionary<TKey, TValue>.Values
    {
        get
        {
            if (value == null)
            {
                if (Default != null)
                {
                    return Default.Values;
                }
                else
                {
                    return Array.Empty<TValue>();
                }
            }
            return value.Values;
        }
    }

    public virtual void Add(TKey key, TValue value, bool raiseValueChanged = true, bool notSave = false)
    {
        if (this.value == null)
        {
            this.value = Activator.CreateInstance<TDictionary>();
            if (Default != null)
            {
                foreach (var item in Default)
                {
                    this.value.Add(item.Key, item.Value);
                }
            }
        }
        if (!this.value.TryAdd(key, value))
        {
            this.value[key] = value;
        }

        if (raiseValueChanged)
            RaiseValueChanged(notSave);
    }

    public override void Add(KeyValuePair<TKey, TValue> pair, bool raiseValueChanged = true, bool notSave = false)
    {
        Add(pair.Key, pair.Value, raiseValueChanged, notSave);
    }

    static bool TryAdd(IDictionary<TKey, TValue> dictionary, TKey key, TValue value)
    {
        if (dictionary is ConcurrentDictionary<TKey, TValue> cdict)
        {
            
/github.com/dotnet/runtime/issues/30451
            return cdict.TryAdd(key, value);
        }
        return dictionary.TryAdd(key, value);
    }

    public override void AddRange(IEnumerable<KeyValuePair<TKey, TValue>> items, bool raiseValueChanged = true, bool notSave = false)
    {
        if (value == null)
        {
            value = Activator.CreateInstance<TDictionary>();
            if (Default != null)
            {
                foreach (var item in Default)
                {
                    value.Add(item.Key, item.Value);
                }
            }
        }

        foreach (var item in items)
        {
            try
            {
                if (!TryAdd(value, item.Key, item.Value))
                {
                    value[item.Key] = item.Value;
                }
            }
            catch
            {
                value[item.Key] = item.Value;
            }
        }

        if (raiseValueChanged)
            RaiseValueChanged(notSave);
    }

    public virtual bool ContainsKey(TKey key)
    {
        if (value == null)
        {
            if (Default != null)
            {
                return Default.ContainsKey(key);
            }
            return false;
        }
        return value.ContainsKey(key);
    }

    public virtual bool Remove(TKey key, bool raiseValueChanged = true, bool notSave = false)
    {
        bool result;
        if (value == null)
        {
            if (Default.Any_Nullable())
            {
                value = Activator.CreateInstance<TDictionary>();
                foreach (var item in Default)
                {
                    value.Add(item.Key, item.Value);
                }

                result = value.Remove(key);
                if (raiseValueChanged)
                    RaiseValueChanged(notSave);

                return result;
            }
            return false;
        }

        result = value.Remove(key);
        if (raiseValueChanged)
            RaiseValueChanged(notSave);

        return result;
    }

    public virtual bool TryGetValue(TKey key, out TValue value)
    {
        if (this.value == null)
        {
            if (Default != null)
            {
                return Default.TryGetValue(key, out value!);
            }
            value = default!;
            return false;
        }
        return this.value.TryGetValue(key, out value!);
    }

    void IDictionary<TKey, TValue>.Add(TKey key, TValue value) => Add(key, value);

    bool IDictionary<TKey, TValue>.Remove(TKey key) => Remove(key);

    public virtual TValue GetOrAdd(TKey key, TValue value)
    {
        Add(key, value);
        return value;
    }
}

发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Settings\Infrastructure\SettingsProperty.cs
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Settings\Infrastructure\SettingsStructProperty.cs
/ </summary>

/ <typeparam name="TValue"></typeparam>

/ <typeparam name="TSettings"></typeparam>
public class SettingsStructProperty<TValue, [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicProperties)] TSettings> : SettingsStructPropertyBase<TValue, TSettings>
    where TValue : struct
    where TSettings : new()
{
    public SettingsStructProperty(TValue @default = default, bool autoSave = true, [CallerMemberName] string? propertyName = null) : base(@default, autoSave, propertyName)
    {
    }

    public TValue Value
    {
        get
        {
            var value = ActualValue;
            return value;
            
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Settings\Infrastructure\Abstractions\ISettings.cs
/ </summary>
    
/ <param name="utf8Json"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static TSettings Deserialize(Stream utf8Json)
        => SJsonSerializer.Deserialize(utf8Json, TSettings.JsonTypeInfo) ?? new();

    sealed class OptionsMonitor : IOptionsMonitor<TSettings>, IOptions<TSettings>
    {
        TSettings settings;
        readonly string settingsFileName;
        readonly string settingsFilePath;
        readonly PhysicalFileProvider fileProvider;

        public OptionsMonitor(string settingsFilePath, TSettings? settings = default)
        {
            this.settingsFilePath = settingsFilePath;
            var settingsDirPath = Path.GetDirectoryName(settingsFilePath);
            settingsDirPath.ThrowIsNull();
            this.settings = settings ?? ISettings.Deserialize<TSettings>(settingsFilePath) ?? new();
            fileProvider = new(settingsDirPath);
            settingsFileName = Path.GetFileName(settingsFilePath);
        }

        TSettings IOptionsMonitor<TSettings>.CurrentValue => settings;

        TSettings IOptions<TSettings>.Value => settings;

        TSettings IOptionsMonitor<TSettings>.Get(string? name) => settings;

        TSettings? AllowNullDeserialize()
        {
            try
            {
                var settings = ISettings.Deserialize<TSettings>(settingsFilePath);
                return settings;
            }
            catch
            {
                return default;
            }
        }

        IDisposable? IOptionsMonitor<TSettings>.OnChange(Action<TSettings, string?> listener)
            => ChangeToken.OnChange(() => fileProvider.Watch(settingsFileName), () =>
        {
            var settings_ = AllowNullDeserialize();
            if (settings_ != null)
            {
                
/ </summary>
    
/ <typeparam name="TSettings"></typeparam>
    
/ <param name="settings"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static string Serialize<TSettings>(this TSettings settings) where TSettings : ISettings
        => SJsonSerializer.Serialize(settings, typeof(TSettings), TSettings.JsonSerializerContext);

    
/ </summary>
    
/ <typeparam name="TSettings"></typeparam>
    
/ <param name="utf8Json"></param>
    
/ <param name="settings"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Serialize<TSettings>(this TSettings settings, Stream utf8Json) where TSettings : ISettings
        => SJsonSerializer.Serialize(utf8Json, settings, typeof(TSettings), TSettings.JsonSerializerContext);

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void Save_____<TSettings>(this TSettings settings, Stream utf8Json) where TSettings : ISettings
    {
        utf8Json.Position = 0;
        utf8Json.Write("{\""u8);
        utf8Json.Write(Encoding.UTF8.GetBytes(TSettings.Name));
        utf8Json.Write("\":"u8);
        Serialize(settings, utf8Json);
        utf8Json.Write("}"u8);
        utf8Json.SetLength(utf8Json.Position);
        utf8Json.Flush();
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void TrySave_____<TSettings>(IOptionsMonitor<TSettings> optionsMonitor, string? notRead = null) where TSettings : class, ISettings
    {
        var settings = optionsMonitor.CurrentValue;
        var settingsFilePath = ISettings.GetFilePath(typeof(TSettings), TSettings.Name);

        lock (TSettings.Name)
        {
            var settingsType = typeof(TSettings);
            SettingsPropertyBase.SetSaveStatus(settingsType);

            try
            {
                if (notRead != bool.TrueString) 
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Settings\Infrastructure\Abstractions\ISettings.cs
DEBUG
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Settings\Infrastructure\Abstractions\SettingsPropertyBase.cs
/ </summary>
    public bool AutoSave { get; set; }

    public abstract void RaiseValueChanged(bool notSave = false);

    public abstract void Reset(bool save = true);

    static readonly Dictionary<Type, List<string>> SettingsProperties = new();
    static readonly Dictionary<(Type SettingsType, string PropertyName), bool?> SaveNameStatus = new();

    protected internal static void SetProperties(Type settingsType, string propertyName)
    {
        if (SettingsProperties.TryGetValue(settingsType, out var propertyNames))
            propertyNames.Add(propertyName);
        else
            SettingsProperties[settingsType] = new() { propertyName };
        SaveNameStatus.TryAdd((settingsType, propertyName), null);
    }

    protected internal static bool CanOnChange<TSettings>(TSettings settings, string propertyName) where TSettings : new()
    {
        var settingsType = typeof(TSettings);
#if DEBUG
        switch (propertyName)
        {
            case "WindowSizePositions":
                break;
        }
#endif
        var key = (settingsType, propertyName);
        if (SaveNameStatus.TryGetValue(key, out var saveStatus) && saveStatus.HasValue)
        {
            
/ </summary>
    protected TValue? value;

    
/ </summary>
    protected abstract TValue? ModelValue { get; }

    
/ 获取模型上的值是否为 <see langword="null"/>
    
/ </summary>
    protected bool ModelValueIsNull => ModelValue == null;

    
/ </summary>
    protected abstract TValue? ActualValue { get; set; }

    public abstract TValue? Default { get; set; }

    protected virtual bool Equals(TValue? left, TValue? right)
    {
        return EqualityComparer<TValue>.Default.Equals(left, right);
    }

    public IDisposable Subscribe(Action<TValue?> listener, bool notifyOnInitialValue = true)
    {
        if (notifyOnInitialValue)
            listener(ActualValue);
        return new ValueChangedEventListener(this, listener);
    }

    protected sealed class ValueChangedEventListener : IDisposable
    {
        private readonly Action<TValue?> _listener;
        private readonly SettingsPropertyBase<TValue> _source;

        public ValueChangedEventListener(SettingsPropertyBase<TValue> property, Action<TValue?> listener)
        {
            _listener = listener;
            _source = property;
            _source.ValueChanged += HandleValueChanged;
        }

        private void HandleValueChanged(object? sender, SettingsPropertyValueChangedEventArgs<TValue> args)
        {
            _listener(args.NewValue);
        }

        public void Dispose()
        {
            _source.ValueChanged -= HandleValueChanged;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator TValue?(SettingsPropertyBase<TValue> property)
        => property.ActualValue;

    #region events

    public event EventHandler<SettingsPropertyValueChangedEventArgs<TValue>>? ValueChanged;

    protected async void OnValueChanged(TValue? oldValue, TValue? newValue)
    {
        await MainThread2.InvokeOnMainThreadAsync(() =>
        {
            ValueChanged?.Invoke(this, new SettingsPropertyValueChangedEventArgs<TValue>(oldValue, newValue));
        });
    }

    readonly Dictionary<PropertyChangedEventHandler, EventHandler<SettingsPropertyValueChangedEventArgs<TValue>>>
        _handlers = new();

    event PropertyChangedEventHandler? INotifyPropertyChanged.PropertyChanged
    {
        add
        {
            if (value == null) return;
            ValueChanged += _handlers[value] = (sender, args) => value(sender, new PropertyChangedEventArgs("Value"));
        }

        remove
        {
            if (value == null) return;
            if (_handlers.TryGetValue(value, out var handler))
            {
                ValueChanged -= handler;
                _handlers.Remove(value);
            }
        }
    }

    #endregion
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Settings\Infrastructure\Abstractions\SettingsPropertyBase.cs
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Settings\Infrastructure\Abstractions\SettingsStructPropertyBase.cs
/ </summary>
    protected override TValue ActualValue
    {
        get => value;
        set
        {
            SetValue(value);
        }
    }

    public override TValue Default { get; set; }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    void SetValue(TValue value, bool save = true)
    {
        if (Equals(value, this.value))
            return; 
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Settings\Steam\SteamSettings.cs
/ </auto-generated>

/ </summary>
    [MPKey(0), MP2Key(0), JsonPropertyOrder(0)]
    public string? SteamStratParameter { get; set; } = ISteamSettings.DefaultSteamStratParameter;

    
/ </summary>
    [MPKey(1), MP2Key(1), JsonPropertyOrder(1)]
    public string? SteamSkin { get; set; } = ISteamSettings.DefaultSteamSkin;

    
/ </summary>
    [MPKey(2), MP2Key(2), JsonPropertyOrder(2)]
    public string? SteamProgramPath { get; set; } = ISteamSettings.DefaultSteamProgramPath;

    
/ </summary>
    [MPKey(3), MP2Key(3), JsonPropertyOrder(3)]
    public bool IsAutoRunSteam { get; set; } = ISteamSettings.DefaultIsAutoRunSteam;

    
/ </summary>
    [MPKey(4), MP2Key(4), JsonPropertyOrder(4)]
    public bool IsRunSteamMinimized { get; set; } = ISteamSettings.DefaultIsRunSteamMinimized;

    
/ </summary>
    [MPKey(5), MP2Key(5), JsonPropertyOrder(5)]
    public bool IsRunSteamNoCheckUpdate { get; set; } = ISteamSettings.DefaultIsRunSteamNoCheckUpdate;

    
/ </summary>
    [MPKey(6), MP2Key(6), JsonPropertyOrder(6)]
    public bool IsRunSteamChina { get; set; } = ISteamSettings.DefaultIsRunSteamChina;

    
/ </summary>
    [MPKey(7), MP2Key(7), JsonPropertyOrder(7)]
    public bool IsRunSteamVGUI { get; set; } = ISteamSettings.DefaultIsRunSteamVGUI;

    
/ </summary>
    [MPKey(8), MP2Key(8), JsonPropertyOrder(8)]
    public bool IsEnableSteamLaunchNotification { get; set; } = ISteamSettings.DefaultIsEnableSteamLaunchNotification;

    
/ </summary>
    [MPKey(9), MP2Key(9), JsonPropertyOrder(9)]
    public OSExitMode DownloadCompleteSystemEndMode { get; set; } = ISteamSettings.DefaultDownloadCompleteSystemEndMode;

    
/ </summary>
    [MPKey(10), MP2Key(10), JsonPropertyOrder(10)]
    public bool IsRunSteamAdministrator { get; set; } = ISteamSettings.DefaultIsRunSteamAdministrator;

}

public static partial class SteamSettings
{
    
/ </summary>
    public static SettingsProperty<string, SteamSettings_> SteamStratParameter { get; }
        = new(DefaultSteamStratParameter);

    
/ </summary>
    public static SettingsProperty<string, SteamSettings_> SteamSkin { get; }
        = new(DefaultSteamSkin);

#if (WINDOWS || MACCATALYST || MACOS || LINUX) && !(IOS || ANDROID)

    
/ </summary>
    public static SettingsProperty<string, SteamSettings_> SteamProgramPath { get; }
        = new(DefaultSteamProgramPath);

    
/ </summary>
    public static SettingsStructProperty<bool, SteamSettings_> IsAutoRunSteam { get; }
        = new(DefaultIsAutoRunSteam);

    
/ </summary>
    public static SettingsStructProperty<bool, SteamSettings_> IsRunSteamMinimized { get; }
        = new(DefaultIsRunSteamMinimized);

    
/ </summary>
    public static SettingsStructProperty<bool, SteamSettings_> IsRunSteamNoCheckUpdate { get; }
        = new(DefaultIsRunSteamNoCheckUpdate);

    
/ </summary>
    public static SettingsStructProperty<bool, SteamSettings_> IsRunSteamChina { get; }
        = new(DefaultIsRunSteamChina);

    
/ </summary>
    public static SettingsStructProperty<bool, SteamSettings_> IsRunSteamVGUI { get; }
        = new(DefaultIsRunSteamVGUI);

    
/ </summary>
    public static SettingsStructProperty<bool, SteamSettings_> IsEnableSteamLaunchNotification { get; }
        = new(DefaultIsEnableSteamLaunchNotification);

    
/ </summary>
    public static SettingsStructProperty<OSExitMode, SteamSettings_> DownloadCompleteSystemEndMode { get; }
        = new(DefaultDownloadCompleteSystemEndMode);

    
/ </summary>
    public static SettingsStructProperty<bool, SteamSettings_> IsRunSteamAdministrator { get; }
        = new(DefaultIsRunSteamAdministrator);

#endif

}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Startup\Startup.Commands.cs
/show.AddOption(new Option<bool>("-config", "显示 Config.mpo 值"));
        show.AddOption(new Option<bool>("-cert", "显示当前根证书信息"));
        show.Handler = CommandHandler.Create((/*bool config,*/ bool cert) =>
        {
#if WINDOWS
            if (!IsDesignMode)
            {
                if (!PInvoke.Kernel32.AttachConsole(-1))
                    PInvoke.Kernel32.AllocConsole();
            }
#endif

            
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Startup\Startup.Commands.cs
DEBUG
DEBUG
WINDOWS
WINDOWS
WINDOWS
MACOS
LINUX
WINDOWS
DEBUG
DEBUG
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Startup\Startup.CompatibilityCheck.cs
/ 检测当前目录 Temp\Rar$ 这类目录，可能是在压缩包中直接启动程序导致的，还有一堆 文件找不到/加载失败的异常
        
/ <para>此应用程序仅兼容 Windows 11 与 Windows 10 版本 1809（OS 内部版本 17763）或更高版本</para>
    
/ <para>不能在临时文件夹中运行此程序，请将所有文件复制或解压到其他路径后再启动程序</para>
    
/ </summary>
    
/ <returns></returns>
#if NET35 || NET40
    [MethodImpl((MethodImplOptions)0x100)]
#else
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    static bool CompatibilityCheck(string baseDirectory)
    {
#if NETFRAMEWORK || WINDOWS
        int major = 10, minor = 0, build = 17763;
#if NETFRAMEWORK
        if (Environment.OSVersion.Version < new Version(major, minor, build))
#else
        if (!OperatingSystem.IsWindowsVersionAtLeast(major, minor, build))
#endif
        {
            ShowErrMessageBox(Error_IncompatibleOS);
            return false;
        }
#endif
        if (IsInTempPath(baseDirectory))
        {
            ShowErrMessageBox(Error_BaseDir_StartsWith_Temp);
            return false;
        }
        return true;
    }

#if NET35 || NET40
    [MethodImpl((MethodImplOptions)0x100)]
#else
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    internal static WPFMessageBoxResult ShowErrMessageBox(string error, WPFMessageBoxButton button = WPFMessageBoxButton.OK)
    {
        try
        {
            if (Environment.UserInteractive)
            {
                
/ 发布此 win-any 与 win-x64 可比较区别
                return WPFMessageBox.Show(error,
                    Error, button, WPFMessageBoxImage.Error);
            }
        }
        catch
        {

        }

        Console.WriteLine("---------------------------");
        Console.WriteLine(Error);
        Console.WriteLine("---------------------------");
        Console.WriteLine(error);
        Console.WriteLine("---------------------------");
        switch (button)
        {
            case WPFMessageBoxButton.OKCancel:
                {
                    Console.WriteLine("OK/Cancel");
                    Console.WriteLine("---------------------------");
                    var line = Console.ReadLine();
                    if (string.Equals(line, nameof(WPFMessageBoxResult.OK)) || string.Equals(line, nameof(WPFMessageBoxResult.Yes)) || string.Equals(line, "o") || string.Equals(line, "y"))
                        return WPFMessageBoxResult.OK;
                    if (string.Equals(line, nameof(WPFMessageBoxResult.Cancel)) || string.Equals(line, nameof(WPFMessageBoxResult.No)) || string.Equals(line, "c") || string.Equals(line, "n"))
                        return WPFMessageBoxResult.Cancel;
                }
                break;
            case WPFMessageBoxButton.YesNoCancel:
                {
                    Console.WriteLine("Yes/No/Cancel");
                    Console.WriteLine("---------------------------");
                    var line = Console.ReadLine();
                    if (string.Equals(line, nameof(WPFMessageBoxResult.OK)) || string.Equals(line, nameof(WPFMessageBoxResult.Yes)) || string.Equals(line, "o") || string.Equals(line, "y"))
                        return WPFMessageBoxResult.Yes;
                    if (string.Equals(line, nameof(WPFMessageBoxResult.No)) || string.Equals(line, "n"))
                        return WPFMessageBoxResult.No;
                    if (string.Equals(line, nameof(WPFMessageBoxResult.Cancel)) || string.Equals(line, "c"))
                        return WPFMessageBoxResult.Cancel;
                }
                break;
            case WPFMessageBoxButton.YesNo:
                {
                    Console.WriteLine("Yes/No");
                    Console.WriteLine("---------------------------");
                    var line = Console.ReadLine();
                    if (string.Equals(line, nameof(WPFMessageBoxResult.OK)) || string.Equals(line, nameof(WPFMessageBoxResult.Yes)) || string.Equals(line, "o") || string.Equals(line, "y"))
                        return WPFMessageBoxResult.Yes;
                    if (string.Equals(line, nameof(WPFMessageBoxResult.Cancel)) || string.Equals(line, nameof(WPFMessageBoxResult.No)) || string.Equals(line, "c") || string.Equals(line, "n"))
                        return WPFMessageBoxResult.No;
                }
                break;
        }
        return WPFMessageBoxResult.OK;
    }
}

#endif

#if NETFRAMEWORK
public static partial class StringEx
{
#if NET35 || NET40
    [MethodImpl((MethodImplOptions)0x100)]
#else
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static bool Contains(this string l, string r, StringComparison comparison)
    {
        var i = l.IndexOf(r, comparison);
        return i >= 0;
    }
}
#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Startup\Startup.CompatibilityCheck.cs
WINDOWS
APP
NET
NETFRAMEWORK
NETFRAMEWORK
NET
NETFRAMEWORK
NET
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Startup\Startup.cs
/ </summary>
public abstract partial class Startup
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal void SetConsoleTitle(string title)
    {
        try
        {
            Console.Title = title;
        }
        catch
        {

        }
    }

#if (WINDOWS || MACCATALYST || MACOS || LINUX) && !(IOS || ANDROID)
    string[]? args;

    public Startup(string[]? args = null)
    {
        
/ </summary>
    
/ <param name="args"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static string[]? HandleProtocolActivation(ProtocolActivatedEventArgs args)
    {
        var uri = args.Uri;
        if (uri != null)
        {
            var urlString = uri.ToString();
            var argsByCustomUrlScheme = GetArgsByCustomUrlScheme(urlString);
            if (argsByCustomUrlScheme != null)
            {
                return argsByCustomUrlScheme;
            }

        }
        return null;
    }
#endif

    
/ 获取命令行参数，返回 <see langword="null"/> 时执行退出
    
/ </summary>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    string[]? GetCommandLineArgs()
    {
        if (IsDesignMode)
            return Array.Empty<string>();

#if WINDOWS
        if (DesktopBridge.IsRunningAsUwp)
        {
            var activatedArgs = AppInstance.GetActivatedEventArgs();
            if (activatedArgs != null)
            {
                switch (activatedArgs.Kind)
                {
                    case ActivationKind.Protocol:
                        if (activatedArgs is ProtocolActivatedEventArgs protocolActivatedEventArgs)
                        {
                            var handledArgs = HandleProtocolActivation(protocolActivatedEventArgs);
                            if (handledArgs != null)
                                this.args = handledArgs;
                        }
                        break;
                    case ActivationKind.StartupTask:
                        this.args = IPlatformService.SystemBootRunArguments.Split(' ');
                        break;
                }
            }
        }
#endif

        Span<string> args;
        if (this.args != null)
        {
            args = this.args.AsSpan();
        }
        else
        {
            
/ 返回启动主进程的参数
            return new[] { command_main };
        }
    }

    #region 自定义协议

    const string customUrlSchemeArgs = $"{Constants.CUSTOM_URL_SCHEME}args";
    const string customUrlSchemeArgs2 = $"{Constants.CUSTOM_URL_SCHEME}args/";

    static string[]? GetArgsByCustomUrlScheme(string urlString)
    {
        if (urlString.StartsWith(customUrlSchemeArgs2, StringComparison.OrdinalIgnoreCase))
        {
            return GetArgsByCustomUrlSchemeCore(urlString[customUrlSchemeArgs2.Length..]);
        }
        else if (urlString.StartsWith(customUrlSchemeArgs, StringComparison.OrdinalIgnoreCase))
        {
            return GetArgsByCustomUrlSchemeCore(urlString[customUrlSchemeArgs.Length..]);
        }
        return null;
    }

    static string[] GetArgsByCustomUrlSchemeCore(string value)
    {
        var args = HttpUtility.UrlDecode(value).Split(' ', StringSplitOptions.RemoveEmptyEntries);
        return args;
    }

    #endregion

    
/ </summary>
    
/ <returns></returns>
    public virtual async Task<int> StartAsync()
    {
#if DEBUG
        Console.WriteLine("BaseDirectory: " + AppContext.BaseDirectory);
#endif
#if DEBUG && WINDOWS
        if (!IsDesignMode)
        {
            var apartmentState = Thread.CurrentThread.GetApartmentState();
            if (apartmentState != ApartmentState.STA)
            {
                throw new ArgumentOutOfRangeException("CurrentThread != ApartmentState.STA");
            }
        }

#endif

#if WINDOWS
        var isRunningAsUwp = DesktopBridgeHelper.Init();
#endif

        try
        {
#if STARTUP_WATCH_TRACE || DEBUG
            WatchTrace.Start();
#endif

            var args = GetCommandLineArgs();
            if (args == null)
                return 0;

            if (args.FirstOrDefault() == IPlatformService.IPCRoot.CommandName)
            {
                ModuleName = IPlatformService.IPCRoot.moduleName;
            }

            #region PlatformPrerequisite 平台先决条件

            if (!IsDesignMode) 
/learn.microsoft.com/zh-cn/dotnet/api/system.runtime.interopservices.nativelibrary.setdllimportresolver
                }
            }
            var assemblies = AppDomain.CurrentDomain.GetAssemblies();
            foreach (var assembly in assemblies)
                CurrentDomain_AssemblyLoad(assembly);
#if STARTUP_WATCH_TRACE || DEBUG
            WatchTrace.Record("CustomAppDomain.AssemblyLoad");
#endif

            
/ fix The request was aborted: Could not create SSL/TLS secure channel
            ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12 | SecurityProtocolType.Tls13;

#if STARTUP_WATCH_TRACE || DEBUG
            WatchTrace.Record("RuntimeConfiguration");
#endif

            #endregion

            #region InitFileSystem 初始化文件系统

            
/docs.microsoft.com/zh-cn/archive/msdn-magazine/2019/march/net-parse-the-command-line-with-system-commandline
            var rootCommand = new RootCommand("命令行工具(Command Line Tools/CLT)");
            ConfigureCommands(rootCommand);

            var exitCode = rootCommand.InvokeAsync(args).GetAwaiter().GetResult();

            if (TryGetPlugins(out var plugins))
            {
                foreach (var plugin in plugins)
                {
                    try
                    {
                        await plugin.OnExit();
                    }
                    catch (Exception ex)
                    {
                        GlobalExceptionHandler.Handler(ex,
                            $"{plugin.UniqueEnglishName}{nameof(IPlugin.OnExit)}");
                    }
                }
            }

            return exitCode;
        }
        catch (Exception ex)
        {
            GlobalExceptionHandler.Handler(ex, nameof(StartAsync));
            throw;
        }
        finally
        {
            if (!IsDesignMode)
            {
                try
                {
                    await DisposeAppAsync();
                }
                catch (Exception ex)
                {
                    GlobalExceptionHandler.Handler(ex, nameof(DisposeAppAsync));
                }

                try
                {
                    await Ioc.DisposeAsync();
                }
                catch (Exception ex)
                {
                    const string _name = $"{nameof(Ioc)}.{nameof(Ioc.DisposeAsync)}";
                    GlobalExceptionHandler.Handler(ex, _name);
                }

                try
                {
                    NLogManager.Shutdown();
                }
                catch
                {

                }

#if WINDOWS || LINUX || APP_REVERSE_PROXY
                try
                {
                    VisualStudioAppCenterSDK.UtilsImpl.Instance.OnExit(null, EventArgs.Empty);
                }
                catch
                {

                }
#endif

                switch (ModuleName)
                {
                    case IPlatformService.IPCRoot.moduleName:
#if WINDOWS
                        try
                        {
                            
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Startup\Startup.cs
WINDOWS
WINDOWS
WINDOWS
WINDOWS
DEBUG
DEBUG
WINDOWS
STARTUP
WINDOWS
STARTUP
WINDOWS
DEBUG
STARTUP
DEBUG
STARTUP
DEBUG
STARTUP
STARTUP
MACOS
WINDOWS
STARTUP
STARTUP
DBREEZE
STARTUP
WINDOWS
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Startup\Startup.DebugConsole.cs
/ </summary>
    protected static class DebugConsole
    {
        public static readonly bool WriteAssemblyLoad = false;
        public static readonly bool WriteAssemblyResolve = false;

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static void WriteLine(FormattableString str)
        {
            Console.WriteLine(str);
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static void Write(string str)
        {
            Console.Write(str);
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static void WriteLine(string str)
        {
            Console.WriteLine(str);
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static void WriteInfo()
        {
            WriteLine($"CurrentUICulture: {CultureInfo.CurrentUICulture}");
#if WINDOWS
            
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Startup\Startup.DebugConsole.cs
DEBUG
WINDOWS
DEBUG
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Startup\Startup.GlobalExceptionHandler.cs
/ </summary>
    public static class GlobalExceptionHandler
    {
        const string TAG = nameof(GlobalExceptionHandler);

        static int index_exceptions;
        static readonly int[] exceptions = new int[3];
        static readonly object lock_global_ex_log = new();
        static readonly Lazy<Logger> _logger = new(LogManager.GetCurrentClassLogger);

        static Logger Logger => _logger.Value;

#if ANDROID || __ANDROID__
        sealed class UncaughtExceptionHandler : JavaObject, JavaThread.IUncaughtExceptionHandler
        {
            readonly Action<JavaThread, JavaThrowable> action;
            readonly JavaThread.IUncaughtExceptionHandler? @interface;

            public UncaughtExceptionHandler(Action<JavaThread, JavaThrowable> action, JavaThread.IUncaughtExceptionHandler? @interface = null)
            {
                this.action = action;
                this.@interface = @interface;
            }

            public void UncaughtException(JavaThread t, JavaThrowable e)
            {
                @interface?.UncaughtException(t, e);
                action(t, e);
            }
        }
#endif

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Init()
        {
#if __ANDROID__
            JavaThread.DefaultUncaughtExceptionHandler = new UncaughtExceptionHandler((_, ex) =>
            {
                Handler(ex, nameof(Java));
            }, JavaThread.DefaultUncaughtExceptionHandler);
#endif
            AppDomain.CurrentDomain.UnhandledException += (_, e) =>
            {
                if (e.ExceptionObject is Exception ex)
                {
                    Handler(ex, nameof(AppDomain), e.IsTerminating);
                }
            };
            RxApp.DefaultExceptionHandler = Observer.Create<Exception>(ex =>
            {
                
/github.com/AvaloniaUI/Avalonia/issues/5290#issuecomment-760751036
                Handler(ex, nameof(RxApp));
            });
        }

        public static void Handler(Exception ex, string name, bool? isTerminating = null)
        {
            var hashCode = ex.GetHashCode();
            if (exceptions.Contains(hashCode))
                return;

            lock (lock_global_ex_log)
            {
                if (index_exceptions >= exceptions.Length)
                    index_exceptions = 0;
                exceptions[index_exceptions++] = hashCode;
            }

            
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Startup\Startup.GlobalExceptionHandler.cs
ANDROID
ANDROID
DEBUG
WINDOWS
DEBUG
WINDOWS
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Startup\Startup.Host.cs
/ 配置 Host
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    protected void RunUIApplication(
        AppServicesLevel? level = null,
        Func<string>? sendMessage = null,
        params string[] loadModules)
    {
#if DEBUG
        var consoleTitle = Constants.CUSTOM_URL_SCHEME_NAME;
        if (!string.IsNullOrWhiteSpace(ModuleName))
            consoleTitle = $"{consoleTitle}({ModuleName})";
        consoleTitle = $"[{Environment.ProcessId}, {IsProcessElevated_DEBUG_Only().ToLowerString()}] {consoleTitle} {string.Join(' ', Environment.GetCommandLineArgs().Skip(1))}";
        SetConsoleTitle(consoleTitle);

        static bool IsProcessElevated_DEBUG_Only()
        {
#if WINDOWS
            return WindowsPlatformServiceImpl.IsPrivilegedProcess;
#else
            return default;
#endif
        }
#endif

#if STARTUP_WATCH_TRACE || DEBUG
        WatchTrace.Start();
#endif

        level ??= IsMainProcess ? AppServicesLevel.MainProcess : AppServicesLevel.Min;

        HasTrayIcon = level.Value.HasFlag(AppServicesLevel.AppUpdateAndTrayIcon);
        HasUI = level.Value.HasFlag(AppServicesLevel.UI);
        HasServerApiClient = level.Value.HasFlag(AppServicesLevel.ServerApiClient);
        HasRepositories = HasServerApiClient || level.Value.HasFlag(AppServicesLevel.Repositories);
        HasSteam = level.Value.HasFlag(AppServicesLevel.Steam);
        HasHttpClientFactory = HasSteam || level.Value.HasFlag(AppServicesLevel.HttpClientFactory);
        HasHttpProxy = level.Value.HasFlag(AppServicesLevel.HttpProxy);
        HasHosts = level.Value.HasFlag(AppServicesLevel.Hosts);
        HasIPCRoot = level.Value.HasFlag(AppServicesLevel.IPCRoot);
#if STARTUP_WATCH_TRACE || DEBUG
        WatchTrace.Record("AppServicesLevel.HasFlag");
#endif

        var directoryExists = ISettings.DirectoryExists();

        #region 初始化通用【配置/设置】 GeneralSettings

        if (ISettings<GeneralSettings_>.Load(directoryExists, out var @delegate, out var generalSettings))
            InvalidConfigurationFileNames.Add(GeneralSettings_.Name);

        #endregion

#if (WINDOWS || MACCATALYST || MACOS || LINUX) && !(IOS || ANDROID)
        if (IsMainProcess || HasIPCRoot || loadModules.Length != 0)
        {
            var pluginResults = PluginsCore.InitPlugins(generalSettings?.CurrentValue.DisablePlugins, loadModules);
            var plugins = pluginResults?.Where(x => !x.IsDisable).Select(x => x.Data).ToHashSet();
            HasPlugins = plugins.Any_Nullable();
            if (HasPlugins)
            {
                var pluginIds = new HashSet<Guid>();
                var pluginUniqueEnglishNames = new HashSet<string>();
                Dictionary<string, IPlugin>? pluginRepetitionIds = null;
                Dictionary<string, IPlugin>? pluginRepetitionUniqueEnglishNames = null;
                Dictionary<PluginRepetitionType, Dictionary<string, IPlugin>>? repetitivePlugins = null;
                void AddRepetition(PluginRepetitionType key, Dictionary<string, IPlugin> value)
                {
                    repetitivePlugins ??= new();
                    if (!repetitivePlugins.ContainsKey(key))
                        repetitivePlugins.Add(key, value);
                }
                void AddRepetitionId(IPlugin plugin)
                {
                    pluginRepetitionIds ??= new();
                    AddRepetition(PluginRepetitionType.Id, pluginRepetitionIds);
                    pluginRepetitionIds.Add(plugin.Id.ToString(), plugin);
                }
                void AddRepetitionUniqueEnglishName(IPlugin plugin)
                {
                    pluginRepetitionUniqueEnglishNames ??= new();
                    AddRepetition(PluginRepetitionType.UniqueEnglishName, pluginRepetitionUniqueEnglishNames);
                    pluginRepetitionUniqueEnglishNames.Add(plugin.UniqueEnglishName, plugin);
                }
                foreach (var item in plugins!)
                {
                    var isRepetition = false;
                    if (!pluginIds.Add(item.Id))
                    {
                        isRepetition = true;
                        AddRepetitionId(item);
                    }
                    if (!pluginUniqueEnglishNames.Add(item.UniqueEnglishName))
                    {
                        isRepetition = true;
                        AddRepetitionUniqueEnglishName(item);
                    }
                    if (isRepetition)
                    {
                        pluginResults!.RemoveWhere(x => x.Data == item && !x.IsDisable);
                        plugins.Remove(item);
                    }
                }
                RepetitivePlugins = repetitivePlugins;
                this.plugins = plugins;
            }
            this.pluginResults = pluginResults;
#if STARTUP_WATCH_TRACE || DEBUG
            WatchTrace.Record("InitPlugins");
#endif
        }
#endif

        if (IsMainProcess)
        {
            if (!InitSingleInstancePipeline(sendMessage))
            {
                return;
            }
            singleInstancePipeline.ThrowIsNull().MessageReceived += OnMessageReceived;
#if STARTUP_WATCH_TRACE || DEBUG
            WatchTrace.Record("InitSingleInstancePipeline");
#endif
        }

        if (HasHttpClientFactory || HasHttpProxy)
        {
            void SetWebProxyMode(AppWebProxyMode mode)
            {
                switch (mode)
                {
                    case AppWebProxyMode.NoProxy:
                        HttpClient.DefaultProxy = HttpNoProxy.Instance;
                        break;
                    case AppWebProxyMode.Custom:
                        WebProxy webProxy;
                        if (!string.IsNullOrEmpty(generalSettings.CurrentValue.CustomWebProxyModeHost) && generalSettings.CurrentValue.CustomWebProxyModePort != default)
                        {
                            webProxy = new(generalSettings.CurrentValue.CustomWebProxyModeHost, generalSettings.CurrentValue.CustomWebProxyModePort)
                            {
                                BypassProxyOnLocal = generalSettings.CurrentValue.CustomWebProxyModeBypassOnLocal,
                            };
                        }
                        else if (!string.IsNullOrEmpty(generalSettings.CurrentValue.CustomWebProxyModeAddress))
                        {
                            webProxy = new(generalSettings.CurrentValue.CustomWebProxyModeAddress, generalSettings.CurrentValue.CustomWebProxyModeBypassOnLocal);
                        }
                        else
                        {
                            SetWebProxyMode(AppWebProxyMode.FollowSystem);
                            return;
                        }
                        if (!string.IsNullOrEmpty(generalSettings.CurrentValue.CustomWebProxyModeCredentialUserName))
                        {
                            NetworkCredential credential = new(generalSettings.CurrentValue.CustomWebProxyModeCredentialUserName,
                                generalSettings.CurrentValue.CustomWebProxyModeCredentialPassword ?? "",
                                generalSettings.CurrentValue.CustomWebProxyModeCredentialDomain ?? "");
                            webProxy.Credentials = credential;
                        }
                        HttpClient.DefaultProxy = webProxy;
                        break;
                    default:
                    case AppWebProxyMode.FollowSystem:
#if WINDOWS
                        
/ 在 Windows 上还原 .NET Framework 中网络请求跟随系统网络代理变化而动态切换代理行为
                        HttpClient.DefaultProxy = DynamicHttpWindowsProxy.Instance;
#endif
                        break;
                }
            }
            if (generalSettings != null)
                SetWebProxyMode(generalSettings.CurrentValue.WebProxyMode);
#if STARTUP_WATCH_TRACE || DEBUG
            WatchTrace.Record("DynamicHttpWindowsProxy");
#endif
        }

        #region 初始化【配置/设置】 Settings/Configuration

        if (ISettings<UISettings_>.Load(directoryExists, out var @delegate1))
            InvalidConfigurationFileNames.Add(UISettings_.Name);
        else
            @delegate += @delegate1;
        if (ISettings<SteamSettings_>.Load(directoryExists, out var @delegate2))
            InvalidConfigurationFileNames.Add(SteamSettings_.Name);
        else
            @delegate += @delegate2;

        if (TryGetPlugins(out var plugins_cfg))
        {
            foreach (var plugin in plugins_cfg)
            {
                try
                {
                    directoryExists = ISettings.DirectoryExists(plugin.AppDataDirectory);
                    var plugin_cfg = plugin.GetConfiguration(directoryExists);
                    if (plugin_cfg != default)
                    {
                        foreach (var item in plugin_cfg)
                        {
                            if (item.isInvalid)
                            {
                                InvalidConfigurationFileNames.Add(item.name);
                            }
                            if (item.@delegate != null)
                            {
                                @delegate += item.@delegate;
                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    GlobalExceptionHandler.Handler(ex,
                        $"{plugin.UniqueEnglishName}{nameof(IPlugin.GetConfiguration)}");
                }
            }
        }

        Configuration = @delegate;

#if STARTUP_WATCH_TRACE || DEBUG
        WatchTrace.Record("LoadSettings");
#endif
        #endregion

#if STARTUP_WATCH_TRACE || DEBUG
        WatchTrace.Stop();
#endif

        LoadLogicApplication();

        if (!IsDesignMode && IsMainProcess)
            StartUIApplication();
    }

    async void OnMessageReceived(string value)
    {
        if (!string.IsNullOrEmpty(value))
        {
            switch (value)
            {
                case key_shutdown:
                    var app = await UIApplicationTCS.Task;
                    app.Shutdown();
                    return;
                case key_show:
                    try
                    {
                        MainThread2.BeginInvokeOnMainThread(() =>
                        {
                            try
                            {
                                IApplication.Instance.RestoreMainWindow();
                            }
                            catch
                            {

                            }
                        });
                    }
                    catch
                    {

                    }
                    break;
                default:
                    var args = value.Split(' ', StringSplitOptions.RemoveEmptyEntries);
                    if (args.Length >= 1)
                    {
                        switch (args[0])
                        {
                            case key_proxy:
                                if (args.Length >= 2)
                                {
                                    ProxyMessageReceived();
                                    return;
                                }
                                void ProxyMessageReceived()
                                {
                                    var value = Enum.TryParse<OnOffToggle>(
                                        args[1], out var value_) ? value_ : default;
                                    try
                                    {
                                        MainThread2.BeginInvokeOnMainThread(() =>
                                        {
                                            var proxyService = Ioc.Get_Nullable<IProxyService>();
                                            if (proxyService == null)
                                                return;
                                            var status = value switch
                                            {
                                                OnOffToggle.On => true,
                                                OnOffToggle.Off => false,
                                                _ => !proxyService.ProxyStatus,
                                            };
                                            proxyService.StartOrStopProxyService(status);
                                        });
                                    }
                                    catch (Exception ex)
                                    {
                                        GlobalExceptionHandler.Handler(ex,
                                            nameof(ProxyMessageReceived));
                                    }
                                }
                                break;
                        }
                    }
                    break;
            }
        }

        try
        {
            var app = await UIApplicationTCS.Task;
            MainThread2.BeginInvokeOnMainThread(app.RestoreMainWindow);
        }
        catch (Exception ex)
        {
            GlobalExceptionHandler.Handler(ex, nameof(OnMessageReceived));
        }
    }

    LogLevel? overrideLoggerMinLevel;

    
/ </summary>
    public void LoadLogicApplication()
    {
#if STARTUP_WATCH_TRACE || DEBUG
        WatchTrace.Start();
#endif

        if (HasServerApiClient)
        {
            ModelValidatorProvider.Init();
#if STARTUP_WATCH_TRACE || DEBUG
            WatchTrace.Record("ModelValidatorProvider.Init");
#endif
        }

        
/ </summary>
    
/ <param name="services"></param>
    protected abstract void ConfigureDemandServices(IServiceCollection services);

    
/ </summary>
    
/ <param name="services"></param>
    protected abstract void ConfigureRequiredServices(IServiceCollection services);

    
/ </summary>
    protected abstract void StartUIApplication();

    protected readonly TaskCompletionSource<IApplication> UIApplicationTCS = new();
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Startup\Startup.Host.cs
DEBUG
WINDOWS
STARTUP
STARTUP
STARTUP
STARTUP
WINDOWS
STARTUP
STARTUP
STARTUP
STARTUP
STARTUP
STARTUP
STARTUP
STARTUP
STARTUP
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Startup\Startup.OnStartup.cs
STARTUP
STARTUP
DEBUG
STARTUP
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Startup\Startup.Properties.cs
/ </summary>
    public string? ModuleName { get; private set; }

    
/ </summary>
    public bool IsMainProcess { get; private set; }

    
/ </summary>
    public bool IsConsoleLineToolProcess { get; private set; }

#if DEBUG
    
/ <inheritdoc cref="IsConsoleLineToolProcess"/>
    [Obsolete("use IsConsoleLineToolProcess", true)]
    public bool IsCLTProcess => IsConsoleLineToolProcess;
#endif

    
/ </summary>
    public bool IsCustomEntryPoint { get; init; }

    
/ </summary>
    public bool IsDesignMode { get; set; }

    
/ </summary>
    public bool IsSteamRun { get; set; }

    
/ </summary>
    public bool IsMinimize { get; set; }

    
/ </summary>
    public bool IsProxyService { get; private set; }

    
/ </summary>
    public OnOffToggle ProxyServiceStatus { get; private set; }

    public object? App { private get; set; }

    
/ </summary>
    public Action<IServiceCollection>? Configuration { get; private set; }

    
/ </summary>
    public bool InvalidConfiguration => InvalidConfigurationFileNames.Any();

    
/ </summary>
    public HashSet<string> InvalidConfigurationFileNames { get; private set; } = new();

    
/ 存在重复的插件列表，无重复则为 <see langword="null"/>
    
/ <para>string = 重复的 Id 或者 UniqueEnglishName</para>
    
/ </summary>
    public Dictionary<PluginRepetitionType, Dictionary<string, IPlugin>>? RepetitivePlugins { get; private set; }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    async ValueTask DisposeAppAsync()
    {
        var app = App;
        if (app == null)
        {
            return;
        }
        else if (app is IAsyncDisposable asyncDisposable)
        {
            await asyncDisposable.DisposeAsync();
            return;
        }
        else if (app is IDisposable disposable)
        {
            disposable.Dispose();
            return;
        }
    }

    
/ <inheritdoc cref="AppServicesLevel.AppUpdateAndTrayIcon"/>
    public bool HasTrayIcon { get; set; }

    
/ <inheritdoc cref="AppServicesLevel.UI"/>
    public bool HasUI { get; private set; }

    
/ <inheritdoc cref="AppServicesLevel.ServerApiClient"/>
    public bool HasServerApiClient { get; private set; }

    
/ <inheritdoc cref="AppServicesLevel.Repositories"/>
    public bool HasRepositories { get; private set; }

    
/ <inheritdoc cref="AppServicesLevel.HttpClientFactory"/>
    public bool HasHttpClientFactory { get; private set; }

    
/ <inheritdoc cref="AppServicesLevel.HttpProxy"/>
    public bool HasHttpProxy { get; private set; }

    
/ <inheritdoc cref="AppServicesLevel.Hosts"/>
    public bool HasHosts { get; private set; }

    
/ <inheritdoc cref="AppServicesLevel.Steam"/>
    public bool HasSteam { get; private set; }

    
/ <inheritdoc cref="AppServicesLevel.IPCRoot"/>
    public bool HasIPCRoot { get; private set; }

#if (WINDOWS || MACCATALYST || MACOS || LINUX) && !(IOS || ANDROID)
    
/ </summary>
    public bool HasPlugins { get; private set; }

    
/ </summary>
    IReadOnlyCollection<IPlugin>? plugins;

    
/ </summary>
    IReadOnlyCollection<PluginResult<IPlugin>>? pluginResults;
#endif

    
/ </summary>
    
/ <param name="plugins"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetPlugins([NotNullWhen(true)] out IReadOnlyCollection<IPlugin>? plugins)
    {
#if (WINDOWS || MACCATALYST || MACOS || LINUX) && !(IOS || ANDROID)
        plugins = this.plugins;
        return HasPlugins;
#else
        plugins = default;
        return default;
#endif
    }

    
/ </summary>
    
/ <param name="plugins"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetPluginResults([NotNullWhen(true)] out IReadOnlyCollection<PluginResult<IPlugin>>? pluginResults)
    {
#if (WINDOWS || MACCATALYST || MACOS || LINUX) && !(IOS || ANDROID)
        pluginResults = this.pluginResults;
        return HasPlugins;
#else
        pluginResults = default;
        return default;
#endif
    }

    readonly TaskCompletionSource waitConfiguredServices = new();

    public Task WaitConfiguredServices => waitConfiguredServices.Task;

    static readonly Lazy<string?> _NativeLibraryPath = new(() =>
    {
#if WINDOWS || LINUX
        return $"{GlobalDllImportResolver.GetLibraryPath(null)};{GlobalDllImportResolver.GetLibraryPath(null, IOPath.AppDataDirectory)}";
#endif
#if MACOS
        return AppContext.BaseDirectory;
#endif
        return null;
    });

    
/ </summary>
    public static string? NativeLibraryPath => _NativeLibraryPath.Value;
}

发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Startup\Startup.Properties.cs
DEBUG
WINDOWS
MACOS
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Startup\Startup.RunSelfProcess.cs
LINUX
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Startup\Startup.SingleInstancePipeline.cs
/ </summary>
    sealed class SingleInstancePipeline : IDisposable
    {
        bool disposedValue;

        
/ </summary>
        public bool IsFirstSelfApp { get; }

        
/ </summary>
        public event Action<string>? MessageReceived;

        public SingleInstancePipeline()
        {
            IsFirstSelfApp = GetIsFirstSelfApp();
            if (IsFirstSelfApp)
            {
                Task.Factory.StartNew(() =>
                {
                    Thread.CurrentThread.IsBackground = true;
                    RunSingleInstancePipeServer();
                });
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static bool GetIsFirstSelfApp()
        {
            var query = GetCurrentAllProcess();
            var result = query.Any();
            return !result;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static IEnumerable<Process> GetCurrentAllProcess()
        {
            var current = Process.GetCurrentProcess();
#if DEBUG
            if (string.Equals("dotnet", Path.GetFileNameWithoutExtension(current.MainModule?.FileName), StringComparison.OrdinalIgnoreCase))
            {
                return Array.Empty<Process>();
            }
#endif
            var currentMainModule = current.TryGetMainModule();
            bool IsThisProgram(Process p, ProcessModule? pMainModule)
            {
                if (currentMainModule != null)
                {
                    if (pMainModule != null)
                    {
                        return pMainModule.FileName == currentMainModule.FileName &&
                            pMainModule.ModuleName == currentMainModule.ModuleName;
                    }
                    else
                    {
#if WINDOWS
                        var path = Interop.Kernel32.QueryFullProcessImageName(p);
                        return path == currentMainModule.FileName;
#else
                        return false;
#endif
                    }
                }
                return true;
            }
            var query = from p in Process.GetProcessesByName(current.ProcessName)
                        let pMainModule = p.TryGetMainModule()
                        where p.Id != current.Id &&
                            p.ProcessName == current.ProcessName && IsThisProgram(p, pMainModule)
                        select p;
            return query;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TryKillCurrentAllProcess()
        {
            foreach (var p in GetCurrentAllProcess())
            {
                try
                {
#if NETSTANDARD
                    p.Kill();
#else
                    p.Kill(true);
#endif
                    p.WaitForExit(TimeSpan.FromSeconds(15));
                }
                catch
                {
                }
            }
            return GetIsFirstSelfApp();
        }

        #region Pipes

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static string GetPipeName()
        {
            var processPath = Environment.ProcessPath ?? string.Empty;
            return AssemblyInfo.APPLICATION_ID + "_v" + AssemblyInfo.InformationalVersion + "_" + Hashs.String.Crc32(processPath);
        }

        CancellationTokenSource? cts;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        void RunSingleInstancePipeServer()
        {
            cts = new CancellationTokenSource();
            var name = GetPipeName();

            NamedPipeServerStream GetNamedPipeServerStream()
            {
                const PipeDirection direction = PipeDirection.In;
                const int maxNumberOfServerInstances = 5;
                const PipeTransmissionMode transmissionMode = PipeTransmissionMode.Byte;
                const PipeOptions options = PipeOptions.None;
                const int inBufferSize = 0;
                const int outBufferSize = 0;
#if WINDOWS
                if (WindowsPlatformServiceImpl.IsPrivilegedProcess)
                {
                    
/github.com/dotnet-campus/dotnetCampus.Ipc/blob/2.0.0-alpha403/src/dotnetCampus.Ipc/Internals/IpcPipeServerMessageProvider.cs#L99
                    SecurityIdentifier securityIdentifier = new(WellKnownSidType.AuthenticatedUserSid, null);
                    PipeSecurity pipeSecurity = new();
                    pipeSecurity.AddAccessRule(new PipeAccessRule(securityIdentifier,
                        PipeAccessRights.ReadWrite | PipeAccessRights.CreateNewInstance,
                        AccessControlType.Allow));

                    var result = NamedPipeServerStreamAcl.Create(name, direction, maxNumberOfServerInstances, transmissionMode, options, inBufferSize, outBufferSize, pipeSecurity);
                    return result;
                }
#endif
                return new NamedPipeServerStream(name, direction, maxNumberOfServerInstances, transmissionMode, options);
            }

            while (true)
            {
                using var pipeServer = GetNamedPipeServerStream();
                try
                {
                    pipeServer.WaitForConnection();
                    using var sr = new StreamReader(pipeServer);
                    
/ </summary>
        
/ <param name="value"></param>
        public static bool SendMessage(string value)
        {
            var name = GetPipeName();
            try
            {
                using var pipeClient = new NamedPipeClientStream(".", name,
                    PipeDirection.Out, PipeOptions.None,
                    TokenImpersonationLevel.Impersonation);
                pipeClient.Connect(TimeSpan.FromSeconds(7.7D));
                using StreamWriter sw = new StreamWriter(pipeClient);
                sw.WriteLine(value);
                return true;
            }
            catch
            {
                return false;
            }
        }

        #endregion

        void Dispose(bool disposing)
        {
            if (!disposedValue)
            {
                if (disposing)
                {
                    
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Startup\Startup.SingleInstancePipeline.cs
WINDOWS
DEBUG
WINDOWS
NETSTANDARD
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\Startup\Startup.WatchTrace.cs
/ </summary>
    public static class WatchTrace
    {
        static Stopwatch? sw;
        static long elapsedMilliseconds;

        [MethodImpl(MethodImplOptions.NoInlining)]
        static void WatchTraceWriteLine(
            [StringSyntax(StringSyntaxAttribute.CompositeFormat)] string format,
            params object?[] args)
        {
            Debug.WriteLine(format, args);
            Console.WriteLine(string.Format(format, args));
        }

        
/ </summary>
        [MethodImpl(MethodImplOptions.NoInlining)]
        public static void Stop() => sw?.Stop();

        
/ </summary>
        [MethodImpl(MethodImplOptions.NoInlining)]
        public static void Start()
        {
            Stop();
            sw = Stopwatch.StartNew();
        }

        
/ </summary>
        
/ <param name="mark"></param>
        [MethodImpl(MethodImplOptions.NoInlining)]
        public static void Record(string mark)
        {
            if (sw == null) return;

            sw.Stop();
            elapsedMilliseconds += sw.ElapsedMilliseconds;
            WatchTraceWriteLine("{1} {0}ms", sw.ElapsedMilliseconds, mark);
            sw.Restart();
        }

        
/ </summary>
        [MethodImpl(MethodImplOptions.NoInlining)]
        public static void StopWriteTotal()
        {
            if (sw == null) return;

            sw.Stop();
            elapsedMilliseconds += sw.ElapsedMilliseconds;
            WatchTraceWriteLine("Total {0}ms", elapsedMilliseconds);
        }
    }
#endif
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\Startup\Startup.WatchTrace.cs
STARTUP
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\UI\ViewModels\Abstractions\RIdTitleIconViewModel.cs
/ </summary>
    
/ <param name="vm"></param>
    protected virtual void OnBind(IDisposableHolder vm)
    {
        disposable = ResourceService.Subscribe(OnResChanged);
        disposable.AddTo(vm);
    }

    protected virtual void OnResChanged()
    {
        Title = GetTitleById(id);
    }

    
/ </summary>
    
/ <param name="vm"></param>
    protected virtual void OnUnbind(IDisposableHolder vm)
    {
        if (disposable != null)
        {
            disposable.RemoveTo(vm);
        }
    }

    protected virtual void Dispose(bool disposing)
    {
        if (!disposedValue)
        {
            if (disposing)
            {
                
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\UI\ViewModels\Abstractions\ViewModelBase.cs
/ </summary>
    [IgnoreDataMember, MPIgnore, MP2Ignore, N_JsonIgnore, S_JsonIgnore]
    protected virtual bool IsSingleInstance { get; }

    [IgnoreDataMember, MPIgnore, MP2Ignore, N_JsonIgnore, S_JsonIgnore]
    public CompositeDisposable CompositeDisposable { get; private set; } = new();

    [IgnoreDataMember, MPIgnore, MP2Ignore, N_JsonIgnore, S_JsonIgnore]
    public ViewModelActivator Activator { get; protected set; }

    public ViewModelBase()
    {
        Activator = new ViewModelActivator();

        this.WhenActivated(disposables =>
        {
            Activation();

            CompositeDisposable.Add(Disposable.Create(Deactivation)
                                              .DisposeWith(disposables));
        });
    }

    [IgnoreDataMember, MPIgnore, MP2Ignore, N_JsonIgnore, S_JsonIgnore]
    public bool IsFirstActivation = true;

    [IgnoreDataMember, MPIgnore, MP2Ignore, N_JsonIgnore, S_JsonIgnore]
    public bool IsDeactivation = false;

    [IgnoreDataMember, MPIgnore, MP2Ignore, N_JsonIgnore, S_JsonIgnore]
    public bool Disposed { get; private set; }

    public virtual void Activation()
    {
        if (IsFirstActivation)
        {
            IsFirstActivation = false;
        }
        IsDeactivation = false;
    }

    public virtual void Deactivation()
    {
        IsDeactivation = true;
    }

    protected virtual void Dispose(bool disposing)
    {
        if (!Disposed)
        {
            if (disposing)
            {
                if (IsSingleInstance)
                {
                    try
                    {
                        IViewModelManager.Instance.Dispose(this);
                    }
                    catch (Exception ex)
                    {
                        Log.Error(nameof(ViewModelBase), ex, "Dispose fail.");
                    }
                }

                
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\UI\ViewModels\Abstractions\Items\Actions\IActionItem.cs
/docs.microsoft.com/en-us/xamarin/xamarin-forms/user-interface/toolbaritem</para>

/ </summary>

/ <typeparam name="TEnum"></typeparam>
public interface IActionItem<TEnum> where TEnum : struct, Enum
{
    
/ </summary>
    
/ <param name="action"></param>
    
/ <returns></returns>
    string ToString2(TEnum action);

    
/ </summary>
    
/ <param name="action"></param>
    
/ <returns></returns>
    string GetIcon(TEnum action);

    
/ </summary>
    
/ <param name="action"></param>
    
/ <returns></returns>
    bool IsPrimary(TEnum action) => false;

    
/ </summary>
    
/ <param name="action"></param>
    void MenuItemClick(TEnum action);
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\UI\ViewModels\Abstractions\Windows\ITextBoxWindowViewModel.cs
/ </summary>
    
/ <returns></returns>
    bool InputValidator() => true;
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\UI\ViewModels\Abstractions\Windows\IWindowViewModel.cs
/ </summary>
    Action<bool>? Close { get; set; }

    
/ </summary>
    Action Show { get; set; }

    abstract void OnClosing(object? sender, CancelEventArgs e);
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\UI\ViewModels\Pages\AboutPageViewModel.cs
/www.w3cschool.cn/html/html-copyright.html
            int startYear = 2020, thisYear = 2023;
            var nowYear = DateTime.Now.Year;
            if (nowYear < thisYear) nowYear = thisYear;
            return $"© {startYear}{(nowYear == startYear ? startYear : "-" + nowYear)} {AssemblyInfo.Company}. All Rights Reserved.";
        }
    }

    internal static string? GetOSName()
    {
        string? osName;
#if LINUX

        var d = IPlatformService.LinuxDistribution;
        if (d.IsDefined())
            return d.ToString();
        osName = IPlatformService.GetLinuxReleaseValue(IPlatformService.LinuxConstants.ReleaseKey_NAME);
        if (!string.IsNullOrWhiteSpace(osName))
            return osName;
        osName = IPlatformService.GetLinuxReleaseValue(IPlatformService.LinuxConstants.ReleaseKey_ID);
        if (!string.IsNullOrWhiteSpace(osName))
            return osName;

#endif
        osName = DeviceInfo2.OSName();
        return osName;
    }

    [IgnoreDataMember, MPIgnore, MP2Ignore, N_JsonIgnore, S_JsonIgnore]
    public string VersionDisplay
    {
        get
        {
            var value = $"{AssemblyInfo.InformationalVersion} for {GetOSName()} ({RuntimeInformation.ProcessArchitecture.ToString().ToLower()})";
            value = Strings.About_Version_.Format(value);
            return value;
        }
    }

    [IgnoreDataMember, MPIgnore, MP2Ignore, N_JsonIgnore, S_JsonIgnore]
    public string DotnetDesc =>
"""
.NET is a free, cross-platform, open source developer platform for building many different types of applications.

With .NET, you can use multiple languages, editors, and libraries to build for web, mobile, desktop, games, IoT, and more.
""";

    [IgnoreDataMember, MPIgnore, MP2Ignore, N_JsonIgnore, S_JsonIgnore]
    public string AvaloniaDesc =>
"""
Avalonia is a cross-platform UI framework for dotnet, providing a flexible styling system and supporting a wide range of platforms such as Windows, macOS, Linux, iOS, Android and WebAssembly. Avalonia is mature and production ready and is used by companies, including Schneider Electric, Unity, JetBrains and Github.
""";

    [IgnoreDataMember, MPIgnore, MP2Ignore, N_JsonIgnore, S_JsonIgnore]
    public string AvaloniaVersion
    {
        get
        {
            var avaloniaVersion = GetAssemblyVersion(
               "Avalonia.Application, Avalonia.Controls") ?? "???";
            var value = $"Avalonia {avaloniaVersion}";
            return value;
        }
    }

    [IgnoreDataMember, MPIgnore, MP2Ignore, N_JsonIgnore, S_JsonIgnore]
    public string RuntimeVersion =>
        
/steampp.net/changelog
        yield return new HL(Strings.Changelog, Constants.Urls.OfficialWebsite_Changelog);
        
/steampp.net/contact
        yield return new HL(Strings.ContactUs, Constants.Urls.OfficialWebsite_Contact);
        
/steampp.net/joinus
        yield return new HL(Strings.JoinUs, Constants.Urls.OfficialWebsite_JoinUs);
        
/steampp.net/faq
        yield return new HL(Strings.FAQ, Constants.Urls.OfficialWebsite_Faq);
        
/steampp.net/agreement
        yield return new HL(Strings.User_Agreement, Constants.Urls.OfficialWebsite_Agreement);
        
/steampp.net/privacy
        yield return new HL(Strings.User_Privacy, Constants.Urls.OfficialWebsite_Privacy);
        
/github.com/BeyondDimension/SteamTools/issues
        yield return new HL($"{Strings.BugReport}(GitHub)", Constants.Urls.GitHub_Issues);
        
/gitee.com/rmbgame/SteamTools/issues
        yield return new HL($"{Strings.BugReport}(Gitee)", Constants.Urls.Gitee_Issues);
        
/crowdin.com/project/steampp
        yield return new HL($"Crowdin Translate", Constants.Urls.CrowdinUrl);
        
/github.com/BeyondDimension/SteamTools
        yield return new HL("Source Code(GitHub)", Constants.Urls.GitHub_Repository);
        
/gitee.com/rmbgame/SteamTools
        yield return new HL("Source Code(Gitee)", Constants.Urls.Gitee_Repository);
    }

    public IReadOnlyCollection<HL>? OSL
    {
        get
        {
            try
            {
                return Serializable.DMP2<HL[]>(Properties.Resources.open_source_library);
            }
            catch
            {
                return null;
            }
        }
    }

    [IgnoreDataMember, MPIgnore, MP2Ignore, N_JsonIgnore, S_JsonIgnore]
    public string Licensed => $"{AssemblyInfo.Trademark} is licensed under the GPLv3 license.";
}

发现条件编译指令：../SteamTools\src\BD.WTTS.Client\UI\ViewModels\Pages\AboutPageViewModel.cs
LINUX
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\UI\ViewModels\Pages\AboutPageViewModel.EasterEgg.cs
/b.AppendLine();

        b.Append("[app.install] ");
        b.Append(platformService.CurrentAppIsInstallVersion.ToLowerString());
        b.AppendLine();

#if WINDOWS10_0_17763_0_OR_GREATER
        if (OperatingSystem2.IsWindows10AtLeast())
        {
            try
            {
                var currentPackage = Windows.ApplicationModel.Package.Current;
                var familyName = currentPackage.Id.FamilyName;
                b.Append("[app.pkg] ");
                b.Append(familyName);
                b.AppendLine();
            }
            catch
            {
            }
        }
#endif

        b.Append("[memory.usage] ");
#if ANDROID
        var activityManager = (ActivityManager)activity.GetSystemService(Context.ActivityService)!;
        ActivityManager.MemoryInfo memoryInfo = new();
        activityManager.GetMemoryInfo(memoryInfo);
        var nativeHeapSize = memoryInfo.TotalMem;
        var nativeHeapFreeSize = memoryInfo.AvailMem;
        var usedMemInBytes = nativeHeapSize - nativeHeapFreeSize;
        var usedMemInPercentage = usedMemInBytes * 100M / nativeHeapSize;
        b.Append($"{IOPath.GetDisplayFileSizeString(usedMemInBytes)} ({usedMemInPercentage:0.00}%)");
#else
        b.Append(IOPath.GetDisplayFileSizeString(Environment.WorkingSet));
#endif
        b.AppendLine();

        b.Append("[deploy.mode] ");
        b.Append(IApplication.Instance.DeploymentMode);
        b.AppendLine();

        b.Append("[arch.os] ");
        b.Append(RuntimeInformation.OSArchitecture);
        b.AppendLine();

        b.Append("[arch.proc] ");
        b.Append(RuntimeInformation.ProcessArchitecture);
        b.AppendLine();

        b.Append("[clr.ver] ");
        string? clrVersion;
        try
        {
            clrVersion = GetAssemblyVersion(typeof(object).Assembly);
        }
        catch
        {
            clrVersion = null;
        }
        if (string.IsNullOrEmpty(clrVersion))
            b.Append(System.Environment.Version);
        else
            b.Append(clrVersion);
        b.AppendLine();

#if ANDROID

#if V2RAY
        b.Append("[v2ray.ver] ");
        b.Append(Libv2ray.Libv2ray.CheckVersionX());
        b.AppendLine();
#endif

        
发现与操作系统相关的函数调用：../SteamTools\src\BD.WTTS.Client\UI\ViewModels\Pages\AboutPageViewModel.EasterEgg.cs
name
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\UI\ViewModels\Pages\AboutPageViewModel.EasterEgg.cs
ANDROID
ANDROID
ANDROID
ANDROID
ANDROID
IS
WINDOWS
ANDROID
ANDROID
V
ANDROID
MONOANDROID
ANDROID
ANDROID
ANDROID
ANDROID
AVALONIA
ANDROID
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\UI\ViewModels\Pages\DebugPageViewModel.cs
/BD.WTTS.Client.Avalonia/UI/Assets/Icons/bug.ico";

    public DebugPageViewModel() { }

    string _DebugString = string.Empty;

    [Utf8StringFormatter]
    public string DebugString
    {
        get => _DebugString;
        set => this.RaiseAndSetIfChanged(ref _DebugString, value);
    }

    sealed class D : Repository<Common.Entities.KeyValuePair, string>
    {

    }

    public async void Debug(string? cmd)
    {
        if (string.IsNullOrEmpty(cmd))
            return;

        var title = "测试Test🎆🎇→→";

        var cmds = cmd.ToLowerInvariant().Split(' ');
        switch (cmds[0])
        {
            case "dialog":
                var isDialog = cmds.Length > 1 && cmds[1].Contains('1');
                var textModel = new TextBoxWindowViewModel();
                var result = await IWindowManager.Instance.ShowTaskDialogAsync(textModel, "Window Title", subHeader: title, isDialog: isDialog, isCancelButton: true);
                DebugString += "ShowTaskDialogAsync Result: " + result + Environment.NewLine
                            + "Text Result: " + textModel.Value + Environment.NewLine;
                break;
            case "toast":
                Toast.Show(title);
                break;
            case "messagebox":
                MessageBox.Show(title);
                break;
            case "notify":
                INotificationService.Instance.Notify(title, NotificationType.Announcement);
                break;
            case "webview":
                break;
            case "demo":
                break;
            case "window":
                ContentWindowViewModel vm = new() { PageViewModel = new SettingsPageViewModel { } };
                await IWindowManager.Instance.ShowAsync(AppEndPoint.Content, vm, isParent: false);
                break;
            case "asm":
                DebugString = string.Join(Environment.NewLine, AppDomain.CurrentDomain.GetAssemblies().Select(x => x.FullName).OrderBy(x => x));
                break;
#if (WINDOWS || MACCATALYST || MACOS || LINUX) && !(IOS || ANDROID)
            case "plu":
                var plugins_assemblies = PluginsCore.LoadAssemblies() ?? new();
                DebugString = string.Join(Environment.NewLine, plugins_assemblies.Select(x => x.Data.FullName).OrderBy(x => x));
                break;
#endif
            case "acc":
                try
                {
                    dynamic reverseProxyS = Ioc.Get(
                    Assembly.Load("BD.WTTS.Client.Plugins.Accelerator").GetType("BD.WTTS.Services.IReverseProxyService")!);
                    await reverseProxyS.StartProxyAsync();
                }
                catch (Exception ex)
                {
                    DebugString = ex.ToString();
                }
                break;
            case "updatetray":

                break;
            case "gc":
                GC.Collect();
                break;
            case "refreshnews":
#if DEBUG
                NoticeService.Current.ClrearLastLookNoticeDateTime();
#endif
                await NoticeService.Current.GetNewsAsync();
                break;
            case "login":
                if (cmds.Length > 1)
                {
                    
发现条件编译指令：../SteamTools\src\BD.WTTS.Client\UI\ViewModels\Pages\DebugPageViewModel.cs
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\UI\ViewModels\Pages\HomePageViewModel.cs
/BD.WTTS.Client.Avalonia/UI/Assets/Icons/home.ico";

    [Reactive]
    public ObservableCollection<ArticleItemDTO> Articles { get; set; }

    [Reactive]
    public ObservableCollection<AdvertisementDTO> NavigationBanners { get; set; }

    [Reactive]
    
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\UI\ViewModels\Pages\PluginStorePageViewModel.cs
/BD.WTTS.Client.Avalonia/UI/Assets/Icons/home.ico";

    public ICommand NavgationToMenuPageCommand { get; }

    public PluginStorePageViewModel()
    {
        NavgationToMenuPageCommand = ReactiveCommand.Create<TabItemViewModel>(NavgationToMenuPage);
    }

    public void NavgationToMenuPage(TabItemViewModel tabItem)
    {
        INavigationService.Instance.Navigate(tabItem.PageType, NavigationTransitionEffect.FromBottom);
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\UI\ViewModels\Pages\SettingsPageViewModel.cs
/ </summary>
    
/ <param name="isStartCacheSizeCalc"></param>
    
/ <param name="sizeFormat"></param>
    
/ <param name="action"></param>
    
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\UI\ViewModels\Pages\SettingsPageViewModel.props.cs
/BD.WTTS.Client.Avalonia/UI/Assets/Icons/settings.ico";

    public static string? SelectLanguageKey { get; private set; }

    KeyValuePair<string, string> _SelectLanguage;

    public KeyValuePair<string, string> SelectLanguage
    {
        get => _SelectLanguage;
        set
        {
            this.RaiseAndSetIfChanged(ref _SelectLanguage, value);
            SelectLanguageKey = value.Key;
        }
    }

    KeyValuePair<string, string> _SelectFont;

    public KeyValuePair<string, string> SelectFont
    {
        get => _SelectFont;
        set => this.RaiseAndSetIfChanged(ref _SelectFont, value);
    }

    MenuTabItemViewModel _SelectDefaultPage =
        IViewModelManager.Instance.MainWindow2.TabItems.OfType<MenuTabItemViewModel>().FirstOrDefault(
            s =>
            {
                if (string.IsNullOrEmpty(UISettings.StartDefaultPageName.Value))
                {
                    return s.Id == "Watt Toolkit-Welcome";
                }
                return s.Id == UISettings.StartDefaultPageName.Value;
            });

    [IgnoreDataMember, MPIgnore, MP2Ignore, N_JsonIgnore, S_JsonIgnore]
    public MenuTabItemViewModel SelectDefaultPage
    {
        get => _SelectDefaultPage;
        set
        {
            this.RaiseAndSetIfChanged(ref _SelectDefaultPage, value);
            if (!string.IsNullOrEmpty(value?.Id))
            {
                UISettings.StartDefaultPageName.Value = value.Id;
            }
        }
    }

    [IgnoreDataMember, MPIgnore, MP2Ignore, N_JsonIgnore, S_JsonIgnore]
    public ICommand? SelectImage_Click { get; }

    [IgnoreDataMember, MPIgnore, MP2Ignore, N_JsonIgnore, S_JsonIgnore]
    public ICommand? ResetImage_Click { get; }

    [IgnoreDataMember, MPIgnore, MP2Ignore, N_JsonIgnore, S_JsonIgnore]
    public ICommand? OpenFolder_Click { get; }

    
/ </summary>
    const double clickOpenFolderIntervalSeconds = 7.5d;
    readonly Dictionary<string, DateTime> clickOpenFolderTimeRecord = new();

    public static string[] GetThemes() => new[]
    {
        AppResources.Settings_UI_SystemDefault,
        AppResources.Settings_UI_Light,
        AppResources.Settings_UI_Dark,
    };

    [Reactive]
    public ObservableCollection<PluginResult<IPlugin>>? Plugins { get; set; }

    [IgnoreDataMember, MPIgnore, MP2Ignore, N_JsonIgnore, S_JsonIgnore]
    public ICommand? DeletePlugin_Click { get; }

    [IgnoreDataMember, MPIgnore, MP2Ignore, N_JsonIgnore, S_JsonIgnore]
    public ICommand? CheckUpdate_Click { get; }

    [IgnoreDataMember, MPIgnore, MP2Ignore, N_JsonIgnore, S_JsonIgnore]
    public ICommand? OpenPluginDirectory_Click { get; }

    [IgnoreDataMember, MPIgnore, MP2Ignore, N_JsonIgnore, S_JsonIgnore]
    public ICommand? OpenPluginCacheDirectory_Click { get; }

    [IgnoreDataMember, MPIgnore, MP2Ignore, N_JsonIgnore, S_JsonIgnore]
    public ICommand? SwitchEnablePlugin_Click { get; }

}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\UI\ViewModels\Windows\ContentWindowViewModel.cs
/ </summary>
    [Reactive]
    public object? PageViewModel { get; set; }

    
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\UI\ViewModels\Windows\DialogWindowViewModel.cs
/ </summary>
    
/ <returns></returns>
    public virtual bool OnOKClickCanClose()
    {
        if (this is ITextBoxWindowViewModel viewModel_tb)
        {
            if (!viewModel_tb.InputValidator()) 
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\UI\ViewModels\Windows\LoginOrRegisterWindowViewModel.props.cs
/ </summary>
    
/ <param name="id"></param>
    
/ <param name="vm"></param>
    
/ <returns></returns>
    public static ExternalLoginChannelViewModel Create(string id, IDisposableHolder vm)
    {
        ExternalLoginChannelViewModel r = new() { Id = id, };
        r.OnBind(vm);
        return r;
    }
}

public partial class LoginOrRegisterWindowViewModel
{
    public const string Agreement = "Agreement";
    public const string Privacy = "Privacy";

    [Reactive]
    public string? CurrentSelectChannel { get; set; }

    [Reactive]
    public string? PhoneNumber { get; set; }

    [Reactive]
    public string? SmsCode { get; set; }

    private int _TimeLimit = SMSInterval;

    public int TimeLimit
    {
        get => _TimeLimit;
        set
        {
            this.RaiseAndSetIfChanged(ref _TimeLimit, value);
            this.RaisePropertyChanged(nameof(IsUnTimeLimit));
        }
    }

    public static string DefaultBtnSendSmsCodeText => Strings.User_GetSMSCode;

    [Reactive]
    public string BtnSendSmsCodeText { get; set; } = DefaultBtnSendSmsCodeText;

    public bool IsUnTimeLimit => TimeLimit != SMSInterval;

    public bool SendSmsCodeSuccess { get; set; }

    [Reactive]
    public bool IsLoading { get; set; }

    [Reactive]
    public bool IsFastLogin { get; set; }

    [Reactive]
    public short LoginState { get; set; }

    
/ 选择快速登录渠道点击命令，参数类型为 <see cref="FastLoginChannelViewModel"/>.Id
    
/ </summary>
    public ICommand ChooseChannel { get; }

    
/ </summary>
    [Reactive]
    public ObservableCollection<ExternalLoginChannelViewModel> ExternalLoginChannels { get; set; }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\UI\ViewModels\Windows\TextBoxWindowViewModel.cs
/ </summary>
    public string? Value
    {
        get => _Value;
        set => this.RaiseAndSetIfChanged(ref _Value, value);
    }

    
/ </summary>
    public string? Placeholder
    {
        get => _Placeholder;
        set => this.RaiseAndSetIfChanged(ref _Placeholder, value);
    }

    private string? _Placeholder;

    private string? _Description;

    
/ </summary>
    public string? Description
    {
        get => _Description;
        set => this.RaiseAndSetIfChanged(ref _Description, value);
    }

    
/ </summary>
    public int MaxLength
    {
        get => _MaxLength;
        set => this.RaiseAndSetIfChanged(ref _MaxLength, value);
    }

    private int _MaxLength;

    
/ <inheritdoc cref="TextBoxInputType"/>
    public TextBoxInputType InputType { get; set; }

    
/ 输入空值时提示，<see cref="string.IsNullOrWhiteSpace(string?)"/> == <see langword="true"/> 时，在 <see cref="InputValidator"/> 中会判断输入空值时提示并取消关闭弹窗操作
    
/ </summary>
    public string? ValueIsNullOrWhiteSpaceTip { get; set; }

    
/ 输入空值时提示，<see cref="string.IsNullOrEmpty(string?)"/> == <see langword="true"/> 时，在 <see cref="InputValidator"/> 中会判断输入空值时提示并取消关闭弹窗操作
    
/ </summary>
    public string? ValueIsNullOrEmptyTip { get; set; }

    
/ </summary>
    
/ <returns></returns>
    public bool InputValidator()
    {
        if (ValueIsNullOrWhiteSpaceTip != null && string.IsNullOrWhiteSpace(Value))
        {
            Toast.Show(ToastIcon.Warning, ValueIsNullOrWhiteSpaceTip);
            return false;
        }
        else if (ValueIsNullOrEmptyTip != null && string.IsNullOrEmpty(Value))
        {
            Toast.Show(ToastIcon.Warning, ValueIsNullOrEmptyTip);
            return false;
        }
        return true;
    }

    
/ 显示弹窗，点击取消按钮回返回 <see langword="null"/>
    
/ </summary>
    
/ <param name="vm"></param>
    
/ <returns></returns>
    public static async Task<string?> ShowDialogAsync(TextBoxWindowViewModel? vm = null)
    {
        vm ??= new TextBoxWindowViewModel();
        var r = await IWindowManager.Instance.ShowTaskDialogAsync(vm, vm.Title, subHeader: vm.Description, isCancelButton: true);
        if (r)
            return vm.Value ?? string.Empty;
        return null;
    }

    
/ <inheritdoc cref="ShowDialogAsync(TextBoxWindowViewModel?)"/>
    public static Task<string?> ShowDialogByPresetAsync(PresetType type) => type switch
    {
        PresetType.LocalAuth_PasswordRequired => ShowDialogAsync(new()
        {
            Title = AppResources.LocalAuth_PasswordRequired,
            Placeholder = AppResources.LocalAuth_PasswordRequired1,
            ValueIsNullOrEmptyTip = AppResources.LocalAuth_ProtectionAuth_PasswordErrorTip,
            InputType = TextBoxInputType.Password,
        }),
        _ => ShowDialogAsync(),
    };

    
/ </summary>
    public enum TextBoxInputType
    {
        TextBox,
        Password,
        ReadOnlyText,
    }

    public enum PresetType
    {
        LocalAuth_PasswordRequired,
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\UI\ViewModels\Windows\WindowViewModel.cs
/ </summary>
    public virtual Action<bool>? Close { get; set; }

    
/ </summary>
    public virtual Action Show { get; set; }

    
/ </summary>
    public virtual void Hide() => windowManager.HideWindow(this);

    public virtual void OnClosing(object? sender, CancelEventArgs e) { }
}

发现条件编译指令：../SteamTools\src\BD.WTTS.Client\UI\ViewModels\Windows\Main\MainWindowViewModel.cs
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client\UI\Widgets\MessageBox.cs
/ </summary>
public static partial class MessageBox
{
    
/ 指定显示在消息框上的按钮。 用作 <see cref="MessageBox"/>.Show... 方法的参数
    
/ </summary>
    public enum Button
    {
        OK = 0,
        OKCancel = 1,

        [Obsolete("non-standard api")]
        YesNo = 4,
        [Obsolete("non-standard api")]
        YesNoCancel = 3,
        [Obsolete("non-standard api")]
        OkAbort = 1000,
        [Obsolete("non-standard api")]
        YesNoAbort = 1001,
    }

    
/ </summary>
    public enum Image
    {
        Asterisk = 64,
        Error = 16,
        Exclamation = 48,
        Hand = 16,
        Information = 64,
        None = 0,
        [Obsolete("The question mark message icon is no longer recommended because it does not clearly represent a specific type of message and because the phrasing of a message as a question could apply to any message type. In addition, users can confuse the question mark symbol with a help information symbol. Therefore, do not use this question mark symbol in your message boxes. The system continues to support its inclusion only for backward compatibility.")]
        Question = 32,
        Stop = 16,
        Warning = 48,

        [Obsolete("non-standard api")]
        Battery = 1000,
        [Obsolete("non-standard api")]
        Database,
        [Obsolete("non-standard api")]
        Folder,
        [Obsolete("non-standard api")]
        Forbidden,
        [Obsolete("non-standard api")]
        Plus,
        [Obsolete("non-standard api")]
        Setting,
        [Obsolete("non-standard api")]
        SpeakerLess,
        [Obsolete("non-standard api")]
        SpeakerMore,
        [Obsolete("non-standard api")]
        Stop2,
        [Obsolete("non-standard api")]
        Stopwatch,
        [Obsolete("non-standard api")]
        Wifi,
    }

    
/ 指定弹框是否可选不再显示。 用作 <see cref="MessageBox"/>.Show... 方法的参数。
    
/ </summary>
    public enum DontPromptType
    {
        Undefined = 0,

        
/ </summary>
        UnLockAchievement = 1,

        
/ </summary>
        Donate = 2,

        ResetHostsFile,

        SaveEditAppInfo,

        AndroidCertificateTrustTip,
    }

    
/ 指定用户单击的消息框按钮。 由 <see cref="MessageBox"/>.Show... 方法返回。
    
/ </summary>
    public enum Result
    {
        Cancel = 2,
        None = 0,
        OK = 1,

        [Obsolete("non-standard api")]
        Yes = 6,
        [Obsolete("non-standard api")]
        No = 7,
        [Obsolete("non-standard api")]
        Abort = 1000,
    }

    const string default_caption = AssemblyInfo.Trademark;
    const Button default_button = Button.OK;
    static readonly IMessageBoxService? mbcs = IMessageBoxService.Instance;
    public const Button OKCancel = Button.OKCancel;

    
/ <inheritdoc cref="IMessageBoxService.ShowAsync(string, string, Button, Image)"/>
    public static async Task<Result> ShowAsync(
        string messageBoxText, string caption = default_caption, Button button = default_button, Image icon = default, DontPromptType rememberChooseKey = default)
    {
        if (mbcs != null)
        {
            return await mbcs.ShowAsync(messageBoxText, caption, button, icon);
        }

        var isDoNotShow = rememberChooseKey != DontPromptType.Undefined;

        if (isDoNotShow &&
            UISettings.MessageBoxDontPrompts.Contains(rememberChooseKey))
        {
            return Result.OK;
        }

        var viewModel = new MessageBoxWindowViewModel
        {
            Content = messageBoxText,
            IsCancelcBtn = button == OKCancel,
            IsShowRememberChoose = isDoNotShow,
        };

        var r = await IWindowManager.Instance.ShowTaskDialogAsync(
            viewModel, caption, isDialog: false, isCancelButton: viewModel.IsCancelcBtn);

        if (r && viewModel.RememberChoose && isDoNotShow)
        {
            UISettings.MessageBoxDontPrompts.Add(rememberChooseKey);
        }

        return r ? Result.OK : Result.Cancel;
    }

    
/ <inheritdoc cref="IMessageBoxService.ShowAsync(string, string, Button, Image)"/>
    public static async void Show(string messageBoxText, string caption = default_caption, Button button = default_button, Image icon = default, DontPromptType rememberChooseKey = default)
    {
        await ShowAsync(messageBoxText, caption, button, icon, rememberChooseKey);
    }

    
/ <inheritdoc cref="IMessageBoxService.ShowAsync(string, string, Button, Image)"/>
    
/ <inheritdoc cref="IMessageBoxService.ShowAsync(string, string, Button, Image)"/>
    public static void Show(Exception exception, string caption = default_caption, Button button = default_button, Image icon = default)
    {
        var messageBoxText = exception.GetAllMessage();
        Show(messageBoxText, caption, button, icon);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsOK(this Result r) => r == Result.OK;
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.AppHost\MessageBox.cs
/github.com/dotnet/wpf/blob/v6.0.6/src/Microsoft.DotNet.Wpf/src/PresentationFramework/System/Windows/MessageBox.cs

#if NET7_0_OR_GREATER || NETFRAMEWORK

namespace MS.Win32;

public static partial class MessageBox
{
    const uint DEFAULT_BUTTON1 = 0x00000000;
    const uint DEFAULT_BUTTON2 = 0x00000100;
    const uint DEFAULT_BUTTON3 = 0x00000200;

    sealed partial class User32
    {
#if NET7_0_OR_GREATER
        [LibraryImport(nameof(User32), SetLastError = true)]
        public static partial IntPtr GetActiveWindow();

        [LibraryImport(nameof(User32), EntryPoint = "MessageBoxW", StringMarshalling = StringMarshalling.Utf16)]
        public static partial MessageBoxResult MessageBox(IntPtr hWnd, string text, string caption, uint options);
#elif NETFRAMEWORK
        [DllImport("user32.dll", ExactSpelling = true, CharSet = CharSet.Auto)]
        [ResourceExposure(ResourceScope.Process)]
        public static extern IntPtr GetActiveWindow();

        [DllImport("user32.dll", EntryPoint = "MessageBoxW", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern MessageBoxResult MessageBox(IntPtr hWnd, string text, string caption, uint type);

#endif
    }

#if NET35 || NET40
    [MethodImpl((MethodImplOptions)0x100)]
#else
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static MessageBoxResult Show(
            string messageBoxText,
            string caption,
            MessageBoxButton button,
            MessageBoxImage icon,
            MessageBoxResult defaultResult,
            MessageBoxOptions options) => ShowCore(IntPtr.Zero, messageBoxText, caption, button, icon, defaultResult, options);

#if NET35 || NET40
    [MethodImpl((MethodImplOptions)0x100)]
#else
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static MessageBoxResult Show(
          string messageBoxText,
          string caption,
          MessageBoxButton button,
          MessageBoxImage icon,
          MessageBoxResult defaultResult) => ShowCore(IntPtr.Zero, messageBoxText, caption, button, icon, defaultResult, 0);

#if NET35 || NET40
    [MethodImpl((MethodImplOptions)0x100)]
#else
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static MessageBoxResult Show(
         string messageBoxText,
         string caption,
         MessageBoxButton button,
         MessageBoxImage icon) => ShowCore(IntPtr.Zero, messageBoxText, caption, button, icon, 0, 0);

#if NET35 || NET40
    [MethodImpl((MethodImplOptions)0x100)]
#else
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static MessageBoxResult Show(
          string messageBoxText,
          string caption,
          MessageBoxButton button) => ShowCore(IntPtr.Zero, messageBoxText, caption, button, MessageBoxImage.None, 0, 0);

#if NET35 || NET40
    [MethodImpl((MethodImplOptions)0x100)]
#else
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static MessageBoxResult Show(string messageBoxText, string caption) => ShowCore(IntPtr.Zero, messageBoxText, caption, MessageBoxButton.OK, MessageBoxImage.None, 0, 0);

#if NET35 || NET40
    [MethodImpl((MethodImplOptions)0x100)]
#else
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    public static MessageBoxResult Show(string messageBoxText) => ShowCore(IntPtr.Zero, messageBoxText, string.Empty, MessageBoxButton.OK, MessageBoxImage.None, 0, 0);

#if NET35 || NET40
    [MethodImpl((MethodImplOptions)0x100)]
#else
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    static uint DefaultResultToButtonNumber(MessageBoxResult result, MessageBoxButton button)
    {
        if (result == 0) return DEFAULT_BUTTON1;

        switch (button)
        {
            case MessageBoxButton.OK:
                return DEFAULT_BUTTON1;
            case MessageBoxButton.OKCancel:
                if (result == MessageBoxResult.Cancel) return DEFAULT_BUTTON2;
                return DEFAULT_BUTTON1;
            case MessageBoxButton.YesNo:
                if (result == MessageBoxResult.No) return DEFAULT_BUTTON2;
                return DEFAULT_BUTTON1;
            case MessageBoxButton.YesNoCancel:
                if (result == MessageBoxResult.No) return DEFAULT_BUTTON2;
                if (result == MessageBoxResult.Cancel) return DEFAULT_BUTTON3;
                return DEFAULT_BUTTON1;
            default:
                return DEFAULT_BUTTON1;
        }
    }

    internal static MessageBoxResult ShowCore(
           IntPtr owner,
           string messageBoxText,
           string caption,
           MessageBoxButton button,
           MessageBoxImage icon,
           MessageBoxResult defaultResult,
           MessageBoxOptions options)
    {
        if (!IsValidMessageBoxButton(button))
        {
            throw new InvalidEnumArgumentException("button", (int)button, typeof(MessageBoxButton));
        }
        if (!IsValidMessageBoxImage(icon))
        {
            throw new InvalidEnumArgumentException("icon", (int)icon, typeof(MessageBoxImage));
        }
        if (!IsValidMessageBoxResult(defaultResult))
        {
            throw new InvalidEnumArgumentException("defaultResult", (int)defaultResult, typeof(MessageBoxResult));
        }
        if (!IsValidMessageBoxOptions(options))
        {
            throw new InvalidEnumArgumentException("options", (int)options, typeof(MessageBoxOptions));
        }

        
/
        /*if (!SystemInformation.UserInteractive && (options & (MessageBoxOptions.ServiceNotification | MessageBoxOptions.DefaultDesktopOnly)) == 0) {
            throw new InvalidOperationException("UNDONE: SR.GetString(SR.CantShowModalOnNonInteractive)");
        }*/

        if ((options & (MessageBoxOptions.ServiceNotification | MessageBoxOptions.DefaultDesktopOnly)) != 0)
        {
            if (owner != IntPtr.Zero)
            {
                throw new ArgumentException("Cannot show MessageBox Service with Owner.");
            }
        }
        else
        {
            if (owner == IntPtr.Zero)
            {
                owner = User32.GetActiveWindow();
            }
        }

        uint style = (uint)button | (uint)icon | DefaultResultToButtonNumber(defaultResult, button) | (uint)options;

        
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.AppHost\MessageBox.cs
NET
NET
NET
NET
NET
NET
NET
NET
NET
NET
NET
NET
NET
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.AppHost\NativeLibrary.cs
/www.pinvoke.net/default.aspx/kernel32.LoadLibrary
    
/learn.microsoft.com/zh-cn/dotnet/api/system.runtime.interopservices.nativelibrary.load</para>
    
/ </summary>
    
/ <param name="lpFileName"></param>
    
/ <returns></returns>
    [DllImport("kernel32", EntryPoint = "LoadLibraryW", SetLastError = true, CharSet = CharSet.Unicode)]
    public static extern nint Load([MarshalAs(UnmanagedType.LPWStr)] string lpFileName);

    
/www.pinvoke.net/default.aspx/kernel32.GetProcAddress
    
/learn.microsoft.com/zh-cn/dotnet/api/system.runtime.interopservices.nativelibrary.getexport</para>
    
/ </summary>
    
/ <param name="hModule"></param>
    
/ <param name="procName"></param>
    
/ <returns></returns>
    [DllImport("kernel32", EntryPoint = "GetProcAddress", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
    public static extern nint GetExport(nint hModule, [MarshalAs(UnmanagedType.LPStr)] string procName);

    
/www.pinvoke.net/default.aspx/kernel32/FreeLibrary.html
    
/learn.microsoft.com/zh-cn/dotnet/api/system.runtime.interopservices.nativelibrary.free</para>
    
/ </summary>
    
/ <param name="hModule"></param>
    
/ <returns></returns>
    
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.AppHost\NativeLibrary.cs
NETFRAMEWORK
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.AppHost\Net35.cs
/www.codeproject.com/questions/641314/check-64-or-32-bit-in-net-3-5

    
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.AppHost\Net35.cs
NET
NET
NET
NET
NET
NET
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.AppHost\Program.cs
/github.com/dotnet/runtime/blob/main/docs/design/features/host-error-codes.md

/github.com/dotnet/samples/blob/91355ef22a10ec614a2e8daefd68785066860d57/core/hosting/src/NativeHost/nativehost.cpp

#if NETFRAMEWORK
using System.Configuration;
#endif
using static BD.WTTS.AssemblyInfo;
using static BD.WTTS.Client.Resources.Strings;


/ </summary>
    
/ <returns></returns>
    
/ </summary>
    
/ <returns></returns>
#if NET35 || NET40
    [MethodImpl((MethodImplOptions)0x100)]
#else
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    static Architecture GetProcessArchitecture()
    {
        Architecture processArchitecture;
#if NET471_OR_GREATER || NETCOREAPP
        processArchitecture = RuntimeInformation.ProcessArchitecture;
#else
        try
        {
            processArchitecture = (Architecture)Type.GetType("System.Runtime.InteropServices.RuntimeInformation").GetProperty("ProcessArchitecture", BindingFlags.Public | BindingFlags.Static).GetValue(null, null);
        }
        catch
        {
            processArchitecture =
#if NET35
                IntPtr.Size == 8
#else
                Environment.Is64BitProcess
#endif
                ? Architecture.X64 : Architecture.X86;
        }
#endif
        return processArchitecture;
    }

    
/ </summary>
    
/ <param name="architecture"></param>
    
/ <returns></returns>
    
/ <exception cref="ArgumentOutOfRangeException"></exception>
#if NET35 || NET40
    [MethodImpl((MethodImplOptions)0x100)]
#else
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    static string ToString(Architecture architecture) => architecture switch
    {
        Architecture.X86 => "x86",
        Architecture.X64 => "x64",
        Architecture.Arm => "Arm32",
        Architecture.Arm64 => "Arm64",
#if !NETFRAMEWORK
        Architecture.Armv6 => "Armv6",
#endif
        _ => throw new ArgumentOutOfRangeException(nameof(architecture), architecture, null),
    };

#if NET35 || NET40
    [MethodImpl((MethodImplOptions)0x100)]
#else
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    static void OpenCoreByProcess(string url)
    {
        try
        {
            var psi = new ProcessStartInfo(url)
            {
                UseShellExecute = true,
            };
            Process.Start(psi);
        }
        catch (Win32Exception e)
        {
            var text = string.Format(OpenCoreByProcess_Win32Exception_,
                Convert.ToString(e.NativeErrorCode, 16));
            ShowErrMessageBox(text);
        }
    }

    
/ </summary>
#if NET35 || NET40
    [MethodImpl((MethodImplOptions)0x100)]
#else
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
    static void DownloadDotNetRuntime()
    {
        string urlFormat1 = $"https:
/dotnet.microsoft.com/{{0}}/download/dotnet/{dotnet_version_major}.{dotnet_version_minor}";
        var url = string.Format(urlFormat1, GetLang());
        OpenCoreByProcess(url);
    }

    enum DotNetRootType : byte
    {
        BaseDir,
#if NETFRAMEWORK || WINDOWS
        ProgramFiles,
#endif
        EnvironmentVariable,
    }

#if NET40_OR_GREATER
    [System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptions]
#endif
    [STAThread]
    static int Main(string[] args)
#if DEBUG
    {
        try
        {
            var exitCode = MainCore(args);
            Console.ReadLine();
            return exitCode;
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex);
            Console.ReadLine();
            return (int)ExitCode.InternalServerError;
        }
    }
#endif

#if DEBUG
    static int MainCore(string[] args)
#endif
    {
        
/learn.microsoft.com/zh-cn/dotnet/core/runtime-config/garbage-collector#conserve-memory
        Environment.SetEnvironmentVariable("DOTNET_GCConserveMemory", "9", EnvironmentVariableTarget.Process);

#if DEBUG
        Console.WriteLine($"Environment.Version: {Environment.Version}");
#endif

#if NETFRAMEWORK
        try
        {
            var dotnet_version_ = ConfigurationManager.AppSettings["d"];
            if (!
#if !NET35
                string.
#endif
                IsNullOrWhiteSpace(dotnet_version_) &&
                dotnet_version_.Length < sbyte.MaxValue)
            {
                var dotnet_version__ = dotnet_version_.Split('.');
                int major, minor, build;
                switch (dotnet_version__.Length)
                {
                    case 1:
                        dotnet_version_major = (int.TryParse(dotnet_version__[0], out major) ? major : 0).ToString();
                        dotnet_version_minor = dotnet_version_build = "0";
                        dotnet_version = $"{dotnet_version_major}.0.0";
                        break;
                    case 2:
                        dotnet_version_major = (int.TryParse(dotnet_version__[0], out major) ? major : 0).ToString();
                        dotnet_version_minor = (int.TryParse(dotnet_version__[1], out minor) ? minor : 0).ToString();
                        dotnet_version_build = "0";
                        dotnet_version = $"{dotnet_version_major}.{dotnet_version_minor}.0";
                        break;
                    case 3:
                        dotnet_version_major = (int.TryParse(dotnet_version__[0], out major) ? major : 0).ToString();
                        dotnet_version_minor = (int.TryParse(dotnet_version__[1], out minor) ? minor : 0).ToString();
                        dotnet_version_build = (int.TryParse(dotnet_version__[2], out build) ? build : 0).ToString();
                        dotnet_version = $"{dotnet_version_major}.{dotnet_version_minor}.{dotnet_version_build}";
                        break;
                }
            }
        }
        catch
        {

        }

        if (dotnet_version == default)
            return (int)ExitCode.Failure_read_dotnet_version;
#endif

        var baseDirectory =
#if NET46_OR_GREATER || NETCOREAPP
                AppContext.BaseDirectory;
#else
                AppDomain.CurrentDomain.BaseDirectory;
#endif

        if (args.Length == 0 && !CompatibilityCheck(baseDirectory))
            return 0;

        
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.AppHost\Program.cs
NETFRAMEWORK
NETFRAMEWORK
NET
NETFRAMEWORK
NET
NET
NET
NET
NET
NET
NET
NETFRAMEWORK
NET
DEBUG
DEBUG
DEBUG
NETFRAMEWORK
NET
NETFRAMEWORK
NET
NET
NETFRAMEWORK
NET
NET
NET
NET
DEBUG
NET
NET
NETFRAMEWORK
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.AppHost\Strings.cs
NET
NET
NET
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\Behaviors\AdaptiveBehavior.cs
/ Observes <see cref="Behavior{T}.AssociatedObject"/> control or <see cref="SourceControl"/> control <see cref="Visual.Bounds"/> property changes and if triggered sets or removes style classes when conditions from <see cref="AdaptiveClassSetter"/> are met.

/ </summary>
public class AdaptiveBehavior : Behavior<Control>
{
    private IDisposable? _disposable;
    private AvaloniaList<AdaptiveClassSetter>? _setters;

    
/ Identifies the <seealso cref="SourceControl"/> avalonia property.
    
/ </summary>
    public static readonly StyledProperty<Control?> SourceControlProperty =
        AvaloniaProperty.Register<AdaptiveBehavior, Control?>(nameof(SourceControl));

    
/ Identifies the <seealso cref="TargetControl"/> avalonia property.
    
/ </summary>
    public static readonly StyledProperty<Control?> TargetControlProperty =
        AvaloniaProperty.Register<AdaptiveBehavior, Control?>(nameof(TargetControl));

    
/ Identifies the <seealso cref="Setters"/> avalonia property.
    
/ </summary>
    public static readonly DirectProperty<AdaptiveBehavior, AvaloniaList<AdaptiveClassSetter>> SettersProperty =
        AvaloniaProperty.RegisterDirect<AdaptiveBehavior, AvaloniaList<AdaptiveClassSetter>>(nameof(Setters), t => t.Setters);

    
/ Gets or sets the the source control that <see cref="Visual.BoundsProperty"/> property are observed from, if not set <see cref="Behavior{T}.AssociatedObject"/> is used. This is a avalonia property.
    
/ </summary>
    [ResolveByName]
    public Control? SourceControl
    {
        get => GetValue(SourceControlProperty);
        set => SetValue(SourceControlProperty, value);
    }

    
/ Gets or sets the target control that class name that should be added or removed when triggered, if not set <see cref="Behavior{T}.AssociatedObject"/> is used or <see cref="AdaptiveClassSetter.TargetControl"/> from <see cref="AdaptiveClassSetter"/>. This is a avalonia property.
    
/ </summary>
    [ResolveByName]
    public Control? TargetControl
    {
        get => GetValue(TargetControlProperty);
        set => SetValue(TargetControlProperty, value);
    }

    
/ </summary>
    [Content]
    public AvaloniaList<AdaptiveClassSetter> Setters => _setters ??= new AvaloniaList<AdaptiveClassSetter>();

    
/ <inheritdoc/>
    protected override void OnAttachedToVisualTree()
    {
        base.OnAttachedToVisualTree();

        StopObserving();
        StartObserving();
    }

    
/ <inheritdoc/>
    protected override void OnDetachedFromVisualTree()
    {
        base.OnDetachedFromVisualTree();

        StopObserving();
    }

    private void StartObserving()
    {
        var sourceControl = GetValue(SourceControlProperty) is not null
            ? SourceControl
            : AssociatedObject;

        if (sourceControl is not null)
        {
            _disposable = ObserveBounds(sourceControl);
        }
    }

    private void StopObserving()
    {
        _disposable?.Dispose();
    }

    private IDisposable ObserveBounds(Control sourceControl)
    {
        if (sourceControl is null)
        {
            throw new ArgumentNullException(nameof(sourceControl));
        }

        return sourceControl.GetObservable(Visual.BoundsProperty)
            .Subscribe(new AnonymousObserver<Rect>(bounds => ValueChanged(sourceControl, Setters, bounds)));
    }

    private void ValueChanged(Control? sourceControl, AvaloniaList<AdaptiveClassSetter>? setters, Rect bounds)
    {
        if (sourceControl is null || setters is null)
        {
            return;
        }

        foreach (var setter in setters)
        {
            var isMinOrMaxWidthSet = setter.IsSet(AdaptiveClassSetter.MinWidthProperty)
                                     || setter.IsSet(AdaptiveClassSetter.MaxWidthProperty);
            var widthConditionTriggered = GetResult(setter.MinWidthOperator, bounds.Width, setter.MinWidth)
                                          && GetResult(setter.MaxWidthOperator, bounds.Width, setter.MaxWidth);

            var isMinOrMaxHeightSet = setter.IsSet(AdaptiveClassSetter.MinHeightProperty)
                                      || setter.IsSet(AdaptiveClassSetter.MaxHeightProperty);
            var heightConditionTriggered = GetResult(setter.MinHeightOperator, bounds.Height, setter.MinHeight)
                                           && GetResult(setter.MaxHeightOperator, bounds.Height, setter.MaxHeight);

            var isAddClassTriggered = isMinOrMaxWidthSet switch
            {
                true when !isMinOrMaxHeightSet => widthConditionTriggered,
                false when isMinOrMaxHeightSet => heightConditionTriggered,
                true when isMinOrMaxHeightSet => widthConditionTriggered && heightConditionTriggered,
                _ => false
            };

            var targetControl = setter.GetValue(AdaptiveClassSetter.TargetControlProperty) is not null
                ? setter.TargetControl
                : GetValue(TargetControlProperty) is not null
                    ? TargetControl
                    : AssociatedObject;

            if (targetControl is not null)
            {
                var className = setter.ClassName;
                var isPseudoClass = setter.IsPseudoClass;

                if (isAddClassTriggered)
                {
                    Add(targetControl, className, isPseudoClass);
                }
                else
                {
                    Remove(targetControl, className, isPseudoClass);
                }
            }
        }
    }

    private bool GetResult(ComparisonConditionType comparisonConditionType, double property, double value)
    {
        return comparisonConditionType switch
        {
            
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Avalonia\Converters\BitmapAssetValueConverter.cs
AVALONIA
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\Converters\ImageValueConverter.cs
/ 将 图片源(流) 转换为 <see cref="SKBitmap"/>(Skia)
    
/ </summary>
    
/ <param name="clipStream"></param>
    
/ <param name="bitmap"></param>
    
/ <returns></returns>
    static bool TryGetBitmap([NotNullWhen(true)] ImageSource.ClipStream? clipStream, [NotNullWhen(true)] out SKBitmap? bitmap)
    {
        if (clipStream?.Stream == null)
        {
            bitmap = null;
            return false;
        }

        var filename = clipStream.Name;
        if (filename != null)
        {
            bitmap = SKBitmap.Decode(filename);
        }
        else
        {
            TryReset(clipStream.Stream);
            using var ms = new MemoryStream();
            clipStream.Stream.CopyTo(ms);
            TryReset(ms);
            bitmap = SKBitmap.Decode(ms);
        }
        return true;
    }

    
/ 将 图片源(流) 根据预设参数处理并转换为 <see cref="Bitmap"/>(Avalonia)
    
/ </summary>
    
/ <param name="clipStream"></param>
    
/ <param name="width"></param>
    
/ <returns></returns>
    
/        new SKRoundRect(rect, bitmapSource.Width / 2f, bitmapSource.Height / 2f) :
    
/ 将 <see cref="SKBitmap"/>(Skia) 转换为 <see cref="Bitmap"/>(Avalonia)
    
/ </summary>
    
/ <param name="s"></param>
    
/ <param name="width"></param>
    
/ <returns></returns>
    
/ 将 <see cref="Stream"/> 转换为 <see cref="Bitmap"/>(Avalonia)
    
/ </summary>
    
/ <param name="s"></param>
    
/ <param name="width"></param>
    
/ <returns></returns>
    [return: NotNullIfNotNull("s")]
    protected static Bitmap? GetDecodeBitmap(Stream? s, int width)
    {
        if (s == null)
        {
            return null;
        }
        if (width < 1)
        {
            return new Bitmap(s);
        }
        return Bitmap.DecodeToWidth(s, width, BitmapInterpolationMode.MediumQuality);
    }

    
/ 将 <see cref="string"/>(filePath) 转换为 <see cref="Bitmap"/>(Avalonia)
    
/ </summary>
    
/ <param name="s"></param>
    
/ <param name="width"></param>
    
/ <returns></returns>
    [return: NotNullIfNotNull("s")]
    protected static Bitmap? GetDecodeBitmap(string? s, int width)
    {
        #region Obsolete

        
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\Converters\Abstractions\IBinding.cs
/ <inheritdoc cref="CommonCA.IBinding.DoNothing"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static object DoNothing(this CommonCA.IBinding _)
#if AVALONIA
        => BindingOperations.DoNothing;
#endif

    
/ <inheritdoc cref="CommonCA.IBinding.UnsetValue"/>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static object UnsetValue(this CommonCA.IBinding _)
#if AVALONIA
        => BindingValueType.UnsetValue;
#endif
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Avalonia\Converters\Abstractions\IBinding.cs
AVALONIA
AVALONIA
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Avalonia\Converters\Abstractions\IMultiValueConverter.cs
AVALONIA
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Avalonia\Converters\Abstractions\IValueConverter.cs
AVALONIA
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\Converters\WaveProgress\WaveProgressValueConverter.cs
/ <inheritdoc/>
    public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        if (value is not double i) return 0;
        return 155 - (i * 2.1);
    }

    
/ <inheritdoc/>
    public object ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        return BindingOperations.DoNothing;
    }
}

public class WaveProgressValueColorConverter : IValueConverter
{
    public static readonly WaveProgressValueColorConverter Instance = new();

    
/ <inheritdoc/>
    public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        if (value is not double d) return Brushes.Black;
        if (d > 50) return Brushes.GhostWhite;
        return Application.Current?.ActualThemeVariant == ThemeVariant.Dark ? Brushes.GhostWhite : Brushes.Black;
    }

    
/ <inheritdoc/>
    public object ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        return BindingOperations.DoNothing;
    }
}

public class WaveProgressValueTextConverter : IValueConverter
{
    public static readonly WaveProgressValueTextConverter Instance = new();

    
/ <inheritdoc/>
    public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        return value is not double d ? "0%" : $"{d:#0}%";
    }

    
/ <inheritdoc/>
    public object ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        return BindingOperations.DoNothing;
    }
}

public class WaveProgressGradientOffsetConverter : IValueConverter
{
    public static readonly WaveProgressGradientOffsetConverter Instance = new();

    
/ <inheritdoc/>
    public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        if (value is not double v)
            return Brushes.Blue;

        var app = Application.Current;
        if (app == null)
            return null;

        Color primaryColor = Colors.DodgerBlue;
        Color accentColor = Colors.Transparent;

        try
        {
            if (app.FindResource("SystemAccentColor") is Color primaryColor2)
            {
                primaryColor = primaryColor2;
            }
            if (app.FindResource("SystemAccentColorLight2") is Color accentColor2)
            {
                accentColor = accentColor2;
            }
        }
        catch { }

        var isLight = app.RequestedThemeVariant == ThemeVariant.Light;

        v /= 100;
        v += isLight ? 0.2 : 0.4;
        if (v > 1)
            v = 1;

        return new LinearGradientBrush()
        {
            EndPoint = new RelativePoint(0.5, 1, RelativeUnit.Relative),
            StartPoint = new RelativePoint(0.5, 0, RelativeUnit.Relative),
            GradientStops = new GradientStops()
            {
                new GradientStop() { Color = primaryColor, Offset = 0 },
                new GradientStop() { Color = isLight ? Colors.Transparent : accentColor, Offset = v },
            },
        };
    }

    
/ <inheritdoc/>
    public object ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        return BindingOperations.DoNothing;
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\Extensions\IEnumerableExtensions.cs
/ <see cref="IEnumerable"/> extensions methods

/ </summary>
public static class IEnumerableExtensions
{
    public static IEnumerable<IEnumerable> Batch(this IEnumerable source, int size)
    {
        object[]? bucket = null;
        var count = 0;

        foreach (var item in source)
        {
            bucket ??= new object[size];

            bucket[count++] = item;

            if (count == size)
            {
                yield return bucket;
                bucket = null;
                count = 0;
            }
        }

        if (bucket != null && count > 0)
            yield return bucket.Take(count).ToArray();
    }
}


发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\Extensions\WindowExtensions.cs
/ </summary>
    
/ <param name="window"></param>
    
/ <param name="value"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void SetResizeMode(this Window window, ResizeMode value)
    {
        var p = Ioc.Get<IPlatformService>();
        switch (value)
        {
            case ResizeMode.NoResize:
            case ResizeMode.CanMinimize:
                window.CanResize = false;
                break;
            case ResizeMode.CanResize:
#pragma warning disable CS0618 
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Avalonia\Extensions\WindowExtensions.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\Extensions\ServiceCollection\ServiceCollectionExtensions.AddApplicationUpdateService.cs
/ </summary>
    
/ <param name="services"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IServiceCollection AddApplicationUpdateService(this IServiceCollection services)
    {
        services.AddSingleton<IAppUpdateService, AppUpdateServiceImpl>();
        return services;
    }
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Avalonia\Extensions\ServiceCollection\ServiceCollectionExtensions.AddApplicationUpdateService.cs
AVALONIA
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Avalonia\Extensions\ServiceCollection\ServiceCollectionExtensions.AddJumpListService.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\Extensions\ServiceCollection\ServiceCollectionExtensions.AddMainThreadPlatformService.cs
/ </summary>
    
/ <param name="services"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IServiceCollection AddMainThreadPlatformService(this IServiceCollection services)
    {
        services.AddSingleton<IMainThreadPlatformService, MainThreadPlatformServiceImpl>();
        return services;
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\Extensions\ServiceCollection\ServiceCollectionExtensions.TryAddAvaloniaFilePickerPlatformService.cs
/ 添加 Avalonia 实现的文件选择/保存框服务
    
/ </summary>
    
/ <param name="services"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IServiceCollection TryAddAvaloniaFilePickerPlatformService(this IServiceCollection services)
    {
        services.AddSingleton<IFilePickerPlatformService, AvaloniaFilePickerPlatformService>();
        services.TryAddSingleton(s => s.GetRequiredService<IFilePickerPlatformService>().OpenFileDialogService);
        services.TryAddSaveFileDialogService(s => s.GetRequiredService<IFilePickerPlatformService>().SaveFileDialogService);
        return services;
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\Extensions\ServiceCollection\ServiceCollectionExtensions.TryAddAvaloniaFontManager.cs
/ </summary>
    
/ <param name="services"></param>
    
/ <param name="useGdiPlusFirst"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IServiceCollection TryAddAvaloniaFontManager(this IServiceCollection services, bool useGdiPlusFirst)
    {
        services.AddSingleton<IFontManager, FontManagerImpl>();
        return services;
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\Extensions\ServiceCollection\ServiceCollectionExtensions.TryAddAvaloniaThemeService.cs
/ </summary>
    
/ <param name="services"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IServiceCollection TryAddAvaloniaTheme(this IServiceCollection services)
    {
        services.TryAddSingleton<FluentAvaloniaTheme>();
        services.TryAddSingleton<CustomTheme>();
        return services;
    }
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Avalonia\Extensions\ServiceCollection\ServiceCollectionExtensions.TryAddAvaloniaThemeService.cs
AVALONIA
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\Extensions\ServiceCollection\ServiceCollectionExtensions.TryAddAvaloniaToastService.cs
/ </summary>
    
/ <param name="services"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IServiceCollection TryToastService(this IServiceCollection services)
    {
        services.TryAddSingleton<IToastService, ToastServiceImpl_>();
        return services;
    }
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Avalonia\Extensions\ServiceCollection\ServiceCollectionExtensions.TryAddAvaloniaToastService.cs
AVALONIA
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\Extensions\ServiceCollection\ServiceCollectionExtensions.TryAddWindowManager.cs
/ </summary>
    
/ <param name="services"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IServiceCollection TryAddWindowManager(this IServiceCollection services)
    {
        services.TryAddSingleton<IWindowManager, WindowManagerImpl_>();
        return services;
    }

    
/ </summary>
    
/ <param name="services"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IServiceCollection TryAddNavigationService(this IServiceCollection services)
    {
        services.TryAddSingleton<INavigationService, NavigationService>();
        return services;
    }
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Avalonia\Extensions\ServiceCollection\ServiceCollectionExtensions.TryAddWindowManager.cs
AVALONIA
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\Helpers\NotifyIconHelper.cs
/ <inheritdoc cref="INotificationService.NotifyIconHelper"/>

/BD.WTTS.Client.Avalonia.App/Application/UI/Assets/ApplicationIcon_16.png";

/BD.WTTS.Client.Avalonia/Application/UI/Assets/ApplicationIcon.ico";

发现 Windows 特有的库：../SteamTools\src\BD.WTTS.Client.Avalonia\Helpers\NotifyIconHelper.cs
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Avalonia\Helpers\NotifyIconHelper.cs
WINDOWS
WINDOWS
WINDOWS
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\Properties\AssemblyInfo.Xaml.cs
/steampp.net/ui", "BD.WTTS.Enums")]
[assembly: XmlnsDefinition("https:
/steampp.net/ui", "BD.WTTS.Models")]
[assembly: XmlnsDefinition("https:
/steampp.net/ui", "BD.WTTS.Models.Abstractions")]
[assembly: XmlnsDefinition("https:
/steampp.net/ui", "BD.WTTS.UI")]
[assembly: XmlnsDefinition("https:
/steampp.net/ui", "BD.WTTS.UI.ViewModels")]
[assembly: XmlnsDefinition("https:
/steampp.net/ui", "BD.WTTS.UI.ViewModels.Abstractions")]
[assembly: XmlnsDefinition("https:
/steampp.net/ui", "BD.WTTS.UI.Views")]
[assembly: XmlnsDefinition("https:
/steampp.net/ui", "BD.WTTS.UI.Views.Controls")]
[assembly: XmlnsDefinition("https:
/steampp.net/ui", "BD.WTTS.UI.Views.Pages")]
[assembly: XmlnsDefinition("https:
/steampp.net/ui", "BD.WTTS.UI.Views.Windows")]
[assembly: XmlnsDefinition("https:
/steampp.net/ui", "BD.WTTS.Converters")]
[assembly: XmlnsDefinition("https:
/steampp.net/ui", "BD.WTTS.Markup")]
[assembly: XmlnsDefinition("https:
/steampp.net/ui", "BD.WTTS.Behaviors")]
[assembly: XmlnsDefinition("https:
/steampp.net/services", "BD.WTTS.Services")]
[assembly: XmlnsDefinition("https:
/steampp.net/services", "BD.WTTS.Plugins")]
[assembly: XmlnsDefinition("https:
/steampp.net/services", "BD.WTTS.Plugins.Abstractions")]
[assembly: XmlnsDefinition("https:
/steampp.net/settings", "BD.WTTS.Settings")]


/github.com/amwx/FluentAvalonia", "FluentAvalonia.UI.Controls")]
[assembly: XmlnsDefinition("https:
/github.com/amwx/FluentAvalonia", "FluentAvalonia.UI.Windowing")]
[assembly: XmlnsDefinition("https:
/github.com/amwx/FluentAvalonia", "FluentAvalonia.UI.Controls.Primitives")]
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\Services.Implementation\App\AvaloniaApplicationUpdateServiceImpl.cs
/ <inheritdoc cref="IAppUpdateService"/>
sealed class AvaloniaApplicationUpdateServiceImpl : AppUpdateServiceBaseImpl
{
    public AvaloniaApplicationUpdateServiceImpl(
        IApplication application,
        INotificationService notificationService,
        IToast toast,
        IMicroServiceClient client,
        IOptions<AppSettings> options) : base(application, notificationService, toast, client, options)
    {

    }

    protected override bool HasActiveWindow()
    {
        var hasActiveWindow = App.Instance.HasActiveWindow();
        return hasActiveWindow;
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\Services.Implementation\UI\Views\Windows\AvaloniaWindowManagerImpl.cs
/ <inheritdoc cref="IWindowManager"/>
public sealed class AvaloniaWindowManagerImpl : IWindowManagerImpl
{
    Type? IWindowManagerImpl.WindowType => typeof(Window);

    public static TopLevel? GetWindowTopLevel()
    {
        if (App.Instance.ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
        {
            var window = desktop.MainWindow;
            if (window != null)
            {
                return TopLevel.GetTopLevel(window);
            }
        }
        else if (App.Instance.ApplicationLifetime is ISingleViewApplicationLifetime view)
        {
            var mainView = view.MainView;
            if (mainView != null)
            {
                return TopLevel.GetTopLevel(mainView);
            }
        }
        return null;
    }

    Type GetWindowType(AppEndPoint customWindow)
    {
        IWindowManagerImpl @this = this;
        return @this.GetWindowType(customWindow, typeof(AvaloniaWindowManagerImpl).Assembly);
    }

    Type GetWindowViewModelType(AppEndPoint customWindow)
    {
        IWindowManagerImpl @this = this;
        return @this.GetWindowViewModelType(customWindow, typeof(WindowViewModel).Assembly);
    }

    static bool IsSingletonWindow(AppEndPoint customWindow) => customWindow switch
    {
        AppEndPoint.MessageBox or
        AppEndPoint.TextBox or
        AppEndPoint.AuthTrade or
        AppEndPoint.ShowAuth => false,
        _ => true,
    };

    static bool TryShowSingletonWindow(Type windowType)
    {
        if (Application.Current?.ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
        {
            var window = desktop.Windows.FirstOrDefault(x => x.GetType() == windowType);
            if (window != null)
            {
                window.Show();
                if (window.WindowState == WindowState.Minimized)
                    window.WindowState = WindowState.Normal;
                window.Activate();
                return true;
            }
        }
        return false;
    }

    
/ </summary>
    
/ <typeparam name="TPageViewModel"></typeparam>
    
/ <param name="viewModel"></param>
    
/ <param name="title"></param>
    
/ <param name="subHeader"></param>
    
/ <param name="isDialog"></param>
    
/ <param name="isFooterExpanded"></param>
    
/ <returns></returns>
    public async Task<bool> ShowTaskDialogAsync<TPageViewModel>(
        TPageViewModel? viewModel,
        string title = "",
        string? header = null,
        string? subHeader = null,
        bool isDialog = false,
        bool showProgressBar = false,
        bool isRememberChooseFooter = false,
        bool isOkButton = true,
        bool isCancelButton = false,
        bool isRetryButton = false,
        object? pageContent = null,
        string? okButtonText = null,
        string? retryButtonText = null,
        string? moreInfoText = null,
        Func<bool>? cancelCloseAction = null,
        bool disableScroll = false)
        where TPageViewModel : ViewModelBase
  {
        var td = new TaskDialogEx
        {
            Title = title,
            Header = string.IsNullOrEmpty(header) ? title : header,
            SubHeader = subHeader,
            
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Avalonia\Services.Implementation\UI\Widgets\AvaloniaClipboardPlatformService.cs
LINUX
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\Services.Implementation\UI\Widgets\AvaloniaFilePickerPlatformService.cs
/github.com/xamarin/Essentials/blob/1.7.3/Xamarin.Essentials/FilePicker/FilePicker.uwp.cs
    
/github.com/xamarin/Essentials/blob/1.7.3/Xamarin.Essentials/FileSystem/FileSystem.shared.cs

    sealed class FilePickerFileTypeWrapper : IFilePickerFileType
    {
        public required IReadOnlyList<APS_FilePickerFileType> Values { get; init; }

        public IEnumerable<string>? GetPlatformFileType(Platform platform)
        {
            foreach (var value in Values)
            {
                if (value.Patterns != null)
                    foreach (var item in value.Patterns)
                        yield return item;
                if (value.MimeTypes != null)
                    foreach (var item in value.MimeTypes)
                        yield return item;
                if (value.AppleUniformTypeIdentifiers != null)
                    foreach (var item in value.AppleUniformTypeIdentifiers)
                        yield return item;
            }
        }
    }

    IFilePickerFileType IInternalFilePickerPlatformService.Images { get; } = new FilePickerFileTypeWrapper
    {
        Values = new[]
        {
            new APS_FilePickerFileType("All Images")
            {
                Patterns = new[] { "*.webp", "*.png", "*.jpg", "*.jpeg", "*.gif", "*.bmp" },
                AppleUniformTypeIdentifiers = new[] { "public.png", "public.jpeg", "public.jpeg-2000", "com.compuserve.gif", "com.microsoft.bmp", },
                MimeTypes = new[] { "image/webp", "image/png", "image/jpeg", "image/gif", "image/bmp", },
            },
        },
    };

    IFilePickerFileType IInternalFilePickerPlatformService.Png { get; } = new FilePickerFileTypeWrapper
    {
        Values = new[]
        {
            new APS_FilePickerFileType("PNG image")
            {
                Patterns = new[] { "*.png", },
                AppleUniformTypeIdentifiers = new[] { "public.png", },
                MimeTypes = new[] { "image/png", },
            },
        },
    };

    IFilePickerFileType IInternalFilePickerPlatformService.Jpeg { get; } = new FilePickerFileTypeWrapper
    {
        Values = new[]
        {
            new APS_FilePickerFileType("JPEG image")
            {
                Patterns = new[] { "*.jpg", "*.jpeg", },
                AppleUniformTypeIdentifiers = new[] { "public.jpeg", "public.jpeg-2000", },
                MimeTypes = new[] { "image/jpeg", },
            },
        },
    };

    IFilePickerFileType IInternalFilePickerPlatformService.Videos => throw new NotImplementedException();

    IFilePickerFileType IInternalFilePickerPlatformService.Pdf { get; } = new FilePickerFileTypeWrapper
    {
        Values = new[]
        {
            new APS_FilePickerFileType("PDF document")
            {
                Patterns = new[] { "*.pdf", },
                AppleUniformTypeIdentifiers = new[] { "com.adobe.pdf", },
                MimeTypes = new[] { "application/pdf", },
            },
        },
    };

    
/docs.avaloniaui.net/docs/next/concepts/services/storage-provider/file-picker-options
        var result = new APS_FilePickerFileType(name);
        if (extensions != null)
        {
#if IOS || MACOS || MACCATALYST
            HashSet<string> appleUniformTypeIdentifiers = new();
#else
#if !WINDOWS
            HashSet<string> mimeTypes = new();
#endif
            HashSet<string> patterns = new();
#endif
            foreach (var x in extensions)
            {
                if (x.Contains('/'))
                {
#if !WINDOWS && !(IOS || MACOS || MACCATALYST)
                    mimeTypes.Add(x);
#endif
                    continue;
                }
                else if (IsAppleUniformTypeIdentifier(x))
                {
#if IOS || MACOS || MACCATALYST
                    appleUniformTypeIdentifiers.Add(x);
#endif
                    continue;
                }
                else if (x.StartsWith('.'))
                {
#if !(IOS || MACOS || MACCATALYST)
                    patterns.Add($"*{x}");
#endif
                    continue;
                }
                else if (x.StartsWith('*'))
                {
#if !(IOS || MACOS || MACCATALYST)
                    patterns.Add(x);
#endif
                    continue;
                }
                else
                {
#if !(IOS || MACOS || MACCATALYST)
                    patterns.Add($"*.{x}");
#endif
                    continue;
                }
            }
#if IOS || MACOS || MACCATALYST
            if (appleUniformTypeIdentifiers.Any())
            {
                result.AppleUniformTypeIdentifiers = appleUniformTypeIdentifiers.ToArray();
            }
#else
#if !WINDOWS
            if (mimeTypes.Any())
            {
                result.MimeTypes = mimeTypes.ToArray();
            }
#endif
            if (patterns.Any())
            {
                result.Patterns = patterns.ToArray();
            }
#endif
        }

        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static IReadOnlyList<APS_FilePickerFileType>? Convert(IFilePickerFileType? fileTypes)
    {
        if (fileTypes is AvaloniaFilePickerFileTypeFilter ava)
        {
            var items = ava.Values;
            if (items != null)
            {
                var query = from m in items
                            select new APS_FilePickerFileType(m.Name)
                            {
                                Patterns = m.Patterns,
                                AppleUniformTypeIdentifiers = m.AppleUniformTypeIdentifiers,
                                MimeTypes = m.MimeTypes,
                            };
                return query.ToArray();
            }
            return null;
        }
        else if (fileTypes is FilePickerFileTypeWrapper impl)
        {
            return impl.Values;
        }
        else if (fileTypes is FilePickerFileType.IFilePickerFileTypeWithName @interface)
        {
            var values = @interface.GetFileTypes();
            if (values.Any())
            {
                return values.Select(x => Convert(x.Item1, x.Item2)).ToList();
            }
        }
        else
        {
            var extensions = fileTypes?.GetPlatformFileType(DeviceInfo2.Platform());
            if (extensions.Any_Nullable())
            {
                return new APS_FilePickerFileType[]
                {
                    Convert(string.Empty, extensions),
                };
            }
        }
        return null;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static IEnumerable<IFileResult> Convert(IReadOnlyList<IStorageFile> fileResults)
    {
        foreach (var fileResult in fileResults)
        {
            var filePath = GetAbsoluteFilePath(fileResult);
            if (!string.IsNullOrEmpty(filePath))
                yield return new FileResult(filePath);
        }
    }

    async Task<IEnumerable<IFileResult>> IOpenFileDialogService.PlatformPickAsync(PickOptions? options, bool allowMultiple)
    {
        var storageProvider = App.Instance.MainWindow?.StorageProvider;
        if (storageProvider == null || !storageProvider.CanOpen)
            return Array.Empty<IFileResult>();

        FilePickerOpenOptions options_ = new()
        {
            AllowMultiple = allowMultiple,
        };
        if (options != default)
        {
            if (options.PickerTitle != default)
            {
                options_.Title = options.PickerTitle;
            }
            if (options.FileTypes != default)
            {
                var filters = Convert(options.FileTypes);
                if (filters != default)
                {
                    options_.FileTypeFilter = filters;
                }
            }
        }

        var fileResults = await storageProvider.OpenFilePickerAsync(options_);

        if (fileResults.Any_Nullable())
        {
            return Convert(fileResults);
        }
        return Array.Empty<FileResult>();
    }

    async Task<SaveFileResult?> ISaveFileDialogService.PlatformSaveAsync(PickOptions? options)
    {
        var storageProvider = App.Instance.MainWindow?.StorageProvider;
        if (storageProvider == null || !storageProvider.CanSave)
            return null;

        FilePickerSaveOptions options_ = new();

        if (options != default)
        {
            if (options.PickerTitle != default)
            {
                options_.Title = options.PickerTitle;
            }
            if (options.FileTypes != default)
            {
                var filters = Convert(options.FileTypes);
                if (filters != default)
                {
                    options_.FileTypeChoices = filters;
                }
            }
            if (options.InitialFileName != default)
            {
                options_.SuggestedFileName = options.InitialFileName;
            }
        }

        var fileResult = await storageProvider.SaveFilePickerAsync(options_);
        var filePath = GetAbsoluteFilePath(fileResult);
        return string.IsNullOrEmpty(filePath) ? null : new(filePath);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static string? GetAbsoluteFilePath(IStorageItem? storageItem)
    {
        const string trim_s =
#if WINDOWS
            "file:
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Avalonia\Services.Implementation\UI\Widgets\AvaloniaFilePickerPlatformService.cs
IOS
IOS
IOS
IOS
IOS
IOS
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\Services.Implementation\UI\Widgets\AvaloniaToastServiceImpl.cs
/ </summary>
    
/ <param name="text"></param>
    
/ <param name="duration"></param>
    public void Show(ToastIcon icon, string text, int? duration = null)
    {
        if (NotificationManager == null)
        {
            var host = AvaloniaWindowManagerImpl.GetWindowTopLevel();
            if (host != null)
            {
                NotificationManager = new SnackbarManager(host)
                {
                    Position = NotificationPosition.BottomRight,
                    MaxItems = 5,
                };
            }
        }

        if (NotificationManager != null)
        {
            var notificationType = GetNotificationType(icon);
            NotificationManager.Show(text, notificationType: notificationType);
        }
    }

    
/ <inheritdoc cref="Show(string, int?)"/>
    public void Show(ToastIcon icon, string text, ToastLength duration)
    {
        Show(icon, text, null);
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\Services.Implementation\UI\Widgets\JumpListServiceImpl.cs
/ <inheritdoc cref="IJumpListService"/>
internal sealed class JumpListServiceImpl : IJumpListService
{
#if WINDOWS
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static bool IsWindows10JumpListSupported()
    {
        if (OperatingSystem.IsWindowsVersionAtLeast(10, 0, 10586))
        {
            return WinUI.JumpList.IsSupported();
        }
        return false;
    }
#endif

    ValueTask IJumpListService.AddJumpItemsAsync(IEnumerable<(string title, string applicationPath, string iconResourcePath, string arguments, string description, string customCategory)> items)
    {
#if WINDOWS
        return AddJumpItemsByWinAsync(items);
#else
        return default;
#endif
    }

#if WINDOWS
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static async ValueTask AddJumpItemsByWinAsync(IEnumerable<(string title, string applicationPath, string iconResourcePath, string arguments, string description, string customCategory)> items)
    {
        if (IsWindows10JumpListSupported() && await AddJumpItemsByWin10Async(items)) return;
        await AddJumpItemsByWPFAsync(items);
    }

    static async ValueTask<bool> AddJumpItemsByWin10Async(IEnumerable<(string title, string applicationPath, string iconResourcePath, string arguments, string description, string customCategory)> items)
    {
        try
        {
            var jumpList1 = await WinUI.JumpList.LoadCurrentAsync();

            foreach (var (title, _, _, arguments, description, customCategory) in items)
            {
                var isAdd = false;
                var item = jumpList1.Items.FirstOrDefault(x =>
                    x.Kind == WinUI.JumpListItemKind.Arguments && x.Arguments == arguments);
                if (item == null)
                {
                    item = WinUI.JumpListItem.CreateWithArguments(arguments, title);
                    isAdd = true;
                }
                else
                {
                    item.DisplayName = title;
                }
                item.Description = description;
                item.GroupName = customCategory;

                if (isAdd) jumpList1.Items.Add(item);
            }

            await jumpList1.SaveAsync();
            return true;
        }
        catch (Exception ex)
        {
            const string log_msg = $"{nameof(AddJumpItemsByWin10Async)} catch.";
            Log.Error(TAG, ex, log_msg);
            return false;
        }
    }

    static ValueTask<bool> AddJumpItemsByWPFAsync(IEnumerable<(string title, string applicationPath, string iconResourcePath, string arguments, string description, string customCategory)> items)
    {
        try
        {
            var avaloniaApp = AvaloniaApplication.Current;
            avaloniaApp.ThrowIsNull();

            var jumpList1 = JumpList.GetJumpList(avaloniaApp);
            if (jumpList1 == null)
            {
                jumpList1 = new JumpList
                {
                    ShowRecentCategory = true,
                    ShowFrequentCategory = false,
                };
                JumpList.SetJumpList(avaloniaApp, jumpList1);
            }

            foreach (var (title, applicationPath, iconResourcePath, arguments, description, customCategory) in items)
            {
                var task = (from s in jumpList1.JumpItems
                            let v = s is JumpTask t ? t : null
                            where v != null &&
                              v.ApplicationPath == applicationPath &&
                              v.Arguments == arguments
                            select v).FirstOrDefault();
                if (task != null)
                {
                    task.Title = title;
                    task.IconResourcePath = iconResourcePath;
                    task.Description = description;
                    task.CustomCategory = customCategory;
                }
                else
                {
                    task = new JumpTask
                    {
                        
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Avalonia\Services.Implementation\UI\Widgets\JumpListServiceImpl.cs
WINDOWS
WINDOWS
WINDOWS
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\UI\App.axaml.cs
/ </summary>
    public Window? MainWindow { get; internal set; }

    public static event InitializeHandler? InitializeMainWindow;

    public delegate Window InitializeHandler(object sender);

    
/ </summary>
    
/ <returns></returns>
    public Window? GetFirstOrDefaultWindow()
    {
        var window = MainWindow;
        if (window == null)
        {
            if (ApplicationLifetime is ClassicDesktopStyleApplicationLifetime classicDesktopStyleApplicationLifetime)
            {
                window = classicDesktopStyleApplicationLifetime.Windows.FirstOrDefault(x => x != null);
            }
        }
        return window;
    }

    public override void Initialize()
    {
        try
        {
            AvaloniaXamlLoader.Load(this);

#if WINDOWS || LINUX || MACOS
            if (GeneralSettings.MinimizeOnStartup.Value)
                Startup.Instance.IsMinimize = true;

            if (Startup.Instance.IsSteamRun)
            {
                try
                {
                    Steamworks.Dispatch.OnException = (e) =>
                    {
                        Log.Error(nameof(Steamworks), e, "Steamworks.SteamClient OnException.");
                    };

                    
/ <inheritdoc cref="IPlatformService.SetDesktopBackgroundToWindow(nint, int, int)"/>
    
/ </summary>
    
/ <param name="level"></param>
    public void SetAllWindowransparencyMateria(WindowBackgroundMaterial level)
    {
        if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
        {
            foreach (var window in desktop.Windows)
            {
                window.TransparencyLevelHint = new WindowTransparencyLevel[] { level.ToWindowTransparencyLevel() };

                
/BD.WTTS.Client.Avalonia/UI/Assets/Fonts/HarmonyOS_Sans_SC_Regular.ttf#HarmonyOS Sans SC";

    static readonly Lazy<FontFamily> _DefaultFontFamily = new(GetDefaultFontFamily);

    public static FontFamily DefaultFontFamily => _DefaultFontFamily.Value;

    public ICommand OpenBrowserCommand { get; }

    public async void OpenBrowserCommandCore(object? url)
    {
        try
        {
            var urlString = url?.ToString();
            if (string.IsNullOrEmpty(urlString))
            {
                Toast.Show(ToastIcon.Warning, "打开链接失败");
                return;
            }
            try
            {
                Uri uri = new(urlString);
                if (uri.Host.EndsWith(Constants.Urls.OfficialWebsiteHost, StringComparison.OrdinalIgnoreCase) &&
                    uri.Query.EndsWith(Constants.Urls.Komaasharu_IsAuthQuery, StringComparison.OrdinalIgnoreCase))
                {
                    await UserService.Current.OpenAuthUrl(urlString);
                    return;
                }
            }
            catch
            {
            }
            Browser2.Open(urlString);
        }
        catch (Exception ex)
        {
            Toast.LogAndShowT(ex);
        }
    }

    public ICommand CopyToClipboardCommand { get; }

    public async void CopyToClipboardCommandCore(object? text)
    {
        try
        {
            if (text == null || string.IsNullOrEmpty(text.ToString()))
            {
                Toast.Show(ToastIcon.Warning, "复制内容失败");
                return;
            }
            await Clipboard2.SetTextAsync(text.ToString());
            Toast.Show(ToastIcon.Success, Strings.CopyToClipboard);
        }
        catch (Exception ex)
        {
            Toast.LogAndShowT(ex);
        }
    }
}

发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Avalonia\UI\App.axaml.cs
MACOS
WINDOWS
WINDOWS
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\UI\App.Interface.cs
/github.com/AvaloniaUI/Avalonia/issues/2975
        mainWindow.Focus();

        
/github.com/AvaloniaUI/Avalonia/issues/2994
        
/ </summary>
    
/ <param name="window"></param>
    
/ <returns></returns>
    public async Task ShowDialogWindowAsync(Window window)
    {
        var owner = GetActiveWindow();
        if (owner != null)
        {
            try
            {
                await window.ShowDialog(owner);
                return;
            }
            catch (InvalidOperationException)
            {
            }
        }
        window.Show();
    }

    public void ShowWindow(Window window)
    {
        var owner = GetActiveWindow();
        if (owner != null)
        {
            try
            {
                window.Show(owner);
                return;
            }
            catch (InvalidOperationException)
            {
            }

        }
        window.Show();
    }

    public void ShowWindowNoParent(Window window)
    {
        window.Show();
    }

    void IApplication.Shutdown() => Shutdown();

    object IApplication.CurrentPlatformUIHost => MainWindow!;

    public System.Drawing.Size? GetScreenSize()
    {
        try
        {
            var window = GetFirstOrDefaultWindow();
            var screen = window?.Screens?.Primary;
            if (screen != default)
            {
                return new(screen.Bounds.Width, screen.Bounds.Height);
            }
        }
        catch
        {

        }
        return null;
    }

    public bool? IsAnyWindowNotMinimized()
    {
        try
        {
            if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime l)
            {
                foreach (var window in l.Windows)
                {
                    static bool WindowIntersectsWithAnyScreen(Window window)
                    {
                        static bool IntersectsWith(Rect rect, PixelRect @this)
                        {
                            if (rect.X < @this.X + @this.Width && @this.X < rect.X + rect.Width && rect.Y < @this.Y + @this.Height)
                            {
                                return @this.Y < rect.Y + rect.Height;
                            }

                            return false;
                        }
                        return window.Screens.All.Any(screen => IntersectsWith(window.Bounds, screen.Bounds));
                    }
                    if (window.WindowState != WindowState.Minimized && WindowIntersectsWithAnyScreen(window))
                    {
                        return true;
                    }
                }
            }
        }
        catch
        {

        }
        return default;
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\UI\App.TrayIcon.cs
/BD.WTTS.Client.Avalonia/UI/Assets/ApplicationIcon.ico"))),
                    ToolTipText = AssemblyInfo.Trademark,
                    Command = ReactiveCommand.Create(RestoreMainWindow),
                    
/ </summary>
    
/ <param name="sender"></param>
    
/ <param name="e"></param>
    private void ActivatableLifetimeOnActivated(object? sender, ActivatedEventArgs e)
    {
        switch (e.Kind)
        {
            case ActivationKind.Background:
            case ActivationKind.Reopen:
                RestoreMainWindow();
                break;
        }
    }

    
/ </summary>
    
/ <param name="sender"></param>
    
/ <param name="e"></param>
    
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Avalonia\UI\App.TrayIcon.cs
UI
MACOS
MACOS
发现 Windows 特有的库：../SteamTools\src\BD.WTTS.Client.Avalonia\UI\Input\Command.cs
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\UI\Input\ItemDragBehavior.cs
/ </summary>
    public static readonly StyledProperty<Orientation> OrientationProperty =
        AvaloniaProperty.Register<ItemDragBehavior, Orientation>(nameof(Orientation));

    
/ </summary>
    public static readonly StyledProperty<double> HorizontalDragThresholdProperty =
        AvaloniaProperty.Register<ItemDragBehavior, double>(nameof(HorizontalDragThreshold), 3);

    
/ </summary>
    public static readonly StyledProperty<double> VerticalDragThresholdProperty =
        AvaloniaProperty.Register<ItemDragBehavior, double>(nameof(VerticalDragThreshold), 3);

    
/ </summary>
    public Orientation Orientation
    {
        get => GetValue(OrientationProperty);
        set => SetValue(OrientationProperty, value);
    }

    
/ </summary>
    public double HorizontalDragThreshold
    {
        get => GetValue(HorizontalDragThresholdProperty);
        set => SetValue(HorizontalDragThresholdProperty, value);
    }

    
/ </summary>
    public double VerticalDragThreshold
    {
        get => GetValue(VerticalDragThresholdProperty);
        set => SetValue(VerticalDragThresholdProperty, value);
    }

    
/ <inheritdoc />
    protected override void OnAttachedToVisualTree()
    {
        if (AssociatedObject is { })
        {
            AssociatedObject.AddHandler(InputElement.PointerReleasedEvent, PointerReleased, RoutingStrategies.Tunnel);
            AssociatedObject.AddHandler(InputElement.PointerPressedEvent, PointerPressed, RoutingStrategies.Tunnel);
            AssociatedObject.AddHandler(InputElement.PointerMovedEvent, PointerMoved, RoutingStrategies.Tunnel);
            AssociatedObject.AddHandler(InputElement.PointerCaptureLostEvent, PointerCaptureLost, RoutingStrategies.Tunnel);
        }
    }

    
/ <inheritdoc />
    protected override void OnDetachedFromVisualTree()
    {
        if (AssociatedObject is { })
        {
            AssociatedObject.RemoveHandler(InputElement.PointerReleasedEvent, PointerReleased);
            AssociatedObject.RemoveHandler(InputElement.PointerPressedEvent, PointerPressed);
            AssociatedObject.RemoveHandler(InputElement.PointerMovedEvent, PointerMoved);
            AssociatedObject.RemoveHandler(InputElement.PointerCaptureLostEvent, PointerCaptureLost);
        }
    }

    private void PointerPressed(object? sender, PointerPressedEventArgs e)
    {
        var properties = e.GetCurrentPoint(AssociatedObject).Properties;
        if (properties.IsLeftButtonPressed
            && AssociatedObject?.Parent is ItemsControl itemsControl)
        {
            _enableDrag = true;
            _dragStarted = false;
            _start = e.GetPosition(itemsControl);
            _draggedIndex = -1;
            _targetIndex = -1;
            _itemsControl = itemsControl;
            _draggedContainer = AssociatedObject;

            if (_draggedContainer is { })
            {
                SetDraggingPseudoClasses(_draggedContainer, true);
            }

            AddTransforms(_itemsControl);

            _captured = true;
        }
    }

    private void PointerReleased(object? sender, PointerReleasedEventArgs e)
    {
        if (_captured)
        {
            if (e.InitialPressMouseButton == Avalonia.Input.MouseButton.Left)
            {
                Released();
            }

            _captured = false;
        }
    }

    private void PointerCaptureLost(object? sender, PointerCaptureLostEventArgs e)
    {
        Released();
        _captured = false;
    }

    private void Released()
    {
        if (!_enableDrag)
        {
            return;
        }

        RemoveTransforms(_itemsControl);

        if (_itemsControl is { })
        {
            foreach (var control in _itemsControl.GetRealizedContainers())
            {
                SetDraggingPseudoClasses(control, true);
            }
        }

        if (_dragStarted)
        {
            if (_draggedIndex >= 0 && _targetIndex >= 0 && _draggedIndex != _targetIndex)
            {
                MoveDraggedItem(_itemsControl, _draggedIndex, _targetIndex);
            }
        }

        if (_itemsControl is { })
        {
            foreach (var control in _itemsControl.GetRealizedContainers())
            {
                SetDraggingPseudoClasses(control, false);
            }
        }

        if (_draggedContainer is { })
        {
            SetDraggingPseudoClasses(_draggedContainer, false);
        }

        _draggedIndex = -1;
        _targetIndex = -1;
        _enableDrag = false;
        _dragStarted = false;
        _itemsControl = null;

        _draggedContainer = null;
    }

    private void AddTransforms(ItemsControl? itemsControl)
    {
        if (itemsControl?.Items is null)
        {
            return;
        }

        for (var i = 0; i < itemsControl.Items.Count; i++)
        {
            var container = itemsControl.ContainerFromIndex(i);
            if (container is not null)
            {
                SetTranslateTransform(container, 0, 0);
            }
        }
    }

    private void RemoveTransforms(ItemsControl? itemsControl)
    {
        if (itemsControl?.Items is null)
        {
            return;
        }

        for (var i = 0; i < itemsControl.Items.Count; i++)
        {
            var container = itemsControl.ContainerFromIndex(i);
            if (container is not null)
            {
                SetTranslateTransform(container, 0, 0);
            }
        }
    }

    private void MoveDraggedItem(ItemsControl? itemsControl, int draggedIndex, int targetIndex)
    {
        if (itemsControl?.ItemsSource is IList itemsSource)
        {
            var draggedItem = itemsSource[draggedIndex];
            itemsSource.RemoveAt(draggedIndex);
            itemsSource.Insert(targetIndex, draggedItem);

            if (itemsControl is SelectingItemsControl selectingItemsControl)
            {
                selectingItemsControl.SelectedIndex = targetIndex;
            }
        }
        else
        {
            if (itemsControl?.Items is { IsReadOnly: false } itemCollection)
            {
                var draggedItem = itemCollection[draggedIndex];
                itemCollection.RemoveAt(draggedIndex);
                itemCollection.Insert(targetIndex, draggedItem);

                if (itemsControl is SelectingItemsControl selectingItemsControl)
                {
                    selectingItemsControl.SelectedIndex = targetIndex;
                }
            }
        }
    }

    private void PointerMoved(object? sender, PointerEventArgs e)
    {
        var properties = e.GetCurrentPoint(AssociatedObject).Properties;
        if (_captured
            && properties.IsLeftButtonPressed)
        {
            if (_itemsControl?.Items is null || _draggedContainer?.RenderTransform is null || !_enableDrag)
            {
                return;
            }

            var orientation = Orientation;
            var position = e.GetPosition(_itemsControl);
            var delta = orientation == Orientation.Horizontal ? position.X - _start.X : position.Y - _start.Y;

            if (!_dragStarted)
            {
                var diff = _start - position;
                var horizontalDragThreshold = HorizontalDragThreshold;
                var verticalDragThreshold = VerticalDragThreshold;

                if (orientation == Orientation.Horizontal)
                {
                    if (Math.Abs(diff.X) > horizontalDragThreshold)
                    {
                        _dragStarted = true;
                    }
                    else
                    {
                        return;
                    }
                }
                else
                {
                    if (Math.Abs(diff.Y) > verticalDragThreshold)
                    {
                        _dragStarted = true;
                    }
                    else
                    {
                        return;
                    }
                }
            }

            if (orientation == Orientation.Horizontal)
            {
                SetTranslateTransform(_draggedContainer, delta, 0);
            }
            else
            {
                SetTranslateTransform(_draggedContainer, 0, delta);
            }

            _draggedIndex = _itemsControl.IndexFromContainer(_draggedContainer);
            _targetIndex = -1;

            var draggedBounds = _draggedContainer.Bounds;

            var draggedStart = orientation == Orientation.Horizontal ? draggedBounds.X : draggedBounds.Y;

            var draggedDeltaStart = orientation == Orientation.Horizontal
                ? draggedBounds.X + delta
                : draggedBounds.Y + delta;

            var draggedDeltaEnd = orientation == Orientation.Horizontal
                ? draggedBounds.X + delta + draggedBounds.Width
                : draggedBounds.Y + delta + draggedBounds.Height;

            for (var i = 0; i < _itemsControl.Items.Count; i++)
            {
                var targetContainer = _itemsControl.ContainerFromIndex(i);
                if (targetContainer?.RenderTransform is null || ReferenceEquals(targetContainer, _draggedContainer))
                {
                    i++;
                    continue;
                }

                var targetBounds = targetContainer.Bounds;

                var targetStart = orientation == Orientation.Horizontal ? targetBounds.X : targetBounds.Y;

                var targetMid = orientation == Orientation.Horizontal
                    ? targetBounds.X + (targetBounds.Width / 2)
                    : targetBounds.Y + (targetBounds.Height / 2);

                var targetIndex = _itemsControl.IndexFromContainer(targetContainer);

                if (targetStart > draggedStart && draggedDeltaEnd >= targetMid)
                {
                    if (orientation == Orientation.Horizontal)
                    {
                        SetTranslateTransform(targetContainer, -draggedBounds.Width, 0);
                    }
                    else
                    {
                        SetTranslateTransform(targetContainer, 0, -draggedBounds.Height);
                    }

                    _targetIndex = _targetIndex == -1 ? targetIndex :
                        targetIndex > _targetIndex ? targetIndex : _targetIndex;
                }
                else if (targetStart < draggedStart && draggedDeltaStart <= targetMid)
                {
                    if (orientation == Orientation.Horizontal)
                    {
                        SetTranslateTransform(targetContainer, draggedBounds.Width, 0);
                    }
                    else
                    {
                        SetTranslateTransform(targetContainer, 0, draggedBounds.Height);
                    }

                    _targetIndex = _targetIndex == -1 ? targetIndex :
                        targetIndex < _targetIndex ? targetIndex : _targetIndex;
                }
                else
                {
                    if (orientation == Orientation.Horizontal)
                    {
                        SetTranslateTransform(targetContainer, 0, 0);
                    }
                    else
                    {
                        SetTranslateTransform(targetContainer, 0, 0);
                    }
                }
            }
        }
    }

    private void SetDraggingPseudoClasses(Control control, bool isDragging)
    {
        if (isDragging)
        {
            ((IPseudoClasses)control.Classes).Add(":dragging");
        }
        else
        {
            ((IPseudoClasses)control.Classes).Remove(":dragging");
        }
    }

    private void SetTranslateTransform(Control control, double x, double y)
    {
        var transformBuilder = new TransformOperations.Builder(1);
        transformBuilder.AppendTranslate(x, y);
        control.RenderTransform = transformBuilder.Build();
    }
}


发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\UI\Styling\CustomTheme.axaml.cs
/ </summary>
public class CustomTheme : Styles, IResourceProvider
{
    public const string LightModeString = "Light";
    public const string DarkModeString = "Dark";
    public const string HighContrastModeString = "HighContrast";

    public static readonly ThemeVariant HighContrastTheme = new ThemeVariant(HighContrastModeString,
        ThemeVariant.Light);

    private readonly Uri? _baseUri;
    private bool _hasLoaded;

    public static readonly StyledProperty<string> ModeProperty =
        AvaloniaProperty.Register<CustomTheme, string>(nameof(Mode), DarkModeString);

    
/ </summary>
    public string Mode
    {
        get => GetValue(ModeProperty);
        set => SetValue(ModeProperty, value);
    }

    public CustomTheme(Uri baseUri)
    {
        _baseUri = baseUri;
        Init();
    }

    public CustomTheme(IServiceProvider serviceProvider)
    {
        _baseUri = ((IUriContext?)serviceProvider.GetService(typeof(IUriContext)))?.BaseUri;
        Init();
    }

    void Init()
    {
        AvaloniaXamlLoader.Load(this);
        
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\UI\Views\Abstractions\Pages\PageBase.cs
/ Initializes a new instance of the <see cref="PageBase{TViewModel}"/> class.
    
/ </summary>
    public PageBase() : base()
    {
        
/ </summary>
    public TViewModel? ViewModel
    {
        get => GetValue(ViewModelProperty);
        set => SetValue(ViewModelProperty, value);
    }

    object? IViewFor.ViewModel
    {
        get => ViewModel;
        set => ViewModel = (TViewModel?)value;
    }

    protected override void OnDataContextChanged(EventArgs e)
    {
        base.OnDataContextChanged(e);
        ViewModel = DataContext as TViewModel;
    }

    private void OnViewModelChanged(object? value)
    {
        if (value == null)
        {
            ClearValue(DataContextProperty);
        }
        else if (DataContext != value)
        {
            DataContext = value;
        }
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\UI\Views\Abstractions\Windows\ReactiveAppWindow.cs
/ A ReactiveUI <see cref="Window"/> that implements the <see cref="IViewFor{TViewModel}"/> interface and will

/ activate your ViewModel automatically if the view model implements <see cref="IActivatableViewModel"/>. When

/ </summary>

/ <typeparam name="TViewModel">ViewModel type.</typeparam>
public class ReactiveAppWindow<TViewModel> : AppWindow, IViewFor<TViewModel>, IViewFor, IActivatableView where TViewModel : class
{
    public static readonly StyledProperty<TViewModel?> ViewModelProperty = ReactiveWindow<TViewModel>.ViewModelProperty.AddOwner<ReactiveAppWindow<TViewModel>>();

    public static readonly StyledProperty<bool> IsSaveWindowSizeProperty = AvaloniaProperty
        .Register<ReactiveAppWindow<TViewModel>, bool>(nameof(IsSaveWindowSize), true);

    private bool _isInitialize;

    
/ Initializes a new instance of the <see cref="ReactiveAppWindow{TViewModel}"/> class.
    
/ </summary>
    public ReactiveAppWindow() : base()
    {
#if WINDOWS
        if (OperatingSystem2.IsWindows() && !Design.IsDesignMode)
        {
            if (!GeneralSettings.GPU.Value)
            {
                var hWND = this.TryGetPlatformHandle()?.Handle;
                if (hWND != null)
                    IPlatformService.Instance.BeautifyTheWindow(hWND.Value);
            }
            else if (UISettings.WindowBackgroundMaterial.Value is WindowBackgroundMaterial.None or WindowBackgroundMaterial.Blur)
            {
                var hWND = this.TryGetPlatformHandle()?.Handle;
                if (hWND != null)
                    IPlatformService.Instance.BeautifyTheWindow(hWND.Value);
            }
        }
#endif

        
/ </summary>
    public TViewModel? ViewModel
    {
        get => GetValue(ViewModelProperty);
        set => SetValue(ViewModelProperty, value);
    }

    object? IViewFor.ViewModel
    {
        get => ViewModel;
        set => ViewModel = (TViewModel?)value;
    }

    private void OnDataContextChanged(object? value)
    {
        if (value is TViewModel viewModel)
        {
            ViewModel = viewModel;
        }
        else
        {
            ViewModel = null;
        }
    }

    private void OnViewModelChanged(object? value)
    {
        if (value == null)
        {
            ClearValue(DataContextProperty);
        }
        else if (DataContext != value)
        {
            DataContext = value;
        }
    }

    public override void Show()
    {
        if (IsSaveWindowSize && SizePosition != null)
        {
            var screen = Screens.ScreenFromPoint(Position);
            if (screen != null)
            {
                var primaryScreenBounds = screen.Bounds;

                if (CanResize && !_isInitialize && !IsVisible)
                {
                    WindowStartupLocation = WindowStartupLocation.Manual;
                    var scalingOffset = 31 - ((screen.Scaling - 1) / 0.5); 
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Avalonia\UI\Views\Abstractions\Windows\ReactiveAppWindow.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\UI\Views\Controls\AdControl.axaml.cs
/ Defines the <see cref="AutoScroll"/> property.
    
/ </summary>
    public static readonly StyledProperty<bool> SupportCloseProperty =
        AvaloniaProperty.Register<AdControl, bool>(nameof(SupportClose), false);

    
/ Defines the <see cref="AutoScrollInterval"/> property.
    
/ </summary>
    public static readonly StyledProperty<AdvertisementOrientation> StandardProperty =
        AvaloniaProperty.Register<AdControl, AdvertisementOrientation>(nameof(Standard), AdvertisementOrientation.Horizontal);

    
/ </summary>
    public bool SupportClose
    {
        get => GetValue(SupportCloseProperty);
        set => SetValue(SupportCloseProperty, value);
    }

    
/ </summary>
    public AdvertisementOrientation Standard
    {
        get => GetValue(StandardProperty);
        set => SetValue(StandardProperty, value);
    }

    public AdControl()
    {
        InitializeComponent();

        if (CloseAdBtn != null)
        {
            this.GetObservable(SupportCloseProperty)
                .Subscribe(x => CloseAdBtn.IsVisible = x);

            CloseAdBtn.Click += (s, e) =>
            {
                RemoveAd();
            };
        }

        if (AdBanner != null)
        {
            this.GetObservable(StandardProperty)
                .Subscribe(x =>
                {
                    var bind = new Binding()
                    {
                        Source = AdvertiseService.Current,
                        Mode = BindingMode.OneWay,
                    };

                    if (Standard == AdvertisementOrientation.Vertical)
                    {
                        bind.Path = nameof(AdvertiseService.Current.VerticalBannerAdvertisements);
                    }
                    else
                    {
                        bind.Path = nameof(AdvertiseService.Current.HorizontalBannerAdvertisements);
                    }
                    AdBanner.Bind(CarouselBanner.ItemsSourceProperty, bind);
                });

            
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\UI\Views\Controls\ContentLoader.cs
/ Defines the <see cref="IsLoading"/> property
    
/ </summary>
    public static readonly StyledProperty<bool> IsLoadingProperty =
        AvaloniaProperty.Register<ContentLoader, bool>(nameof(IsLoading), true);

    
/ Defines the <see cref="NoResultMessage"/> property
    
/ </summary>
    public static readonly StyledProperty<object?> NoResultMessageProperty =
        AvaloniaProperty.Register<ContentLoader, object?>(nameof(NoResultMessage), null);

    
/ Defines the <see cref="ProgressValue"/> property
    
/ </summary>
    public static readonly StyledProperty<double> ProgressValueProperty =
        ProgressBar.ValueProperty.AddOwner<ContentLoader>();

    
/ Defines the <see cref="Minimum"/> property
    
/ </summary>
    public static readonly StyledProperty<double> MinimumProperty =
        ProgressBar.MinimumProperty.AddOwner<ContentLoader>();

    
/ Defines the <see cref="Maximum"/> property
    
/ </summary>
    public static readonly StyledProperty<double> MaximumProperty =
        ProgressBar.MaximumProperty.AddOwner<ContentLoader>();

    
/ Defines the <see cref="IsIndeterminate"/> property
    
/ </summary>
    public static readonly StyledProperty<bool> IsIndeterminateProperty =
        AvaloniaProperty.Register<ContentLoader, bool>(nameof(IsIndeterminate), true);

    
/ Defines the <see cref="IsShowNoResultText"/> property
    
/ </summary>
    public static readonly StyledProperty<bool> IsShowNoResultTextProperty =
        AvaloniaProperty.Register<ContentLoader, bool>(nameof(IsShowNoResultText), false);

    
/ Defines the <see cref="CustomLoadingText"/> property
    
/ </summary>
    public static readonly StyledProperty<string?> CustomLoadingTextProperty =
        AvaloniaProperty.Register<ContentLoader, string?>(nameof(CustomLoadingText), null);

    
/ </summary>
    public bool IsLoading
    {
        get => GetValue(IsLoadingProperty);
        set => SetValue(IsLoadingProperty, value);
    }

    public bool IsIndeterminate
    {
        get => GetValue(IsIndeterminateProperty);
        set => SetValue(IsIndeterminateProperty, value);
    }

    public bool IsShowNoResultText
    {
        get => GetValue(IsShowNoResultTextProperty);
        set => SetValue(IsShowNoResultTextProperty, value);
    }

    
/ </summary>
    public string? CustomLoadingText
    {
        get => GetValue(CustomLoadingTextProperty);
        set => SetValue(CustomLoadingTextProperty, value);
    }

    
/ </summary>
    public object? NoResultMessage
    {
        get => GetValue(NoResultMessageProperty);
        set => SetValue(NoResultMessageProperty, value);
    }

    
/ </summary>
    public double ProgressValue
    {
        get => GetValue(ProgressValueProperty);
        set => SetValue(ProgressValueProperty, value);
    }

    public double Minimum
    {
        get => GetValue(MinimumProperty);
        set => SetValue(MinimumProperty, value);
    }

    public double Maximum
    {
        get => GetValue(MaximumProperty);
        set => SetValue(MaximumProperty, value);
    }

    
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\UI\Views\Controls\CustomFilePicker.cs
/docs.microsoft.com/zh-cn/archive/blogs/patricka/q-why-doesnt-drag-and-drop-work-when-my-application-is-running-elevated-a-mandatory-integrity-control-and-uipi?tdsourcetag=s_pctim_aiomsg

        void DragOver(object? sender, DragEventArgs e)
        {
            
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\UI\Views\Controls\SnackbarManager.cs
/ An <see cref="INotificationManager"/> that displays notifications in a <see cref="Window"/>.

/ </summary>
[TemplatePart("PART_Items", typeof(Panel))]
[PseudoClasses(":topleft", ":topright", ":bottomleft", ":bottomright")]
public class SnackbarManager : TemplatedControl, IManagedNotificationManager
{
    private IList? _items;

    
/ Defines the <see cref="Position"/> property.
    
/ </summary>
    public static readonly StyledProperty<NotificationPosition> PositionProperty =
      AvaloniaProperty.Register<SnackbarManager, NotificationPosition>(nameof(Position), NotificationPosition.BottomRight);

    
/ </summary>
    
/ <seealso cref="NotificationPosition"/>
    public NotificationPosition Position
    {
        get { return GetValue(PositionProperty); }
        set { SetValue(PositionProperty, value); }
    }

    
/ Defines the <see cref="MaxItems"/> property.
    
/ </summary>
    public static readonly StyledProperty<int> MaxItemsProperty =
      AvaloniaProperty.Register<SnackbarManager, int>(nameof(MaxItems), 5);

    
/ </summary>
    public int MaxItems
    {
        get { return GetValue(MaxItemsProperty); }
        set { SetValue(MaxItemsProperty, value); }
    }

    
/ Initializes a new instance of the <see cref="SnackbarManager"/> class.
    
/ </summary>
    public SnackbarManager()
    {
        UpdatePseudoClasses(Position);
    }

    
/ Initializes a new instance of the <see cref="SnackbarManager"/> class.
    
/ </summary>
    
/ <param name="host">The window that will host the control.</param>
    public SnackbarManager(TopLevel? host)
    {
        if (host != null)
        {
            Install(host);
        }
        else
        {
            Log.Error("SnackbarManager", "Install Faild, host is null");
        }

        UpdatePseudoClasses(Position);
    }

    static SnackbarManager()
    {
        HorizontalAlignmentProperty.OverrideDefaultValue<SnackbarManager>(HorizontalAlignment.Stretch);
        VerticalAlignmentProperty.OverrideDefaultValue<SnackbarManager>(VerticalAlignment.Stretch);
    }

    
/ <inheritdoc/>
    protected override void OnApplyTemplate(TemplateAppliedEventArgs e)
    {
        var itemsControl = e.NameScope.Find<Panel>("PART_Items");
        _items = itemsControl?.Children;
    }

    public void Show(string message, string? title = null, NotificationType notificationType = NotificationType.Information)
    {
        Show(new Avalonia.Controls.Notifications.Notification(title, message, notificationType));
    }

    public void Show(INotification content)
    {
        Show(content as object);
    }

    
/ <inheritdoc/>
    public async void Show(object content)
    {
        var notification = content as INotification;

        var infoBarControl = new Snackbar
        {
            MaxWidth = 500,
            IsOpen = true,
            IsClosable = true,
            Severity = InfoBarSeverity.Informational,
        };

        if (notification != null)
        {
            infoBarControl.Title = notification.Title;
            infoBarControl.Message = notification.Message;
            infoBarControl.Severity = notification.Type switch
            {
                NotificationType.Warning => InfoBarSeverity.Warning,
                NotificationType.Success => InfoBarSeverity.Success,
                NotificationType.Error => InfoBarSeverity.Error,
                _ => InfoBarSeverity.Informational,
            };

            if (notification.OnClick != null)
            {
                infoBarControl.ActionButton = new Button
                {
                    Content = notification.Title,
                    Command = ReactiveCommand.Create(notification.OnClick),
                    HorizontalAlignment = HorizontalAlignment.Right,
                };
            }
        }
        else
        {
            infoBarControl.Message = content.ToString();
        }

        infoBarControl.Closed += (sender, args) =>
        {
            notification?.OnClose?.Invoke();
            _items?.Remove(sender);
        };

        _items?.Add(infoBarControl);

        if (_items?.OfType<Snackbar>().Count(i => !i.IsClosing) > MaxItems)
        {
            _items.OfType<Snackbar>().First(i => !i.IsClosing).Close();
        }

        if (notification != null && notification.Expiration == TimeSpan.Zero)
        {
            return;
        }

        await Task.Delay(notification?.Expiration ?? TimeSpan.FromSeconds(5));

        infoBarControl.Close();
    }

    protected override void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change)
    {
        base.OnPropertyChanged(change);

        if (change.Property == PositionProperty)
        {
            UpdatePseudoClasses(change.GetNewValue<NotificationPosition>());
        }
    }

    
/ Installs the <see cref="WindowNotificationManager"/> within the <see cref="AdornerLayer"/>
    
/ of the host <see cref="Window"/>.
    
/ </summary>
    
/ <param name="host">The <see cref="Window"/> that will be the host.</param>
    public void Install(TemplatedControl host)
    {
        var adornerLayer = host.FindDescendantOfType<VisualLayerManager>()?.AdornerLayer;

        if (adornerLayer is not null && !adornerLayer.Children.Contains(this))
        {
            adornerLayer.ZIndex = int.MaxValue;
            adornerLayer.Children.Add(this);
            AdornerLayer.SetAdornedElement(this, adornerLayer);

            var overlayLayer = OverlayLayer.GetOverlayLayer(host);
            
/ <inheritdoc/>
    public void Close(INotification notification)
    {
        Dispatcher.UIThread.VerifyAccess();

        
/ <inheritdoc/>
    public void Close(object content)
    {
        Dispatcher.UIThread.VerifyAccess();

        
/ <inheritdoc/>
    public void CloseAll()
    {
        Dispatcher.UIThread.VerifyAccess();

        
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\UI\Views\Controls\TitleBar.axaml.cs
/ Defines the <see cref="Icon"/> property.
    
/ </summary>
    public static readonly StyledProperty<IImage?> IconProperty =
        Image.SourceProperty.AddOwner<TitleBar>();

    
/ Defines the <see cref="ActionContent"/> property.
    
/ </summary>
    public static readonly StyledProperty<object?> ActionContentProperty =
        AvaloniaProperty.Register<TitleBar, object?>(nameof(ActionContent));

    
/ Defines the <see cref="IsShowSearchBox"/> property.
    
/ </summary>
    public static readonly StyledProperty<bool> IsShowSearchBoxProperty =
        AvaloniaProperty.Register<TitleBar, bool>(nameof(IsShowSearchBox));

    
/ Defines the <see cref="SearchText"/> property.
    
/ </summary>
    public static readonly StyledProperty<string> SearchTextProperty =
        AvaloniaProperty.Register<TitleBar, string>(nameof(SearchText));

    public IImage? Icon
    {
        get { return GetValue(IconProperty); }
        set { SetValue(IconProperty, value); }
    }

    public object? ActionContent
    {
        get { return GetValue(ActionContentProperty); }
        set { SetValue(ActionContentProperty, value); }
    }

    public bool IsShowSearchBox
    {
        get { return GetValue(IsShowSearchBoxProperty); }
        set { SetValue(IsShowSearchBoxProperty, value); }
    }

    public string SearchText
    {
        get { return GetValue(SearchTextProperty); }
        set { SetValue(SearchTextProperty, value); }
    }

    public TitleBar()
    {
        InitializeComponent();
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\UI\Views\Controls\Flex\Flex.cs
/ </summary>
    public static readonly AttachedProperty<AlignItems?> AlignSelfProperty =
        AvaloniaProperty.RegisterAttached<Layoutable, AlignItems?>("AlignSelf", typeof(Flex));

    
/ </summary>
    public static readonly AttachedProperty<int> OrderProperty =
        AvaloniaProperty.RegisterAttached<Layoutable, int>("Order", typeof(Flex));

    public static readonly AttachedProperty<FlexBasis> BasisProperty =
        AvaloniaProperty.RegisterAttached<Layoutable, FlexBasis>("Basis", typeof(Flex), FlexBasis.Auto);

    public static readonly AttachedProperty<double> ShrinkProperty =
        AvaloniaProperty.RegisterAttached<Layoutable, double>("Shrink", typeof(Flex), 1.0, validate: v => v >= 0.0);

    public static readonly AttachedProperty<double> GrowProperty =
        AvaloniaProperty.RegisterAttached<Layoutable, double>("Grow", typeof(Flex), 0.0, validate: v => v >= 0.0);

    internal static readonly AttachedProperty<double> BaseLengthProperty =
        AvaloniaProperty.RegisterAttached<Layoutable, double>("BaseLength", typeof(Flex), 0.0);

    internal static readonly AttachedProperty<double> CurrentLengthProperty =
        AvaloniaProperty.RegisterAttached<Layoutable, double>("CurrentLength", typeof(Flex), 0.0);

    
/ </summary>
    public static AlignItems? GetAlignSelf(Layoutable layoutable)
    {
        if (layoutable is null)
        {
            throw new ArgumentNullException(nameof(layoutable));
        }

        return layoutable.GetValue(AlignSelfProperty);
    }

    
/ </summary>
    public static void SetAlignSelf(Layoutable layoutable, AlignItems? value)
    {
        if (layoutable is null)
        {
            throw new ArgumentNullException(nameof(layoutable));
        }

        layoutable.SetValue(AlignSelfProperty, value);
    }

    
/ </summary>
    public static int GetOrder(Layoutable layoutable)
    {
        if (layoutable is null)
        {
            throw new ArgumentNullException(nameof(layoutable));
        }

        return layoutable.GetValue(OrderProperty);
    }

    
/ </summary>
    public static void SetOrder(Layoutable layoutable, int value)
    {
        if (layoutable is null)
        {
            throw new ArgumentNullException(nameof(layoutable));
        }

        layoutable.SetValue(OrderProperty, value);
    }

    public static FlexBasis GetBasis(Layoutable layoutable)
    {
        if (layoutable is null)
        {
            throw new ArgumentNullException(nameof(layoutable));
        }

        return layoutable.GetValue(BasisProperty);
    }

    public static void SetBasis(Layoutable layoutable, FlexBasis value)
    {
        if (layoutable is null)
        {
            throw new ArgumentNullException(nameof(layoutable));
        }

        layoutable.SetValue(BasisProperty, value);
    }

    public static double GetShrink(Layoutable layoutable)
    {
        if (layoutable is null)
        {
            throw new ArgumentNullException(nameof(layoutable));
        }

        return layoutable.GetValue(ShrinkProperty);
    }

    public static void SetShrink(Layoutable layoutable, double value)
    {
        if (layoutable is null)
        {
            throw new ArgumentNullException(nameof(layoutable));
        }

        layoutable.SetValue(ShrinkProperty, value);
    }

    public static double GetGrow(Layoutable layoutable)
    {
        if (layoutable is null)
        {
            throw new ArgumentNullException(nameof(layoutable));
        }

        return layoutable.GetValue(GrowProperty);
    }

    public static void SetGrow(Layoutable layoutable, double value)
    {
        if (layoutable is null)
        {
            throw new ArgumentNullException(nameof(layoutable));
        }

        layoutable.SetValue(GrowProperty, value);
    }

    internal static double GetBaseLength(Layoutable layoutable)
    {
        if (layoutable is null)
        {
            throw new ArgumentNullException(nameof(layoutable));
        }

        return layoutable.GetValue(BaseLengthProperty);
    }

    internal static void SetBaseLength(Layoutable layoutable, double value)
    {
        if (layoutable is null)
        {
            throw new ArgumentNullException(nameof(layoutable));
        }

        layoutable.SetValue(BaseLengthProperty, value);
    }

    internal static double GetCurrentLength(Layoutable layoutable)
    {
        if (layoutable is null)
        {
            throw new ArgumentNullException(nameof(layoutable));
        }

        return layoutable.GetValue(CurrentLengthProperty);
    }

    internal static void SetCurrentLength(Layoutable layoutable, double value)
    {
        if (layoutable is null)
        {
            throw new ArgumentNullException(nameof(layoutable));
        }

        layoutable.SetValue(CurrentLengthProperty, value);
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\UI\Views\Controls\Flex\FlexPanel.cs
/ Defines the <see cref="Direction"/> property.
    
/ </summary>
    public static readonly StyledProperty<FlexDirection> DirectionProperty =
        AvaloniaProperty.Register<FlexPanel, FlexDirection>(nameof(Direction));

    
/ Defines the <see cref="JustifyContent"/> property.
    
/ </summary>
    public static readonly StyledProperty<JustifyContent> JustifyContentProperty =
        AvaloniaProperty.Register<FlexPanel, JustifyContent>(nameof(JustifyContent));

    
/ Defines the <see cref="AlignItems"/> property.
    
/ </summary>
    public static readonly StyledProperty<AlignItems> AlignItemsProperty =
        AvaloniaProperty.Register<FlexPanel, AlignItems>(nameof(AlignItems));

    
/ Defines the <see cref="AlignContent"/> property.
    
/ </summary>
    public static readonly StyledProperty<AlignContent> AlignContentProperty =
        AvaloniaProperty.Register<FlexPanel, AlignContent>(nameof(AlignContent));

    
/ Defines the <see cref="Wrap"/> property.
    
/ </summary>
    public static readonly StyledProperty<FlexWrap> WrapProperty =
        AvaloniaProperty.Register<FlexPanel, FlexWrap>(nameof(Wrap), FlexWrap.Wrap);

    
/ Defines the <see cref="ColumnSpacing"/> property.
    
/ </summary>
    public static readonly StyledProperty<double> ColumnSpacingProperty =
        AvaloniaProperty.Register<FlexPanel, double>(nameof(ColumnSpacing));

    
/ Defines the <see cref="RowSpacing"/> property.
    
/ </summary>
    public static readonly StyledProperty<double> RowSpacingProperty =
        AvaloniaProperty.Register<FlexPanel, double>(nameof(RowSpacing));

    private FlexLayoutState? _state;

    static FlexPanel()
    {
        AffectsMeasure<FlexPanel>(
            DirectionProperty,
            JustifyContentProperty,
            WrapProperty,
            ColumnSpacingProperty,
            RowSpacingProperty);

        AffectsArrange<FlexPanel>(
            AlignItemsProperty,
            AlignContentProperty);

        AffectsParentMeasure<FlexPanel>(
            HorizontalAlignmentProperty,
            VerticalAlignmentProperty,
            Flex.OrderProperty,
            Flex.BasisProperty,
            Flex.ShrinkProperty,
            Flex.GrowProperty);

        AffectsParentArrange<FlexPanel>(
            Flex.AlignSelfProperty);
    }

    
/ </summary>
    public FlexDirection Direction
    {
        get => GetValue(DirectionProperty);
        set => SetValue(DirectionProperty, value);
    }

    
/ </summary>
    public JustifyContent JustifyContent
    {
        get => GetValue(JustifyContentProperty);
        set => SetValue(JustifyContentProperty, value);
    }

    
/ </summary>
    public AlignItems AlignItems
    {
        get => GetValue(AlignItemsProperty);
        set => SetValue(AlignItemsProperty, value);
    }

    
/ </summary>
    public AlignContent AlignContent
    {
        get => GetValue(AlignContentProperty);
        set => SetValue(AlignContentProperty, value);
    }

    
/ </summary>
    public FlexWrap Wrap
    {
        get => GetValue(WrapProperty);
        set => SetValue(WrapProperty, value);
    }

    
/ </summary>
    public double ColumnSpacing
    {
        get => GetValue(ColumnSpacingProperty);
        set => SetValue(ColumnSpacingProperty, value);
    }

    
/ </summary>
    public double RowSpacing
    {
        get => GetValue(RowSpacingProperty);
        set => SetValue(RowSpacingProperty, value);
    }

    
/ <inheritdoc />
    protected override Size MeasureOverride(Size availableSize)
    {
        var children = (IReadOnlyList<Layoutable>)Children;

        var isColumn = Direction is FlexDirection.Column or FlexDirection.ColumnReverse;

        var max = Uv.FromSize(availableSize, isColumn);
        var spacing = Uv.FromSize(ColumnSpacing, RowSpacing, isColumn);

        var (lineU, lineV, lineShrink, lineGrow, lineAutoMargins) = (0.0, 0.0, 0.0, 0.0, 0);
        var (childIndex, firstChildIndex, itemIndex, lineIndex) = (0, 0, 0, 0);

        var lines = new List<FlexLine>();
        children = children.Where(s_isVisible).OrderBy(s_getOrder).ToArray();

        foreach (var element in children)
        {
            var basis = Flex.GetBasis(element);
            var flexConstraint = basis.Kind switch
            {
                FlexBasisKind.Auto => max.U,
                FlexBasisKind.Absolute => basis.Value,
                FlexBasisKind.Relative => max.U * basis.Value / 100,
                _ => throw new InvalidOperationException()
            };
            element.Measure(Uv.ToSize(max.WithU(flexConstraint), isColumn));

            var size = Uv.FromSize(element.DesiredSize, isColumn);
            var flexLength = basis.Kind switch
            {
                FlexBasisKind.Auto => size.U,
                FlexBasisKind.Absolute or FlexBasisKind.Relative => Math.Max(size.U, flexConstraint),
                _ => throw new InvalidOperationException()
            };
            size = size.WithU(flexLength);
            Flex.SetBaseLength(element, flexLength);
            Flex.SetCurrentLength(element, flexLength);

            if (Wrap != FlexWrap.NoWrap && lineU + size.U + itemIndex * spacing.U > max.U)
            {
                lines.Add(new FlexLine(firstChildIndex, childIndex - 1,
                    lineU, lineV, lineShrink, lineGrow, lineAutoMargins));
                (lineU, lineV, lineShrink, lineGrow, lineAutoMargins) = (0.0, 0.0, 0.0, 0.0, 0);
                firstChildIndex = childIndex;
                itemIndex = 0;
                lineIndex++;
            }

            lineU += size.U;
            lineV = Math.Max(lineV, size.V);
            lineShrink += Flex.GetShrink(element);
            lineGrow += Flex.GetGrow(element);
            lineAutoMargins += GetItemAutoMargins(element, isColumn);
            itemIndex++;
            childIndex++;
        }

        if (itemIndex != 0)
        {
            lines.Add(new FlexLine(firstChildIndex, firstChildIndex + itemIndex - 1,
                lineU, lineV, lineShrink, lineGrow, lineAutoMargins));
        }

        var state = new FlexLayoutState(children, lines, Wrap);

        var totalSpacingV = (lines.Count - 1) * spacing.V;
        var panelSizeU = lines.Count > 0 ? lines.Max(line => line.U + (line.Count - 1) * spacing.U) : 0.0;

        
/ Reizing along main axis using grow and shrink factors can affect cross axis, so remeasure affected items and lines.
        foreach (var line in lines)
        {
            var (itemsCount, totalSpacingU, totalU, freeU) = GetLineMeasureU(line, max.U, spacing.U);
            var (lineMult, autoMargins, remainingFreeU) = GetLineMultInfo(line, freeU);
            if (lineMult != 0.0 && remainingFreeU != 0.0)
            {
                foreach (var element in state.GetLineItems(line))
                {
                    var baseLength = Flex.GetBaseLength(element);
                    var mult = GetItemMult(element, freeU);
                    if (mult != 0.0)
                    {
                        var length = Math.Max(0.0, baseLength + remainingFreeU * mult / lineMult);
                        element.Measure(Uv.ToSize(max.WithU(length), isColumn));
                    }
                }

                line.V = state.GetLineItems(line).Max(i => Uv.FromSize(i.DesiredSize, isColumn).V);
            }
        }

        _state = state;
        var totalLineV = lines.Sum(l => l.V);
        var panelSize = lines.Count == 0 ? default : new Uv(panelSizeU, totalLineV + totalSpacingV);
        return Uv.ToSize(panelSize, isColumn);
    }

    
/ <inheritdoc />
    protected override Size ArrangeOverride(Size finalSize)
    {
        var state = _state ?? throw new InvalidOperationException();

        var isColumn = Direction is FlexDirection.Column or FlexDirection.ColumnReverse;
        var isReverse = Direction is FlexDirection.RowReverse or FlexDirection.ColumnReverse;

        var panelSize = Uv.FromSize(finalSize, isColumn);
        var spacing = Uv.FromSize(ColumnSpacing, RowSpacing, isColumn);

        var linesCount = state.Lines.Count;
        var totalLineV = state.Lines.Sum(s => s.V);
        var totalSpacingV = (linesCount - 1) * spacing.V;
        var totalV = totalLineV + totalSpacingV;
        var freeV = panelSize.V - totalV;

        var alignContent = freeV >= 0.0 ? AlignContent : AlignContent switch
        {
            AlignContent.FlexStart or AlignContent.Stretch or AlignContent.SpaceBetween => AlignContent.FlexStart,
            AlignContent.Center or AlignContent.SpaceAround or AlignContent.SpaceEvenly => AlignContent.Center,
            AlignContent.FlexEnd => AlignContent.FlexEnd,
            _ => throw new InvalidOperationException()
        };

        var (spacingV, v) = alignContent switch
        {
            AlignContent.FlexStart => (spacing.V, 0.0),
            AlignContent.FlexEnd => (spacing.V, freeV),
            AlignContent.Center => (spacing.V, freeV / 2),
            AlignContent.Stretch => (spacing.V, 0.0),
            AlignContent.SpaceBetween => (spacing.V + freeV / (linesCount - 1), 0.0),
            AlignContent.SpaceAround => (spacing.V + freeV / linesCount, freeV / linesCount / 2),
            AlignContent.SpaceEvenly => (spacing.V + freeV / (linesCount + 1), freeV / (linesCount + 1)),
            _ => throw new InvalidOperationException()
        };

        var scaleV = alignContent == AlignContent.Stretch ? (panelSize.V - totalSpacingV) / totalLineV : 1.0;

        foreach (var line in state.Lines)
        {
            var lineV = scaleV * line.V;
            var (itemsCount, totalSpacingU, totalU, freeU) = GetLineMeasureU(line, panelSize.U, spacing.U);
            var (lineMult, lineAutoMargins, remainingFreeU) = GetLineMultInfo(line, freeU);

            var currentFreeU = remainingFreeU;
            if (lineMult != 0.0 && remainingFreeU != 0.0)
            {
                foreach (var element in state.GetLineItems(line))
                {
                    var baseLength = Flex.GetBaseLength(element);
                    var mult = GetItemMult(element, freeU);
                    if (mult != 0.0)
                    {
                        var length = Math.Max(0.0, baseLength + remainingFreeU * mult / lineMult);
                        Flex.SetCurrentLength(element, length);
                        currentFreeU -= length - baseLength;
                    }
                }
            }
            remainingFreeU = currentFreeU;

            if (lineAutoMargins != 0 && remainingFreeU != 0.0)
            {
                foreach (var element in state.GetLineItems(line))
                {
                    var baseLength = Flex.GetCurrentLength(element);
                    var autoMargins = GetItemAutoMargins(element, isColumn);
                    if (autoMargins != 0)
                    {
                        var length = Math.Max(0.0, baseLength + remainingFreeU * autoMargins / lineAutoMargins);
                        Flex.SetCurrentLength(element, length);
                        currentFreeU -= length - baseLength;
                    }
                }
            }
            remainingFreeU = currentFreeU;

            var (spacingU, u) = line.Grow > 0 ? (spacing.U, 0.0) : JustifyContent switch
            {
                JustifyContent.FlexStart => (spacing.U, 0.0),
                JustifyContent.FlexEnd => (spacing.U, remainingFreeU),
                JustifyContent.Center => (spacing.U, remainingFreeU / 2),
                JustifyContent.SpaceBetween => (spacing.U + remainingFreeU / (itemsCount - 1), 0.0),
                JustifyContent.SpaceAround => (spacing.U + remainingFreeU / itemsCount, remainingFreeU / itemsCount / 2),
                JustifyContent.SpaceEvenly => (spacing.U + remainingFreeU / (itemsCount + 1), remainingFreeU / (itemsCount + 1)),
                _ => throw new InvalidOperationException()
            };

            foreach (var element in state.GetLineItems(line))
            {
                var size = Uv.FromSize(element.DesiredSize, isColumn).WithU(Flex.GetCurrentLength(element));
                var align = Flex.GetAlignSelf(element) ?? AlignItems;

                var positionV = align switch
                {
                    AlignItems.FlexStart => v,
                    AlignItems.FlexEnd => v + lineV - size.V,
                    AlignItems.Center => v + (lineV - size.V) / 2,
                    AlignItems.Stretch => v,
                    _ => throw new InvalidOperationException()
                };

                size = size.WithV(align == AlignItems.Stretch ? lineV : size.V);
                var position = new Uv(isReverse ? panelSize.U - size.U - u : u, positionV);
                element.Arrange(new Rect(Uv.ToPoint(position, isColumn), Uv.ToSize(size, isColumn)));

                u += size.U + spacingU;
            }

            v += lineV + spacingV;
        }

        return finalSize;
    }

    private static (int ItemsCount, double TotalSpacingU, double TotalU, double FreeU) GetLineMeasureU(
        FlexLine line, double panelSizeU, double spacingU)
    {
        var itemsCount = line.Count;
        var totalSpacingU = (itemsCount - 1) * spacingU;
        var totalU = line.U + totalSpacingU;
        var freeU = panelSizeU - totalU;
        return (itemsCount, totalSpacingU, totalU, freeU);
    }

    private static (double LineMult, double LineAutoMargins, double RemainingFreeU) GetLineMultInfo(FlexLine line, double freeU)
    {
        var lineMult = freeU switch
        {
            < 0 => line.Shrink,
            > 0 => line.Grow,
            _ => 0.0,
        };
        
/www.w3.org/TR/css-flexbox-1/#remaining-free-space
        
/ <summary>First item index.</summary>
        public int First { get; }

        
/ <summary>Last item index.</summary>
        public int Last { get; }

        
/ <summary>Sum of main sizes of items.</summary>
        public double U { get; }

        
/ <summary>Max of cross sizes of items.</summary>
        public double V { get; set; }

        
/ <summary>Sum of shrink factors of flexible items.</summary>
        public double Shrink { get; }

        
/ <summary>Sum of grow factors of flexible items.</summary>
        public double Grow { get; }

        
/ <summary>Number of "auto margins" along main axis.</summary>
        public int AutoMargins { get; }

        
/ <summary>Number of items.</summary>
        public int Count => Last - First + 1;
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\UI\Views\Controls\Shapes\PureRectangle.cs
/ </summary>
public class PureRectangle : Control
{
    public static readonly StyledProperty<IBrush?> BackgroundProperty =
        Border.BackgroundProperty.AddOwner<PureRectangle>();

    public IBrush? Background
    {
        get => GetValue(BackgroundProperty);
        set => SetValue(BackgroundProperty, value);
    }

    static PureRectangle()
    {
        AffectsRender<PureRectangle>(BackgroundProperty);
    }

    public override void Render(DrawingContext context)
    {
        base.Render(context);
        context.DrawRectangle(Background, null, new Rect(Bounds.Size));
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\UI\Views\Controls\Shapes\PureRing.cs
/ 2;
        double inner = InnerDiameter / 2;
        double thickness = outer - inner;
        context.DrawEllipse(null,
            new Pen(Background, outer - inner),
            new Point(outer, outer),
            outer - thickness / 2,
            outer - thickness / 2);
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\UI\Views\Controls\Widgets\CarouselBanner.axaml.cs
/ Defines the <see cref="AutoScroll"/> property.
        
/ </summary>
        public static readonly StyledProperty<bool> AutoScrollProperty =
            AvaloniaProperty.Register<CarouselBanner, bool>(nameof(AutoScroll), true);

        
/ Defines the <see cref="AutoScrollInterval"/> property.
        
/ </summary>
        public static readonly StyledProperty<int> AutoScrollIntervalProperty =
            AvaloniaProperty.Register<CarouselBanner, int>(nameof(AutoScrollInterval), 6000);

        
/ </summary>
        public static readonly StyledProperty<IEnumerable?> ItemsSourceProperty =
            Carousel.ItemsSourceProperty.AddOwner<CarouselBanner>();

        
/ </summary>
        public static readonly StyledProperty<IDataTemplate?> ItemTemplateProperty =
            Carousel.ItemTemplateProperty.AddOwner<CarouselBanner>();

        
/ Defines the <see cref="GroupView"/> property.
        
/ </summary>
        
/ </summary>
        public IEnumerable? ItemsSource
        {
            get => GetValue(ItemsSourceProperty);
            set => SetValue(ItemsSourceProperty, value);
        }

        
/ </summary>
        public IDataTemplate? ItemTemplate
        {
            get => GetValue(ItemTemplateProperty);
            set => SetValue(ItemTemplateProperty, value);
        }

        
/ </summary>
        public bool AutoScroll
        {
            get => GetValue(AutoScrollProperty);
            set => SetValue(AutoScrollProperty, value);
        }

        
/ </summary>
        public int AutoScrollInterval
        {
            get => GetValue(AutoScrollIntervalProperty);
            set => SetValue(AutoScrollIntervalProperty, value);
        }

        
/ </summary>
        
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\UI\Views\Controls\Widgets\CarouselItems.cs
/ Defines the <see cref="AutoScroll"/> property.
    
/ </summary>
    public static readonly StyledProperty<bool> AutoScrollProperty =
        AvaloniaProperty.Register<CarouselItems, bool>(nameof(AutoScroll), true);

    
/ Defines the <see cref="AutoScrollInterval"/> property.
    
/ </summary>
    public static readonly StyledProperty<int> AutoScrollIntervalProperty =
        AvaloniaProperty.Register<CarouselItems, int>(nameof(AutoScrollInterval), 6000);

    
/ Defines the <see cref="ItemsPerPage"/> property.
    
/ </summary>
    public static readonly StyledProperty<int> ItemsPerPageProperty =
        AvaloniaProperty.Register<CarouselItems, int>(nameof(ItemsPerPage), 4);

    
/ </summary>
    public bool AutoScroll
    {
        get => GetValue(AutoScrollProperty);
        set => SetValue(AutoScrollProperty, value);
    }

    
/ </summary>
    public int AutoScrollInterval
    {
        get => GetValue(AutoScrollIntervalProperty);
        set => SetValue(AutoScrollIntervalProperty, value);
    }

    
/ </summary>
    public int ItemsPerPage
    {
        get => GetValue(ItemsPerPageProperty);
        set => SetValue(ItemsPerPageProperty, value);
    }

    Carousel? _carouselControl;
    Button? _leftButton;
    Button? _rightButton;
    ItemsControl? _swiper;
    Timer? _timer;

    public ICommand? CarouselBannerIndexCommand { get; }

    public CarouselItems()
    {
        CarouselBannerIndexCommand = ReactiveCommand.Create<int>(CarouselBannerIndex);
    }

    protected override void OnApplyTemplate(TemplateAppliedEventArgs e)
    {
        base.OnApplyTemplate(e);

        _carouselControl = e.NameScope.Find<Carousel>("CarouselControl");
        _leftButton = e.NameScope.Find<Button>("Left");
        _rightButton = e.NameScope.Find<Button>("Right");
        _swiper = e.NameScope.Find<Avalonia.Controls.ItemsControl>("Swiper");

        if (_leftButton != null)
        {
            _leftButton.Command = ReactiveCommand.Create(SwiperPrevious);
        }
        if (_rightButton != null)
        {
            _rightButton.Command = ReactiveCommand.Create(SwiperNext);
        }

        if (_carouselControl != null)
        {
            _carouselControl.GetObservable(Carousel.ItemCountProperty)
               .Subscribe(_ => SwipersLoad());

            _carouselControl.GetObservable(Carousel.SelectedIndexProperty)
              .Subscribe(_ => SwipersLoad());

            RefreshItemsSource();
        }
    }

    protected override void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change)
    {
        base.OnPropertyChanged(change);

        if (change.Property == ItemCountProperty)
        {
            RefreshItemsSource();
        }
        else if (change.Property == ItemsPerPageProperty)
        {
            RefreshItemsSource();
        }
        else if (change.Property == AutoScrollProperty)
        {
            var x = change.GetNewValue<bool>();
            if (x && _timer == null)
            {
                _timer = new Timer(_ =>
                {
                    if (!this.IsPointerOver)
                    {
                        Dispatcher.UIThread.Post(SwiperNext, DispatcherPriority.Background);
                    }
                }, nameof(AutoScroll), AutoScrollInterval, AutoScrollInterval);
            }
            else
            {
                if (_timer != null)
                {
                    _timer.Dispose();
                    _timer = null;
                }
            }
        }
    }

    protected override void OnPointerEntered(PointerEventArgs e)
    {
        base.OnPointerEntered(e);

        if (_swiper == null || _leftButton == null || _rightButton == null)
            return;

        _leftButton.IsVisible = _rightButton.IsVisible = _swiper.IsVisible;
    }

    protected override void OnPointerExited(PointerEventArgs e)
    {
        base.OnPointerExited(e);

        if (_swiper == null || _leftButton == null || _rightButton == null)
            return;

        _leftButton.IsVisible = _rightButton.IsVisible = false;
    }

    void RefreshItemsSource()
    {
        if (_carouselControl != null)
        {
            var items = ItemsSource?.Batch(ItemsPerPage);
            _carouselControl.ItemsSource = items;
        }
    }

    void CarouselBannerIndex(int index)
    {
        if (_carouselControl != null)
            _carouselControl.SelectedIndex = index;
    }

    void SwipersLoad()
    {
        if (_carouselControl == null || _swiper == null || _leftButton == null || _rightButton == null)
            return;

        if (_carouselControl.ItemCount <= 0)
        {
            _swiper.ItemsSource = null;
            return;
        }
        if (_carouselControl.ItemCount == 1)
        {
            _swiper.IsVisible = false;
            return;
        }
        else
        {
            _swiper.IsVisible = true;
            var arr = new Dictionary<int, string>();
            for (var i = 0; i < _carouselControl.ItemCount; i++)
            {
                arr.Add(i, "#ADADAD");
            }
            var index = _carouselControl.SelectedIndex < 0 ? 0 : _carouselControl.SelectedIndex;
            arr[index] = "#FFFFFF";

            _swiper.ItemsSource = arr;
        }
    }

    
/ </summary>
    public void SwiperNext()
    {
        if (_carouselControl == null || _carouselControl.ItemCount < 1)
            return;

        if (_carouselControl.SelectedIndex < _carouselControl.ItemCount - 1)
        {
            _carouselControl.Next();
        }
        else
        {
            _carouselControl.SelectedIndex = 0;
        }
    }

    
/ </summary>
    public void SwiperPrevious()
    {
        if (_carouselControl == null || _carouselControl.ItemCount < 1)
            return;

        if (_carouselControl.SelectedIndex > 0)
        {
            _carouselControl.Previous();
        }
        else
        {
            _carouselControl.SelectedIndex = _carouselControl.ItemCount - 1;
        }
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\UI\Views\Controls\Widgets\FixedWrapPanel.cs
/ </summary>
public class FixedWrapPanel : Panel, INavigableContainer
{
    
/ Defines the <see cref="ItemsPerLine"/> property.
    
/ </summary>
    public static readonly StyledProperty<int> ItemsPerLineProperty =
        AvaloniaProperty.Register<FixedWrapPanel, int>(nameof(ItemsPerLine), 3);

    
/ Defines the <see cref="Spacing"/> property.
    
/ </summary>
    public static readonly StyledProperty<double> SpacingProperty =
    AvaloniaProperty.Register<FixedWrapPanel, double>(nameof(Spacing), 0);

    static FixedWrapPanel()
    {
        AffectsMeasure<FixedWrapPanel>(ItemsPerLineProperty);
    }

    
/ </summary>
    public int ItemsPerLine
    {
        get => GetValue(ItemsPerLineProperty);
        set => SetValue(ItemsPerLineProperty, value);
    }

    
/ </summary>
    public double Spacing
    {
        get => GetValue(SpacingProperty);
        set => SetValue(SpacingProperty, value);
    }

    
/ <inheritdoc/>
    IInputElement INavigableContainer.GetControl(NavigationDirection direction, IInputElement? from, bool wrap)
    {
        int index = from is Control control ? Children.IndexOf(control) : -1;
        switch (direction)
        {
            case NavigationDirection.First:
                index = 0;
                break;
            case NavigationDirection.Last:
                index = Children.Count - 1;
                break;
            case NavigationDirection.Next:
                ++index;
                break;
            case NavigationDirection.Previous:
                --index;
                break;
            case NavigationDirection.Left:
                index -= 1;
                break;
            case NavigationDirection.Right:
                index += 1;
                break;
            case NavigationDirection.Up:
                index = -1;
                break;
            case NavigationDirection.Down:
                index = -1;
                break;
        }

        if (index >= 0 && index < Children.Count)
        {
            return Children[index];
        }

        return this;
    }

    
/ <inheritdoc/>
    protected override Size MeasureOverride(Size constraint)
    {
        var panelSize = default(MutableSize);
        var lineSize = default(MutableSize);
        int itemsInCurrentLine = 0;
        double itemWidth = (constraint.Width - (Spacing * (ItemsPerLine - 1))) / ItemsPerLine;

        foreach (var child in Children.OfType<Control>())
        {
            child.Measure(new Size(itemWidth, constraint.Height));
            var childSize = child.DesiredSize;

            if (itemsInCurrentLine == ItemsPerLine)
            {
                
/ <inheritdoc/>
    protected override Size ArrangeOverride(Size finalSize)
    {
        var itemWidth = (finalSize.Width - (Spacing * (ItemsPerLine - 1))) / ItemsPerLine;
        var position = default(MutablePoint);
        var lineHeight = 0.0;
        int itemsInCurrentLine = 0;
        try
        {
            foreach (var child in Children.OfType<Control>())
            {
                if (itemsInCurrentLine == ItemsPerLine)
                {
                    
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\UI\Views\Controls\Widgets\Ripple.cs
/ 2, -endY / 2, 0, 0);
    }

    public void RunSecondStep()
    {
        Opacity = 0;
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\UI\Views\Controls\Widgets\RippleEffect.cs
/ Find canvas host
        PART_RippleCanvasRoot = e.NameScope.Find<Canvas>(nameof(PART_RippleCanvasRoot));
    }

    private Ripple CreateRipple(PointerPressedEventArgs e, bool center)
    {
        var w = Bounds.Width;
        var h = Bounds.Height;

        var r = new Ripple(w, h)
        {
            Fill = RippleFill
        };

        if (center) r.Margin = new Thickness(w / 2, h / 2, 0, 0);
        else r.SetupInitialValues(e, this);

        return r;
    }

    #region Styled properties

    public static readonly StyledProperty<IBrush> RippleFillProperty =
        AvaloniaProperty.Register<RippleEffect, IBrush>(nameof(RippleFill), inherits: true);

    public IBrush RippleFill
    {
        get => GetValue(RippleFillProperty);
        set => SetValue(RippleFillProperty, value);
    }

    public static readonly StyledProperty<double> RippleOpacityProperty =
        AvaloniaProperty.Register<RippleEffect, double>(nameof(RippleOpacity), inherits: true);

    public double RippleOpacity
    {
        get => GetValue(RippleOpacityProperty);
        set => SetValue(RippleOpacityProperty, value);
    }

    public static readonly StyledProperty<bool> RaiseRippleCenterProperty =
        AvaloniaProperty.Register<RippleEffect, bool>(nameof(RaiseRippleCenter));

    public bool RaiseRippleCenter
    {
        get => GetValue(RaiseRippleCenterProperty);
        set => SetValue(RaiseRippleCenterProperty, value);
    }

    public static readonly StyledProperty<bool> IsAllowedRaiseRippleProperty =
        AvaloniaProperty.Register<RippleEffect, bool>(nameof(IsAllowedRaiseRipple));

    public bool IsAllowedRaiseRipple
    {
        get => GetValue(IsAllowedRaiseRippleProperty);
        set => SetValue(IsAllowedRaiseRippleProperty, value);
    }

    #endregion Styled properties
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\UI\Views\Controls\Widgets\Snackbar.cs
/ </summary>
    public bool IsClosing
    {
        get { return _isClosing; }
        private set { SetAndRaise(IsClosingProperty, ref _isClosing, value); }
    }

    
/ Defines the <see cref="IsClosing"/> property.
    
/ </summary>
    public static readonly DirectProperty<Snackbar, bool> IsClosingProperty =
        AvaloniaProperty.RegisterDirect<Snackbar, bool>(nameof(IsClosing), o => o.IsClosing);

    public Snackbar() : base()
    {
        Closing += Snackbar_Closing;
        Closed += Snackbar_Closed;
    }

    private void Snackbar_Closed(InfoBar sender, InfoBarClosedEventArgs args)
    {
        IsClosing = false;
    }

    private void Snackbar_Closing(InfoBar sender, InfoBarClosingEventArgs args)
    {
        if (args.Reason == InfoBarCloseReason.CloseButton)
        {
            args.Cancel = true;
            IsClosing = true;
        }
    }

    protected override void OnDetachedFromVisualTree(VisualTreeAttachmentEventArgs e)
    {
        Closing -= Snackbar_Closing;
        Closed -= Snackbar_Closed;
        base.OnDetachedFromVisualTree(e);
    }

    public void Close()
    {
        if (IsClosing)
        {
            return;
        }

        IsClosing = true;
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\UI\Views\Controls\Widgets\Stepper.cs
/ colCount);
        }
        else
        {
            _bar.Height = (colCount - 1) * (Bounds.Height / colCount);
        }
    }

    public static readonly AvaloniaProperty<Dock> DockProperty =
        AvaloniaProperty.Register<Stepper, Dock>(nameof(Dock)
            , Dock.Top);

    public Dock Dock
    {
        get => this.GetValue<Dock>(DockProperty);
        set => SetValue(DockProperty, value);
    }

    public static readonly StyledProperty<bool> IsMouseSelectableProperty =
        AvaloniaProperty.Register<Stepper, bool>(nameof(IsMouseSelectable), false);

    public bool IsMouseSelectable
    {
        get => GetValue(IsMouseSelectableProperty);
        set => SetValue(IsMouseSelectableProperty, value);
    }

    public static readonly DirectProperty<Stepper, ICommand> NextCommandProperty =
        AvaloniaProperty.RegisterDirect<Stepper, ICommand>(nameof(NextCommand),
            o => o.NextCommand);

    public ICommand NextCommand
    {
        get => _nextCommand ??=
            new Command(GoNext, CanGoNext);
    }

    public static readonly DirectProperty<Stepper, ICommand> BackCommandProperty =
        AvaloniaProperty.RegisterDirect<Stepper, ICommand>(nameof(BackCommand),
            o => o.BackCommand);

    public ICommand BackCommand
    {
        get => _backCommand ??=
            new Command(GoBack, CanGoBack);
    }

    bool CanGoBack(object? _)
    {
        if (Items?.Count is int count)
            return count > 0 && (SelectedIndex - 1) >= 0;
        return false;
    }

    void GoBack(object? _)
    {
        SelectedIndex--;
    }

    bool CanGoNext(object? _) => Items?.Count is int count && count > 0 && SelectedIndex + 1 < count;

    void GoNext(object? _)
    {
        SelectedIndex++;
    }

    protected override void OnLoaded(RoutedEventArgs e)
    {
        base.OnLoaded(e);
        UpdateProgressBar();
        if (Items.Count > 0 && SelectedIndex == -1)
        {
            SetCurrentValue(SelectedIndexProperty, 0);
        }
    }

    protected override bool NeedsContainerOverride(object? item, int index, out object? recycleKey)
    {
        return NeedsContainer<StepperItem>(item, out recycleKey);
    }

    protected override Control CreateContainerForItemOverride(object? item, int index, object? recycleKey)
    {
        return new StepperItem();
    }

    protected override void PrepareContainerForItemOverride(Control container, object? item, int index)
    {
        base.PrepareContainerForItemOverride(container, item, index);
    }

    protected override void ContainerForItemPreparedOverride(Control container, object? item, int index)
    {
        base.ContainerForItemPreparedOverride(container, item, index);
        if (container is StepperItem stepperItem)
        {
            stepperItem.Index = index + 1;
        }
    }

    protected override void ContainerIndexChangedOverride(Control container, int oldIndex, int newIndex)
    {
        base.ContainerIndexChangedOverride(container, oldIndex, newIndex);
        if (container is StepperItem item)
        {
            item.Index = newIndex + 1;
        }
    }

    protected override void OnApplyTemplate(TemplateAppliedEventArgs e)
    {
        base.OnApplyTemplate(e);
        _bar = e.NameScope.Find<ProgressBar>("PART_ProgressBar");
    }

    protected override void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change)
    {
        base.OnPropertyChanged(change);
        if (change.Property == SelectedIndexProperty)
        {
            if (change.NewValue is int selectIndex)
            {
                var nItems = Items.Count;
                int stepIndex = 0;
                for (; stepIndex < selectIndex; stepIndex++)
                {
                    if (ContainerFromIndex(stepIndex) is StepperItem item)
                    {
                        item.Status = StepStatus.Complete;
                    }
                }
                if (ContainerFromIndex(stepIndex++) is StepperItem stepItemSelected)
                    stepItemSelected.Status = StepStatus.UnderWay;
                for (; stepIndex < nItems; stepIndex++)
                {
                    if (ContainerFromIndex(stepIndex) is StepperItem item)
                    {
                        item.Status = StepStatus.Waiting;
                    }
                }
                if (_bar is ProgressBar progressBar)
                {
                    var current = progressBar.Value;
                    progressBar.BeginAnimation(ProgressBar.ValueProperty, TimeSpan.FromMilliseconds(200), (double)selectIndex);
                }
            }
            _backCommand?.RaiseCanExecuteChanged();
            _nextCommand?.RaiseCanExecuteChanged();
        }
        else if (change.Property == BoundsProperty)
        {
            UpdateProgressBar();
        }
    }

    internal bool UpdateSelectionFromPointerEvent(Control source, PointerEventArgs e)
    {
        var hotkeys = Application.Current!.PlatformSettings?.HotkeyConfiguration;
        var toggle = hotkeys is not null && e.KeyModifiers.HasFlag(hotkeys.CommandModifiers);

        return UpdateSelectionFromEventSource(
            source,
            true,
            e.KeyModifiers.HasFlag(KeyModifiers.Shift),
            toggle,
            e.GetCurrentPoint(source).Properties.IsRightButtonPressed);
    }

}

public enum StepStatus
{
    Waiting,
    UnderWay,
    Complete,
    Error,
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\UI\Views\Controls\Widgets\StepperItem.cs
/ Defines the <see cref="IsSelected"/> property.
    
/ </summary>
    public static readonly StyledProperty<bool> IsSelectedProperty =
        SelectingItemsControl.IsSelectedProperty.AddOwner<StepperItem>();

    private static readonly Point s_invalidPoint = new Point(double.NaN, double.NaN);
    private Point _pointerDownPoint = s_invalidPoint;

    
/ </summary>
    public bool IsSelected
    {
        get { return GetValue(IsSelectedProperty); }
        set { SetValue(IsSelectedProperty, value); }
    }

    
/ Initializes static members of the <see cref="StepperItem"/> class.
    
/ </summary>
    static StepperItem()
    {
        SelectableMixin.Attach<StepperItem>(IsSelectedProperty);
        PressedMixin.Attach<StepperItem>();
        FocusableProperty.OverrideDefaultValue<StepperItem>(true);
    }

    public static readonly DirectProperty<StepperItem, bool> IsFirstProperty =
        AvaloniaProperty.RegisterDirect<StepperItem, bool>(nameof(IsFirst),
            o => o.IsFirst);

    public static readonly DirectProperty<StepperItem, bool> IsLastProperty =
        AvaloniaProperty.RegisterDirect<StepperItem, bool>(nameof(IsLast),
            o => o.IsLast);

    public bool IsFirst { get; internal set; }

    public bool IsLast { get; internal set; }

    public static readonly DirectProperty<StepperItem, int> IndexProperty =
        AvaloniaProperty.RegisterDirect<StepperItem, int>(nameof(Index)
           , o => o._index);

    int _index = 0;

    public int Index
    {
        get => _index;
        internal set => SetAndRaise(IndexProperty, ref _index, value);
    }

    public static readonly DirectProperty<StepperItem, StepStatus> StatusProperty =
        AvaloniaProperty.RegisterDirect<StepperItem, StepStatus>(nameof(Status)
            , o => o._status);

    private StepStatus _status = StepStatus.Waiting;

    public StepStatus Status
    {
        get => _status;
        internal set => SetAndRaise(StatusProperty, ref _status, value);
    }

    protected override AutomationPeer OnCreateAutomationPeer()
    {
        return base.OnCreateAutomationPeer();
    }

    protected override void OnPointerPressed(PointerPressedEventArgs e)
    {
        base.OnPointerPressed(e);

        _pointerDownPoint = s_invalidPoint;

        if (e.Handled)
            return;

        if (!e.Handled && ItemsControl.ItemsControlFromItemContaner(this) is Stepper owner)
        {
            var p = e.GetCurrentPoint(this);

            if (p.Properties.PointerUpdateKind is PointerUpdateKind.LeftButtonPressed or
                PointerUpdateKind.RightButtonPressed)
            {
                if (p.Pointer.Type == PointerType.Mouse)
                {
                    
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Avalonia\UI\Views\Pages\MainView.axaml.cs
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\UI\Views\Pages\PluginStorePage.axaml.cs
/ Back/Forward navigation and not just explicit page invokes
        
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\UI\Views\Pages\About\AboutPage.axaml.cs
/ </summary>
    const double clickOpenBrowserIntervalSeconds = .75d;
    static readonly Dictionary<string, DateTime> clickOpenBrowserTimeRecord = new();

    static void OpenBrowser(string url)
    {
        try
        {
            var hasKey = clickOpenBrowserTimeRecord.TryGetValue(url, out var dt);
            var now = DateTime.Now;
            if (hasKey && (now - dt).TotalSeconds <= clickOpenBrowserIntervalSeconds)
                return;
            Browser2.Open(url);
            if (!clickOpenBrowserTimeRecord.TryAdd(url, now)) clickOpenBrowserTimeRecord[url] = now;
        }
        catch (Exception ex)
        {
            Toast.LogAndShowT(ex);
        }

    }

    void GPLv3_Tapped(object? sender, TappedEventArgs e)
    {
        OpenBrowser("https:
/www.gnu.org/licenses/gpl-3.0.html");
    }

    void Dotnet_Tapped(object? sender, TappedEventArgs e)
    {
        OpenBrowser("https:
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\UI\Views\Pages\Common\TextInputDialogPage.axaml.cs
/ </summary>
    
/ <param name="e">The event args.</param>
    protected override void OnAttachedToVisualTree(VisualTreeAttachmentEventArgs e)
    {
        base.OnAttachedToVisualTree(e);

        switch (ViewModel?.InputType)
        {
            case TextBoxWindowViewModel.TextBoxInputType.Password:
                PasswordBox.IsVisible = true;
                PasswordBox.PasswordChar = App.Instance.FindResource("PasswordChar") as char? ?? '*';
                PasswordBox.Classes.Set("revealPasswordButton", true);
                PasswordBox.Classes.Set("clearButton", false);
                break;
            case TextBoxWindowViewModel.TextBoxInputType.TextBox:
                PasswordBox.IsVisible = true;
                PasswordBox.PasswordChar = default;
                PasswordBox.Classes.Set("revealPasswordButton", false);
                PasswordBox.Classes.Set("clearButton", true);
                break;
            case TextBoxWindowViewModel.TextBoxInputType.ReadOnlyText:
                PasswordBox.IsVisible = true;
                PasswordBox.PasswordChar = default;
                PasswordBox.Classes.Set("revealPasswordButton", false);
                PasswordBox.AcceptsReturn = true;
                PasswordBox.IsReadOnly = true;
                break;
        }

        PasswordBox.Focus();
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\UI\Views\Pages\User\LoginOrRegisterPage.axaml.cs
/docs.avaloniaui.net/docs/concepts/services/activatable-lifetime#handling-uri-activation
        
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia\UI\Views\Windows\MainWindow.axaml.cs
/BD.WTTS.Client.Avalonia/UI/Assets/Icons/home.ico",
                        },
                    },
                    ImmutableArray.Create<TabItemViewModel>(
#if DEBUG
                    new MenuTabItemViewModel("Debug")
                    {
                        PageType = typeof(DebugPage),
                        IsResourceGet = false,
                        IconKey = "avares:
/BD.WTTS.Client.Avalonia/UI/Assets/Icons/bug.ico",
                    },
#endif
                    new MenuTabItemViewModel("Plugin_Store")
                    {
                        PageType = typeof(PluginStorePage),
                        IsResourceGet = true,
                        IconKey = "avares:
/BD.WTTS.Client.Avalonia/UI/Assets/Icons/store.ico",
                    },
                    new MenuTabItemViewModel("Settings")
                    {
                        PageType = typeof(SettingsPage),
                        IsResourceGet = true,
                        IconKey = "avares:
/BD.WTTS.Client.Avalonia/UI/Assets/Icons/settings.ico",
                    }));
#pragma warning restore SA1114 
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Avalonia\UI\Views\Windows\MainWindow.axaml.cs
DEBUG
DEBUG
STARTUP
STARTUP
STARTUP
STARTUP
DEBUG
STARTUP
STARTUP
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Avalonia.App\Program.cs
/github.com/dotnet/runtime/blob/v7.0.3/docs/design/features/native-hosting.md#loading-and-calling-managed-components</para>
    
/ </summary>
    
/ <param name="args"></param>
    
/ <param name="sizeBytes"></param>
    
/ <returns></returns>
#pragma warning disable IDE0079 
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Avalonia.App\Program.cs
DESIGNER
DESIGNER
DEBUG
WINDOWS
WINDOWS
WINDOWS
MACOS
DEBUG
DESIGNER
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Avalonia.App\Startup.cs
DEBUG
WINDOWS
WINDOWS
ANDROID
MAUI
LINUX
WINDOWS
AVALONIA
STARTUP
MAUI
LINUX
STARTUP
STARTUP
ANDROID
STARTUP
STARTUP
STARTUP
STARTUP
STARTUP
STARTUP
STARTUP
LINUX
AVALONIA
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.IPC\Enums\ToastLength.cs
/www.cnblogs.com/kborid/p/14078744.html

public enum ToastLength
{
    
/ </summary>
    Short = 2000,

    
/ </summary>
    Long = 3500,
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.IPC\Services\IPCSubProcessService.cs
/ </summary>
public interface IPCSubProcessService : IDisposable
{
    
/ </summary>
    
/ <param name="moduleName"></param>
    
/ <param name="tcs"></param>
    
/ <param name="pipeName"></param>
    
/ <param name="configureIpcProvider"></param>
    
/ <returns></returns>
    Task RunAsync(string moduleName, TaskCompletionSource tcs, string pipeName, Action<IpcProvider>? configureIpcProvider = null);

    
/ </summary>
    
/ <typeparam name="T"></typeparam>
    
/ <returns></returns>
    T? GetService<T>() where T : class;

    private static IPCSubProcessServiceImpl? iPCSubProcessServiceImpl;

    static IPCSubProcessService Instance => iPCSubProcessServiceImpl.ThrowIsNull();

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static SubProcessArgumentIndex2Model? GetSubProcessArgumentIndex2Model(string s)
    {
        try
        {
            var b = s.Base64UrlDecodeToByteArray();
            var m = Serializable.DMP2<SubProcessArgumentIndex2Model>(b);
            return m;
        }
        catch
        {
            return null;
        }
    }

    static string LogDirPath { get; private set; } = null!;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static bool TryGetProcessById(int pid, [NotNullWhen(true)] out Process? process)
    {
        try
        {
            process = Process.GetProcessById(pid);
            return true;
        }
        catch
        {
            
/ </summary>
    
/ <param name="moduleName"></param>
    
/ <param name="pluginName"></param>
    
/ <param name="configureServices">配置子进程的依赖注入服务</param>
    
/ <param name="configureIpcProvider">配置 IPC 服务</param>
    
/ <param name="args"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static async Task<int> MainAsync(
        string moduleName,
        string? pluginName,
        Action<IServiceCollection>? configureServices,
        Action<IpcProvider>? configureIpcProvider,
        params string[] args)
    {
        if (args.Length < 2)
            return (int)CommandExitCode.EmptyArrayArgs;
        var pipeName = args[0];
        if (string.IsNullOrWhiteSpace(pipeName))
            return (int)CommandExitCode.EmptyPipeName;
        if (!int.TryParse(args[1], out var pid))
            return (int)CommandExitCode.EmptyMainProcessId;
        if (!TryGetProcessById(pid, out var mainProcess))
            return (int)CommandExitCode.NotFoundMainProcessId;

#if LIB_CLIENT_IPC
        var nativeLibraryPath = Environment.GetEnvironmentVariable(EnvKey_NativeLibraryPath);
        if (!string.IsNullOrWhiteSpace(nativeLibraryPath))
        {
            var nativeLibraryPaths = nativeLibraryPath.Split(';',
                StringSplitOptions.RemoveEmptyEntries);

            
/learn.microsoft.com/zh-cn/dotnet/api/system.runtime.interopservices.nativelibrary.setdllimportresolver
                }
            }
            var assemblies = AppDomain.CurrentDomain.GetAssemblies();
            foreach (var assembly in assemblies)
                CurrentDomain_AssemblyLoad(assembly);
        }
#endif

        SubProcessArgumentIndex2Model? m = default;
        if (pluginName != null)
        {
            if (args.Length < 3)
                return (int)CommandExitCode.EmptyArrayArgs;
            m = GetSubProcessArgumentIndex2Model(args[2]);
            if (m == null)
                return (int)CommandExitCode.SubProcessArgumentIndex2ModelIsNull;

            IPCSubProcessFileSystem.InitFileSystem(m, pluginName);
        }

        string? logDirPath = null;
        IPCSubProcessFileSystem.InitLog(ref logDirPath, moduleName, cacheDirectory: m?.CacheDirectory);
        LogDirPath = logDirPath!;

        TaskCompletionSource tcs = new();
        mainProcess.EnableRaisingEvents = true;
        mainProcess.Exited += (_, _) =>
        {
            tcs.TrySetResult(); 
/ </summary>
    
/ <param name="logLevel">level to be converted.</param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static NLogLevel ConvertLogLevel(LogLevel logLevel) => logLevel switch
    {
        
/github.com/NLog/NLog.Extensions.Logging/blob/v1.7.0/src/NLog.Extensions.Logging/Logging/NLogLogger.cs#L416
        LogLevel.Trace => NLogLevel.Trace,
        LogLevel.Debug => NLogLevel.Debug,
        LogLevel.Information => NLogLevel.Info,
        LogLevel.Warning => NLogLevel.Warn,
        LogLevel.Error => NLogLevel.Error,
        LogLevel.Critical => NLogLevel.Fatal,
        LogLevel.None => NLogLevel.Off,
        _ => NLogLevel.Debug,
    };

    public const string LogDirName = "Logs";

    static void InitializeTarget(LoggingConfiguration config, Target target, NLogLevel minLevel)
    {
        config.AddTarget(target);
        if (minLevel < NLogLevel.Warn)
        {
            config.LoggingRules.Add(new LoggingRule("Microsoft*", target) { FinalMinLevel = NLogLevel.Warn });
            config.LoggingRules.Add(new LoggingRule("Microsoft.Hosting.Lifetime*", target) { FinalMinLevel = NLogLevel.Info });
            config.LoggingRules.Add(new LoggingRule("System*", target) { FinalMinLevel = NLogLevel.Warn });
        }
        config.LoggingRules.Add(new LoggingRule("*", minLevel, target));
    }

    public static string GetLogDirPath(string? moduleName = null, string? cacheDirectory = null)
    {
        cacheDirectory ??= IOPath.CacheDirectory;

        string logDirPath;
        if (moduleName == null)
        {
            logDirPath = Path.Combine(cacheDirectory, LogDirName);
        }
        else
        {
            var dirName = GetDirectoryName(moduleName);
            logDirPath = Path.Combine(cacheDirectory, LogDirName, dirName);
        }

        IOPath.DirCreateByNotExists(logDirPath);
        return logDirPath;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void InitLog(
        ref string? logDirPath,
        string? moduleName = null,
        string? alias = null,
        string? cacheDirectory = null
#if STARTUP_WATCH_TRACE || DEBUG
#pragma warning disable IDE0079 
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.IPC\Services\IPCSubProcessService.cs
LIB
DEBUG
LIB
DEBUG
DEBUG
DEBUG
DEBUG
DEBUG
STARTUP
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\Entities\Script.cs
/ </summary>
[SQLiteTable(TableName)]
[DebuggerDisplay("{DebuggerDisplay(),nq}")]
public sealed class Script : IEntity<int>
{
    
/ </summary>
    [Column("7C85E5C4")]
    [SQLiteNotNull]
    public string Name { get; set; } = string.Empty;

    
/ </summary>
    [Column("23BE056E")]
    public string Author { get; set; } = string.Empty;

    
/ </summary>
    [Column("8037C4C3")]
    [SQLiteNotNull]
    public string Version { get; set; } = string.Empty;

    
/ </summary>
    [Column("F1DDBF5B")]
    public Guid? Pid { get; set; }

    
/ </summary>
    [Column("C9719845")]
    [SQLiteNotNull]
    public string FilePath { get; set; } = string.Empty;

    
/ </summary>
    [Column(ColumnName_CachePath)]
    [SQLiteNotNull]
    public string CachePath { get; set; } = string.Empty;

    
/ </summary>
    [Column("233E579D")]
    public string SourceLink { get; set; } = string.Empty;

    
/ </summary>
    [Column("50EBB673")]
    public string DownloadLink { get; set; } = string.Empty;

    
/ </summary>
    [Column("A5AD2FBF")]
    public string UpdateLink { get; set; } = string.Empty;

    
/ </summary>
    [Column("B49B2587")]
    public string Description { get; set; } = string.Empty;

    
/ </summary>
    [Column("29296F97")]
    public string MatchDomainNames { get; set; } = string.Empty;

    
/ </summary>
    [Column(ColumnName_Enable)]
    public bool Enable { get; set; } = false;

    
/ </summary>
    [Column("4732B219")]
    public string? Icon { get; set; }

    
/ </summary>
    
/ </summary>
    [Column("569086A0")]
    public string? ExcludeDomainNames { get; set; }

    
/ </summary>
    [Column("5C02E4AA")]
    public string? RequiredJs { get; set; }

    
/ </summary> 
    [Column("D965B4F5")]
    public string MD5 { get; set; } = "";

    
/ </summary> 
    [Column("C5645EF3")]
    public string SHA512 { get; set; } = "";

    [Column("58FF2FF5")]
    public DateTime CreationTime { get; set; } = DateTime.Now;

    [Column("8B9C94E5")]
    public bool IsBuild { get; set; } = true;
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\Enums\NetworkEnvCheckStep.cs
/ </summary>
public enum NetworkEnvCheckStep
{
    
/ </summary>
    HostsFileCheck = 1,

    
/ </summary>
    NetworkInterfaceCheck = 2,

    
/ </summary>
    LSPCheck = 3
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\Enums\ProxyMode.cs
/ </summary>
public enum ProxyMode : byte
{
    
/ </summary>
    DNSIntercept,

    
/ </summary>
    Hosts,

    
/ </summary>
    System,

    
/ </summary>
    VPN,

    
/ </summary>
    ProxyOnly,

    
/ </summary>
    PAC,
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\Extensions\ServiceCollection\ServiceCollectionExtensions.TryAddScriptManager.cs
/ </summary>
    
/ <param name="services"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IServiceCollection TryAddScriptManager(this IServiceCollection services)
    {
        services.TryAddSingleton<IScriptManager, ScriptManager>();
        return services;
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\Helpers\WinDivertInitHelper.cs
/ </summary>
static class WinDivertInitHelper
{
    const string libraryName = "WinDivert.dll";

    static readonly string? libraryPath;
    static readonly string? libraryDirPath;
    
/ </summary>
    
/ <param name="libraryName"></param>
    
/ <param name="assembly"></param>
    
/ <param name="searchPath"></param>
    
/ <returns></returns>
    
/ </summary>
    public static async Task InitializeAsync()
    {
        (byte[] WinDivert_dll, byte[] WinDivert64_sys) data = default;

        void GetData()
        {
            if (data == default)
            {
                data = GetWinDivertBinRes();
            }
        }

        if (libraryPath != null && libraryDirPath != null)
        {
            bool isWrite;
            var libraryFileInfo = new FileInfo(libraryPath);
            if (libraryFileInfo.Exists)
            {
                if (libraryFileInfo.Length > 20000000L) 
/ </summary>
    public static bool IsSupported { get; private set; }

    static WinDivertInitHelper()
    {
        switch (RuntimeInformation.OSArchitecture)
        {
            
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\Helpers\WinDivertInitHelper.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\Models\XunYouAccelStateModel.cs
/ </summary>
[MP2Obj(MP2SerializeLayout.Explicit)]
public partial class XunYouAccelStateModel
{
    
/ <inheritdoc cref="XunYouState"/>
    [MP2Key(0)]
    public XunYouState State { get; set; }

    
/ </summary>
    [MP2Key(1)]
    public int GameId { get; set; }

    
/ </summary>
    [MP2Key(2)]
    public int AreaId { get; set; }

    
/ </summary>
    [MP2Key(3)]
    public int ServerId { get; set; }

    
/ <inheritdoc cref="XunYouAccelStateEx"/>
    [MP2Key(4)]
    public XunYouAccelStateEx? AccelState { get; set; }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\Models\XunYouGameViewModel.cs
/ <inheritdoc cref="XunYouGame"/>
    [MP2Key(0), JsonPropertyOrder(0)]
    public XunYouGame Model { get; set; } = model;

    
/ </summary>
    [Reactive]
    [XmlIgnore, IgnoreDataMember, SystemTextJsonIgnore, NewtonsoftJsonIgnore, MPIgnore, MP2Ignore]
    public XunYouPicInfo? PicInfo { get; set; }

    
/ </summary>
    [Reactive]
    [XmlIgnore, IgnoreDataMember, SystemTextJsonIgnore, NewtonsoftJsonIgnore, MPIgnore, MP2Ignore]
    public uint PingValue { get; set; }

    
/ </summary>
    [Reactive]
    [XmlIgnore, IgnoreDataMember, SystemTextJsonIgnore, NewtonsoftJsonIgnore, MPIgnore, MP2Ignore]
    public bool PingValueIsInvalid { get; set; }

    
/ </summary>
    
/ <param name="value"></param>
    public void SetPingValue(uint value)
    {
        PingValueIsInvalid = value >= 1000;
        if (PingValueIsInvalid) 
/ </summary>
    [Reactive]
    [XmlIgnore, IgnoreDataMember, SystemTextJsonIgnore, NewtonsoftJsonIgnore, MPIgnore, MP2Ignore]
    public float PingSpeedLoss { get; set; }

    XunYouGameInfo? _GameInfo;

    
/ </summary>
    [XmlIgnore, IgnoreDataMember, SystemTextJsonIgnore, NewtonsoftJsonIgnore, MPIgnore, MP2Ignore]
    public XunYouGameInfo? GameInfo
    {
        get => _GameInfo;
        set
        {
            _GameInfo = value;
            this.RaisePropertyChanged();
            this.RaisePropertyChanged(nameof(ShowStart));
        }
    }

    
/ <inheritdoc cref="XunYouGameInfo.ShowStart"/>
    [XmlIgnore, IgnoreDataMember, SystemTextJsonIgnore, NewtonsoftJsonIgnore, MPIgnore, MP2Ignore]
    public bool ShowStart => IsAccelerated && (GameInfo != null && GameInfo.ShowStart);

    
/ </summary>
    [Reactive]
    [MP2Ignore, SystemTextJsonIgnore]
    public bool IsAccelerating { get; set; }

    
/ </summary>
    [Reactive]
    [MP2Ignore, SystemTextJsonIgnore]
    public int AcceleratingProgress { get; set; }

    bool _IsAccelerated;

    
/ </summary>
    [MP2Ignore, SystemTextJsonIgnore]
    public bool IsAccelerated
    {
        get => _IsAccelerated;
        set
        {
            if (_IsAccelerated != value)
            {
                _IsAccelerated = value;
                this.RaisePropertyChanged();
                this.RaisePropertyChanged(nameof(ShowStart));
            }
        }
    }

    
/ </summary>
    [Reactive]
    [MP2Ignore, SystemTextJsonIgnore]
    public bool IsStopAccelerating { get; set; }

    
/ </summary>
    [Reactive]
    [MP2Key(1), JsonPropertyOrder(1)]

    public DateTimeOffset? LastAccelerateTime { get; set; }

    
/ </summary>
    [Reactive]
    [MP2Key(2), JsonPropertyOrder(2)]
    public XunYouGameArea? SelectedArea { get; set; }

    
/ </summary>
    [Reactive]
    [MP2Key(3), JsonPropertyOrder(3)]
    public XunYouGameServer? SelectedServer { get; set; }
}


/ <see cref="XunYouGame"/> 的视图模型

/ </summary>
sealed partial class XunYouGameViewModel(XunYouGame model) : ReactiveSerializationObject
{
    
/ Initializes a new instance of the <see cref="XunYouGameViewModel"/> class.
    
/ </summary>
    [MP2Constructor, SystemTextJsonConstructor]
    public XunYouGameViewModel() : this(new())
    {
    }

    
/ </summary>
    
/ <param name="vm"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator XunYouGame(XunYouGameViewModel vm) => vm.Model;

    
/ </summary>
    
/ <param name="model"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator XunYouGameViewModel(XunYouGame model) => new(model);

    
/ <inheritdoc cref="XunYouGame.Id"/>
    [XmlIgnore, IgnoreDataMember, SystemTextJsonIgnore, NewtonsoftJsonIgnore, MPIgnore, MP2Ignore]
    public int Id { get => Model.Id; set => Model.Id = value; }

    
/ <inheritdoc cref="XunYouGame.Name"/>
    [XmlIgnore, IgnoreDataMember, SystemTextJsonIgnore, NewtonsoftJsonIgnore, MPIgnore, MP2Ignore]
    public string? Name { get => Model.Name; set => Model.Name = value; }

    
/ <inheritdoc cref="XunYouGame.IconUrl"/>
    [XmlIgnore, IgnoreDataMember, SystemTextJsonIgnore, NewtonsoftJsonIgnore, MPIgnore, MP2Ignore]
    public string? IconUrl { get => Model.IconUrl; set => Model.IconUrl = value; }

    
/ <inheritdoc cref="XunYouGame.PicUrl"/>
    [XmlIgnore, IgnoreDataMember, SystemTextJsonIgnore, NewtonsoftJsonIgnore, MPIgnore, MP2Ignore]
    public string? PicUrl { get => Model.PicUrl; set => Model.PicUrl = value; }

    
/ <inheritdoc cref="XunYouGame.PicMD5"/>
    [XmlIgnore, IgnoreDataMember, SystemTextJsonIgnore, NewtonsoftJsonIgnore, MPIgnore, MP2Ignore]
    public string? PicMD5 { get => Model.PicMD5; set => Model.PicMD5 = value; }

    
/ <inheritdoc cref="XunYouGame.LogoUrl"/>
    [XmlIgnore, IgnoreDataMember, SystemTextJsonIgnore, NewtonsoftJsonIgnore, MPIgnore, MP2Ignore]
    public string? LogoUrl { get => Model.LogoUrl; set => Model.LogoUrl = value; }

    
/ <inheritdoc cref="XunYouGame.LogoMD5"/>
    [XmlIgnore, IgnoreDataMember, SystemTextJsonIgnore, NewtonsoftJsonIgnore, MPIgnore, MP2Ignore]
    public string? LogoMD5 { get => Model.LogoMD5; set => Model.LogoMD5 = value; }

    
/ <inheritdoc />
    public override string ToString() => Model.ToString()!;
}

sealed class LastAccelerateTimeComparer : IComparer<XunYouGameViewModel>
{
    
/ <inheritdoc/>
    public int Compare(XunYouGameViewModel? x, XunYouGameViewModel? y)
    {
        if (x == null || y == null)
            return 0;
        if (x.IsAccelerating)
        {
            return -1;
        }
        else if (y.IsAccelerating)
        {
            return 1;
        }
        if (x.IsAccelerated)
        {
            return -1;
        }
        else if (y.IsAccelerated)
        {
            return 1;
        }
        else if (x.LastAccelerateTime.HasValue && y.LastAccelerateTime.HasValue)
        {
            return y.LastAccelerateTime.Value.CompareTo(x.LastAccelerateTime.Value);
        }
        else if (x.LastAccelerateTime.HasValue)
        {
            return -1;
        }
        else if (y.LastAccelerateTime.HasValue)
        {
            return 1;
        }
        else
        {
            var mygamekeys = GameAcceleratorSettings.MyGames.Value?.Keys;
            if (mygamekeys != null)
            {
                var x2 = mygamekeys.IndexOf(x.Id);
                var y2 = mygamekeys.IndexOf(y.Id);
                if (x2 < y2)
                {
                    return -1;
                }
                else if (x2 > y2)
                {
                    return 1;
                }
            }

            return 0;
        }
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\Plugins\Plugin.cs
/BD.WTTS.Client.Plugins.Accelerator/UI/Assets/accelerator.ico";

    public override IEnumerable<MenuTabItemViewModel>? GetMenuTabItems()
    {
        yield return new MenuTabItemViewModel(this, nameof(Strings.CommunityFix))
        {
            PageType = typeof(MainFramePage),
            IsResourceGet = true,
            
/    Console.WriteLine($"DebugString/IReverseProxyService: {debugStringIPC}");
            
/    Console.WriteLine($"DebugString/IReverseProxyService: {debugStringIPC2}");
            
/ </summary>
    internal string? SubProcessPath
    {
        get
        {
            if (subProcessPath == null)
            {
                try
                {
                    subProcessPath = Assembly.GetExecutingAssembly().Location;
                    subProcessPath = Path.GetDirectoryName(subProcessPath);
                    subProcessPath.ThrowIsNull();

                    const string fileName = $"Steam++.{moduleName}";
                    var subProcessFileName = OperatingSystem.IsWindows() ? $"{fileName}{FileEx.EXE}" : fileName;
                    subProcessPath = Path.Combine(subProcessPath, subProcessFileName);

#if DEBUG 
/ </summary>
    
/ <returns></returns>
    bool SubProcessExists()
    {
        var subProcessPath = SubProcessPath;
        return !string.IsNullOrWhiteSpace(subProcessPath) && File.Exists(subProcessPath);
    }

    public override bool HasValue([NotNullWhen(false)] out string? error)
    {
        if (!SubProcessExists())
        {
            error = Strings.CommunityFix_SubProcessFileNotExist;
            return false;
        }

        error = default;
        return true;
    }

    public override IEnumerable<(Action<IServiceCollection>? @delegate, bool isInvalid, string name)>? GetConfiguration(bool directoryExists)
    {
        yield return GetConfiguration<ProxySettings_>(directoryExists);
        yield return GetConfiguration<GameAcceleratorSettings_>(directoryExists);
    }
}

发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\Plugins\Plugin.cs
WINDOWS
DEBUG
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\Properties\Resources.Designer.cs
/ </auto-generated>

/ </summary>
    
/ (以 /str 作为命令选项)，或重新生成 VS 项目。
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        
/ </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("BD.WTTS.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        
/ </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        
/ </summary>
        internal static byte[] accelerator {
            get {
                object obj = ResourceManager.GetObject("accelerator", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        
/ </summary>
        internal static byte[] script {
            get {
                object obj = ResourceManager.GetObject("script", resourceCulture);
                return ((byte[])(obj));
            }
        }
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\Properties\WinDivertResource.Designer.cs
/ </auto-generated>

/ </summary>
    
/ (以 /str 作为命令选项)，或重新生成 VS 项目。
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class WinDivertResource {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal WinDivertResource() {
        }
        
        
/ </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("BD.WTTS.Properties.WinDivertResource", typeof(WinDivertResource).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        
/ </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        
/ </summary>
        internal static byte[] WinDivert_mpo {
            get {
                object obj = ResourceManager.GetObject("WinDivert_mpo", resourceCulture);
                return ((byte[])(obj));
            }
        }
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\Repositories\Abstractions\IScriptRepository.cs
/ </summary>
    const int MaxValue = 100;

    Task<bool> ExistsScriptAsync(string md5, string sha512, CancellationToken cancellationToken = default);

    Task<Script> ExistsScriptNameAsync(string name, CancellationToken cancellationToken = default);

    Task<IList<Script>> GetAllAsync(CancellationToken cancellationToken = default);

    Task SaveScriptEnableAsync(ScriptDTO item, CancellationToken cancellationToken = default);

    Task SaveScriptCachePathAsync(ScriptDTO item, CancellationToken cancellationToken);
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\Services\IAcceleratorService.cs
/ </summary>

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\Services\IAcceleratorService.XunYou.cs
/ </summary>
    
/ <returns></returns>
    Task<ApiRsp<bool>> XY_IsInstall(CancellationToken cancellationToken = default);

    
/ </summary>
    
/ <returns></returns>
    Task<ApiRsp<XunYouUninstallCode>> XY_Uninstall(CancellationToken cancellationToken = default);

    
/ </summary>
    
/ <param name="openid">OpenId</param>
    
/ <param name="nickname">用户昵称</param>
    
/ <param name="gameid">游戏ID</param>
    
/ <param name="area">区服Id</param>
    
/ <param name="server">游戏服Id</param>
    
/ <param name="areaPath">区服名称</param>
    
/ <param name="svrPath">游戏服名</param>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    Task<ApiRsp<int>> XY_StartEx2(
        string openid,
        string nickname,
        int gameid,
        int area,
        int server,
        string? areaPath = default,
        string? svrPath = default,
        CancellationToken cancellationToken = default);

    
/ </summary>
    
/ <param name="gameid">游戏Id</param>
    
/ <param name="area">区服Id</param>
    
/ <param name="serverid"></param>
    
/ <param name="areaName">区服名称</param>
    
/ <param name="svrName">游戏服名</param>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    Task<ApiRsp<int>> XY_StartAccel(
      int gameid,
      int area,
      int serverid = default,
      string? areaName = default,
      string? svrName = default,
      CancellationToken cancellationToken = default);

    
/ </summary>
    
/ <param name="installPath">安装路径</param>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    IAsyncEnumerable<ApiRsp<int>> XY_Install(string installPath, CancellationToken cancellationToken = default);

    
/ </summary>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    Task<ApiRsp<XunYouAccelStateModel?>> XY_GetAccelStateEx(CancellationToken cancellationToken = default);

    
/ </summary>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    Task<ApiRsp<XunYouSendResultCode>> XY_StopAccel(CancellationToken cancellationToken = default);

    
/ </summary>
    
/ <returns></returns>
    Task<ApiRsp<XunYouIsRunningCode>> XY_IsRunning(CancellationToken cancellationToken = default);

    
/ </summary>
    
/ <returns></returns>
    Task<ApiRsp<XunYouStartGameCode>> XY_StartGame(CancellationToken cancellationToken = default);

    
/ </summary>
    
/ <returns></returns>
    Task<ApiRsp<int>> XY_ShowWinodw(bool showHide, CancellationToken cancellationToken = default);
}

partial interface IXunYouAccelStateToFrontendCallback
{
    void XunYouAccelStateToFrontendCallback(XunYouAccelStateModel m);
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\Services\INetworkTestService.cs
/ </summary>
    
/ <param name="testHostNameOrAddress"></param>
    
/ <param name="timeout"></param>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    Task<PingReply> TestPingAsync(string testHostNameOrAddress, TimeSpan timeout, CancellationToken cancellationToken = default);

    
/ </summary>
    
/ <param name="testDomain"></param>
    
/ <param name="dnsServerIp"></param>
    
/ <param name="dnsServerPort"></param>
    
/ <param name="dnsRecordType"></param>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    Task<(long DelayMs, IPAddress[] Address)> TestDNSAsync(
            string testDomain,
            string dnsServerIp,
            int dnsServerPort,
            DnsQueryAnswerRecord.DnsRecordType dnsRecordType = DnsQueryAnswerRecord.DnsRecordType.A,
            CancellationToken cancellationToken = default
        );

    
/ </summary>
    
/ <param name="testDomain"></param>
    
/ <param name="dohServer"></param>
    
/ <param name="dnsRecordType"></param>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    Task<(long DelayMs, IPAddress[] Address)> TestDNSOverHttpsAsync(
            string testDomain,
            string dohServer,
            DnsQueryAnswerRecord.DnsRecordType dnsRecordType = DnsQueryAnswerRecord.DnsRecordType.A,
            CancellationToken cancellationToken = default
        );
}

internal interface IHttpRequestTestService
{
    
/ </summary>
    
/ <param name="url"></param>
    
/ <param name="httpClientFunc"></param>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    Task<(bool Success, long? DelayMs)> TestOpenUrlAsync(string url, Func<HttpClient>? httpClientFunc = null, CancellationToken cancellationToken = default);

    
/ </summary>
    
/ <param name="uploadServerUrl"></param>
    
/ <param name="uploadBytes"></param>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    Task<(bool Success, double? Rate)> TestUploadSpeedAsync(
            string uploadServerUrl,
            byte[] uploadBytes,
            CancellationToken cancellationToken = default
        );

    
/ </summary>
    
/ <param name="downloadUrl"></param>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    Task<(bool Success, double? Rate)> TestDownloadSpeedAsync(string downloadUrl, CancellationToken cancellationToken = default);
}

internal interface IStunTestService
{
    
/ </summary>
    
/ <param name="testServerHostName">STUN 服务地址</param>
    
/ <param name="testServerPort">STUN 服务端口</param>
    
/ <param name="localIPEndPoint">本机IP</param>
    
/ <param name="force">刷新测试 Client</param>
    
/ <remarks></remarks>
    
/ <returns></returns>
    Task<ClassicStunResult?> TestStunClient3489Async(
            string? testServerHostName = default,
            int? testServerPort = default,
            IPEndPoint? localIPEndPoint = default,
            bool force = false,
            CancellationToken cancellationToken = default
        );

    
/ </summary>
    
/ <param name="protocol">使用的传输协议 Tcp,Udp</param>
    
/ <param name="testServerHostName">STUN 服务地址</param>
    
/ <param name="testServerPort">STUN 服务端口</param>
    
/ <param name="localIPEndPoint">本机IP</param>
    
/ <param name="force"></param>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    Task<StunResult5389?> TestStunClient5389Async(
            TransportProtocol protocol,
            string? testServerHostName = default,
            int? testServerPort = default,
            IPEndPoint? localIPEndPoint = null,
            CancellationToken cancellationToken = default
        );
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\Services\IScriptManager.cs
/ </summary>
    
/ <param name="all">加载的列表</param>
    
/ <returns></returns>
    Task<IEnumerable<ScriptDTO>?> LoadingScriptContentAsync(IEnumerable<ScriptDTO>? all);

    
/ </summary>
    
/ <returns></returns>
    Task<bool> BuildScriptAsync(ScriptDTO model, FileInfo fileInfo, bool build = true);

    
/ </summary>
    
/ <param name="path"></param>
    
/ <param name="oldInfo"></param>
    
/ <param name="isCompile"></param>
    
/ <param name="order"></param>
    
/ <param name="deleteFile"></param>
    
/ <param name="pid"></param>
    
/ <param name="ignoreCache"></param>
    
/ <returns></returns>
    Task<IApiRsp<ScriptDTO?>> AddScriptAsync(string path, ScriptDTO? oldInfo = null, bool isCompile = true, long? order = null, bool deleteFile = false, Guid? pid = null, bool ignoreCache = false);

    
/ </summary>
    
/ <param name="path"></param>
    
/ <returns></returns>
    Task<ScriptDTO?> ReadScriptAsync(string path);

    
/ </summary>
    
/ <param name="path"></param>
    
/ <param name="info"></param>
    
/ <param name="oldInfo"></param>
    
/ <param name="isCompile"></param>
    
/ <param name="order"></param>
    
/ <param name="deleteFile"></param>
    
/ <param name="pid"></param>
    
/ <param name="ignoreCache"></param>
    
/ <returns></returns>
    Task<IApiRsp<ScriptDTO?>> SaveScriptAsync(FileInfo path, ScriptDTO? info, ScriptDTO? oldInfo = null, bool isCompile = true, long? order = null, bool deleteFile = false, Guid? pid = null, bool ignoreCache = false);

    
/ </summary>
    
/ <returns></returns>
    Task<IEnumerable<ScriptDTO>> GetAllScriptAsync();

    
/ </summary>
    
/ <param name="item"></param>
    
/ <param name="removeByDataBase"></param>
    
/ <returns></returns>
    Task<IApiRsp> DeleteScriptAsync(ScriptDTO item, bool removeByDataBase = true);

    
/ </summary>
    
/ <param name="url"></param>
    
/ <returns></returns>
    Task<IApiRsp<string?>> DownloadScriptAsync(string url);

    
/ </summary>
    
/ <param name="item"></param>
    
/ <returns></returns>
    Task SaveEnableScriptAsync(ScriptDTO item);

    
/ </summary>
    
/ <param name="list"></param>
    
/ <returns></returns>
    Task<IEnumerable<ScriptDTO>> CheckFiles(IEnumerable<ScriptDTO> list);
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\Services\Mvvm\GameAcceleratorService.cs
/ </summary>
    [Reactive]
    public DateTime? VipEndTime { get; set; }

    const string VipEndTimeStringDef = "新用户免费试用";

    [Reactive]
    public string? VipEndTimeString { get; set; } = VipEndTimeStringDef;

    GameAcceleratorService()
    {
        Ioc.Get<IAcceleratorService>().InitStateSubscribe(); 
/ </summary>
    private static void RestoreGameStatus(XunYouGameViewModel app)
    {
        app.SetPingValue(0);
        app.PingSpeedLoss = 0;
        app.IsAccelerating = false;
        app.IsAccelerated = false;
        app.IsStopAccelerating = false;
    }

    
/ </summary>
    async void SetGameStatus(XunYouGameViewModel game, int areaId = 0, int serverId = 0)
    {
        if (!XunYouSDK.IsSupported)
        {
            return;
        }

        if (CurrentAcceleratorGame != null && CurrentAcceleratorGame.Id == game.Id)
        {
            CurrentAcceleratorGame.IsAccelerating = false;
            CurrentAcceleratorGame.IsAccelerated = true;
            CurrentAcceleratorGame.LastAccelerateTime = DateTimeOffset.Now;

            if (CurrentAcceleratorGame.PicInfo == null)
            {
                CurrentAcceleratorGame.PicInfo = XunYouSDK.GetPicInfo(CurrentAcceleratorGame.Id);
            }
            if (CurrentAcceleratorGame.SelectedArea?.Id != areaId)
            {
                var gameInfo = XunYouSDK.GetGameInfo(game.Id);
                CurrentAcceleratorGame.SelectedArea = gameInfo?.Areas?.FirstOrDefault(s => s.Id == areaId);
            }
            if (CurrentAcceleratorGame.SelectedServer?.Id != serverId)
            {
                CurrentAcceleratorGame.SelectedServer = CurrentAcceleratorGame.SelectedArea?.Servers?.FirstOrDefault(s => s.Id == serverId);
            }
        }
        else
        {
            var cApp = new XunYouGameViewModel(game)
            {
                IsAccelerated = true,
                LastAccelerateTime = DateTimeOffset.Now,
                IsAccelerating = false,
            };

            var gameInfo = XunYouSDK.GetGameInfo(game.Id);
            cApp.SelectedArea = gameInfo?.Areas?.FirstOrDefault(s => s.Id == areaId);
            cApp.SelectedServer = cApp.SelectedArea?.Servers?.FirstOrDefault(s => s.Id == serverId);
            cApp.PicInfo = XunYouSDK.GetPicInfo(game.Id);

            CurrentAcceleratorGame = cApp;
        }

        if (GameAcceleratorSettings.MyGames.ContainsKey(CurrentAcceleratorGame.Id))
        {
            GameAcceleratorSettings.MyGames.Remove(CurrentAcceleratorGame.Id);
        }
        GameAcceleratorSettings.MyGames.TryAdd(CurrentAcceleratorGame.Id, CurrentAcceleratorGame);
        Games.AddOrUpdate(CurrentAcceleratorGame);

        
/加速后
        TracepointHelper.TrackEvent("AcceleratorGameSuccess");
        Toast.Show(ToastIcon.Success, "加速成功");
        if (ProxySettings.AutoShowWattAcceleratorWindow.Value)
        {
            _ = ShowXunYouWindow(true);
        }
        int testSpeedCallback(SpeedCallbackWrapper w)
        {
            if (CurrentAcceleratorGame != null)
            {
                CurrentAcceleratorGame.SetPingValue(w.Struct.PingSpeed);
                CurrentAcceleratorGame.PingSpeedLoss = w.Struct.PingSpeedLoss;
            }
#if DEBUG
            Console.WriteLine($"测速通知状态：{w.State},SpeedCallbackInfo: ErrorDesc/{w.ErrorDesc}, ErrorCode/{w.Struct.ErrorCode}, PingSpeed/{w.Struct.PingSpeed}, PingLocal/{w.Struct.PingLocal}, PingSpeedLoss/{w.Struct.PingSpeedLoss}, PingLocalLoss/{w.Struct.PingLocalLoss}");
#endif
            return 0;
        }
        var speedCode = XunYouSDK.TestSpeed(CurrentAcceleratorGame.Id,
            CurrentAcceleratorGame.SelectedArea?.Id ?? 0,
            CurrentAcceleratorGame.SelectedServer?.Id ?? 0,
            testSpeedCallback);
#if DEBUG
        if (speedCode == XunYouTestSpeedCode.成功)
        {
            Toast.Show(ToastIcon.Info, "发送测速指令");
        }
#endif
    }

    public async Task GameAccelerator(XunYouGameViewModel app)
    {
        if (!XunYouSDK.IsSupported)
        {
            return;
        }

        if (app.IsAccelerating)
            return;

        app.IsAccelerating = true;
        if (!app.IsAccelerated)
        {
            app.LastAccelerateTime = DateTimeOffset.Now;
            CurrentAcceleratorGame = app;
            if (UserService.Current.User?.WattOpenId == null)
            {
                Toast.Show(ToastIcon.Warning, "需要登录账号才能使用游戏加速功能!");
                UserService.Current.ShowWindow();
                app.IsAccelerating = false;
                return;
            }

            TracepointHelper.TrackEvent(nameof(GameAccelerator), new Dictionary<string, string> {
                { "GameId", app.Id.ToString() },
                { "GameName", app.Name ?? string.Empty },
            });

            var xunYouIsInstall = await Ioc.Get<IAcceleratorService>().XY_IsInstall();
            if (xunYouIsInstall.HandleUI(out var isInstall))
            {
                if (!isInstall)
                {
                    
/ </summary>
    public void LoadGames()
    {
        if (!XunYouSDK.IsSupported)
            return;

        Task2.InBackground(() =>
        {
            if (!IsLoadingGames)
            {
                IsLoadingGames = true;
                if (GameAcceleratorSettings.MyGames.Any_Nullable())
                {
                    Games.Clear();
                    var temp = GameAcceleratorSettings.MyGames.Value!.Values.ToArray();
                    foreach (var item in temp)
                    {
                        if (item.PicInfo == null)
                            item.PicInfo = XunYouSDK.GetPicInfo(item.Id);
                    }
                    Games.AddOrUpdate(GameAcceleratorSettings.MyGames.Value!.Values);
                }
                else
                {
                    var games = XunYouSDK.GetHotGames();
                    if (games != null)
                    {
                        Games.Clear();
                        GameAcceleratorSettings.MyGames.AddRange(games.Select(s => new KeyValuePair<int, XunYouGameViewModel>(s.Id, new XunYouGameViewModel(s))));
                        var temp = GameAcceleratorSettings.MyGames.Value!.Values.ToArray();
                        foreach (var item in temp)
                        {
                            if (item.PicInfo == null)
                                item.PicInfo = XunYouSDK.GetPicInfo(item.Id);
                        }
                        Games.AddOrUpdate(GameAcceleratorSettings.MyGames.Value!.Values);
                    }
                }

                IsLoadingGames = false;
            }
        });
    }

    public void RefreshAllGames()
    {
        Task2.InBackground(async () =>
        {
            var games = XunYouSDK.GetAllGames();
            if (games != null)
            {
                AllGames = new ReadOnlyCollection<XunYouGame>(games);
            }

            
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\Services\Mvvm\GameAcceleratorService.cs
DEBUG
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\Services\Mvvm\ProxyService.cs
/ </summary>
    [Reactive]
    public bool ProxyStarting { get; set; }

    [Reactive]
    public bool ProxyStatus { get; set; }

    [Reactive]
    public bool IsAnyProxyScripts { get; set; }

    private bool CheckProxyScriptsEnable()
    {
        if (!ProxyScripts.Items.Any_Nullable())
            return false;
        return ProxyScripts.Items!.Any(w => !w.Disable);
    }

    #endregion 代理状态启动退出

    static bool IsProgramStartupRunProxy()
    {
        var s = Startup.Instance;

        if (s.IsProxyService &&
            (s.ProxyServiceStatus == OnOffToggle.On ||
                s.ProxyServiceStatus == OnOffToggle.Toggle))
            return true;

        return ProxySettings.ProgramStartupRunProxy.Value;
    }

    public async Task InitializeAsync()
    {
        try
        {
            await InitializeAccelerateAsync();
        }
        catch (Exception ex)
        {
            Toast.LogAndShowT(ex, nameof(ProxyService),
                msg: "Accelerate init fail.");
            return; 
/ </summary>
    
/ <returns></returns>
    public async Task InitializeScriptAsync()
    {
        
/ </summary>
    public async Task BasicsInfoAsync()
    {
        var basicsItems = ProxyScripts.Items.Where(x => x.Id == Guid.Parse("00000000-0000-0000-0000-000000000001")).ToArray();
        var count = basicsItems.Length;
        if (count == 1)
            return;
        else if (count > 1)
        {
            foreach (var item in basicsItems)
            {
                await scriptManager.DeleteScriptAsync(item);
                ProxyScripts.Remove(item);
            }
        }
        var basicsInfo = await IMicroServiceClient.Instance.Script.GM(Strings.Script_UpdateError);
        if (basicsInfo.Code == ApiRspCode.OK && basicsInfo.Content != null)
        {
            var jspath = await scriptManager.DownloadScriptAsync(basicsInfo.Content.UpdateLink);
            if (jspath.IsSuccess)
            {
                var build = await scriptManager.AddScriptAsync(jspath.Content!, basicsInfo.Content, isCompile: false, order: 1, deleteFile: true, pid: basicsInfo.Content.Id, ignoreCache: true);
                if (build.IsSuccess)
                {
                    if (build.Content != null)
                    {
                        build.Content.IsBasics = true;
                        ProxyScripts.Insert(0, build.Content);
                    }
                }
                else
                    Toast.Show(ToastIcon.Error, build.Message);
            }
            else
                Toast.Show(ToastIcon.Error, jspath.GetMessageByFormat(Strings.Download_ScriptError_));
        }
    }

    public async Task AddNewScriptAsync(string filePath)
    {
        var fileInfo = new FileInfo(filePath);
        if (fileInfo.Exists)
        {
            var info = await scriptManager.ReadScriptAsync(filePath);
            
/ </summary>
    public async Task RefreshScript()
    {
        var scriptList = await scriptManager.GetAllScriptAsync();
        ProxyScripts.Clear();
        ProxyScripts.AddRange(scriptList);

        CheckScriptUpdate();
    }

    
/ </summary>
    
/ <param name="model"></param>
    public async void DownloadScript(ScriptDTO model)
    {
        model.IsLoading = true;
        var jspath = await scriptManager.DownloadScriptAsync(model.UpdateLink);
        if (jspath.IsSuccess)
        {
            var build = await scriptManager.AddScriptAsync(jspath.Content!, model, isCompile: model.IsCompile, order: model.Order, deleteFile: true, pid: model.Id);
            if (build.IsSuccess)
            {
                if (build.Content != null)
                {
                    model.IsUpdate = false;
                    model.IsExist = true;
                    build.Content.IsUpdate = false;
                    build.Content.IsExist = true;
                    var basicsItem = Current.ProxyScripts.Items.FirstOrDefault(x => x.Id == model.Id);
                    if (basicsItem != null)
                    {
                        ProxyScripts.Replace(basicsItem, build.Content);
                    }
                    else
                    {
                        ProxyScripts.Add(build.Content);
                    }
                    Toast.Show(ToastIcon.Success, Strings.Download_ScriptOk);
                }
            }
            else
            {
                Toast.Show(ToastIcon.Error, build.Message);
            }
        }
        else
        {
            Toast.Show(ToastIcon.Error, jspath.GetMessageByFormat(Strings.Download_ScriptError_));
        }
        model.IsLoading = false;
    }

    
/ </summary>
    public async void CheckScriptUpdate()
    {
        var items = ProxyScripts.Items.Where(x => x.Id.HasValue).Select(x => x.Id!.Value).ToList();
        var client = IMicroServiceClient.Instance.Script;
        var response = await client.GetInfoByIds(Strings.Script_UpdateError, items);
        if (response.Code == ApiRspCode.OK && response.Content != null)
        {
            foreach (var item in ProxyScripts.Items)
            {
                var newItem = response.Content.FirstOrDefault(x => x.Id == item.Id);
                if (newItem != null && item.Version != newItem.Version)
                {
                    item.NewVersion = newItem.Version;
                    item.UpdateLink = newItem.UpdateLink;
                    item.IsUpdate = true;
                    ProxyScripts.Replace(item, item);
                }
            }
        }
    }

    #endregion 脚本相关

    public async void FixNetwork()
    {
        await OnExitRestoreHosts();

#if WINDOWS
        {
            await platformService.SetAsSystemProxyAsync(false);
            await platformService.SetAsSystemPACProxyAsync(false);
            await reverseProxyService.StopProxyAsync();
            try
            {
                Process.Start(new ProcessStartInfo
                {
                    FileName = "cmd.exe",
                    UseShellExecute = false,
                    Arguments = "netsh winsock reset",
                });
            }
            catch
            {
            }
        }
#endif

        Toast.Show(ToastIcon.Success, Strings.FixNetworkComplete);
    }

    public async Task<bool> RefreshIpv6Support()
    {
        var result = await IMicroServiceClient.Instance.Accelerate.GetMyIP(ipV6: true);
        if (!result.IsSuccess) return false;
        IPv6AddresString = result.Content;
        return !string.IsNullOrEmpty(IPv6AddresString);
    }

    public void Dispose()
    {
        Dispose(disposing: true);
        GC.SuppressFinalize(this);
    }

    public async ValueTask DisposeAsync()
    {
        await DisposeAsyncCoreAsync().ConfigureAwait(false);

        Dispose(disposing: false);
        GC.SuppressFinalize(this);
    }

    async void Dispose(bool disposing)
    {
        if (disposing)
        {
            await ExitAsync().ConfigureAwait(false);
        }
    }

    async ValueTask DisposeAsyncCoreAsync()
    {
        await ExitAsync().ConfigureAwait(false);
    }

    public async ValueTask ExitAsync()
    {
        if (ProxyStatus)
        {
            await StopProxyServiceAsync(isExit: true);
        }
        reverseProxyService.Dispose();
    }
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\Services\Mvvm\ProxyService.cs
DEBUG
DEBUG
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\Services\Mvvm\ProxyService.Operate.cs
/ </summary>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    async Task<OperateProxyServiceResult> StartProxyServiceAsync()
    {
        try
        {
            var result = await StartProxyServiceCoreAsync();
            return result;
        }
        catch (Exception ex)
        {
            return ex;
        }
    }

    async Task<OperateProxyServiceResult> StartProxyServiceCoreAsync()
    {
        IReadOnlyCollection<AccelerateProjectDTO>? proxyDomains = EnableProxyDomains;

        if (!proxyDomains.Any_Nullable())
        {
            Toast.Show(ToastIcon.Warning, Strings.CommunityFix_AccEmpty);
        }

        TracepointHelper.TrackEvent("StartProxy", new Dictionary<string, string> {
            { "ProxyType", ProxySettings.ProxyMode.Value.ToString() },
            { "ProxyScriptStatus", ProxySettings.IsEnableScript.Value.ToString() },
        });

        IReadOnlyCollection<ScriptIPCDTO>? scripts = default;
        bool isEnableScript = ProxySettings.IsEnableScript.Value;
        bool isOnlyWorkSteamBrowser = ProxySettings.IsOnlyWorkSteamBrowser.Value;
        ushort proxyPort = ProxySettings.SystemProxyPortId.Value == 0 ? ProxySettings.SystemProxyPortId.Default : ProxySettings.SystemProxyPortId.Value;
        string? proxyIp = ProxySettings.SystemProxyIp.Value;
        proxyMode = defaultProxyMode;
        bool isProxyGOG = ProxySettings.IsProxyGOG.Value;
        bool onlyEnableProxyScript = ProxySettings.OnlyEnableProxyScript.Value;
        bool enableHttpProxyToHttps = ProxySettings.EnableHttpProxyToHttps.Value;
        bool socks5ProxyEnable = ProxySettings.Socks5ProxyEnable.Value ||
            (OperatingSystem.IsAndroid() && 
/{proxyIp_.Value}:{proxyPort}/pac";
                var resultSetSystemPACProxy = await platformService.SetAsSystemPACProxyAsync(true, pacUrl);
                if (!resultSetSystemPACProxy)
                {
                    return Strings.CommunityFix_SetAsSystemPACProxyFail;
                }
                break;
#if WINDOWS && !REMOVE_DNS_INTERCEPT
            case ProxyMode.DNSIntercept:
                {
                    await Mobius.Helpers.WinDivertInitHelper.InitializeAsync();
                }
                break;
#endif
        }

        if (!OperatingSystem.IsWindows())
        {
            var checkRootCertificateCode = ICertificateManager.Constants.CheckRootCertificate(
                  platformService,
                  ICertificateManager.Constants.Instance);
            if (checkRootCertificateCode != StartProxyResultCode.Ok)
            {
                return $"CheckRootCertificate, ErrCode: {checkRootCertificateCode}";
            }
        }

        string? proxyToken = proxyDomains.Any_Nullable(s => s.ProxyType == ProxyType.ServerAccelerate || s.Items.Any_Nullable(x => x.ProxyType == ProxyType.ServerAccelerate)) ?
            await TryRequestServerSideProxyToken() : null;

        ReverseProxySettings reverseProxySettings = new(proxyDomains, scripts,
            isEnableScript, isOnlyWorkSteamBrowser, proxyPort,
            proxyIp, proxyMode, isProxyGOG, onlyEnableProxyScript,
            enableHttpProxyToHttps, socks5ProxyEnable, socks5ProxyPortId,
            twoLevelAgentEnable, twoLevelAgentProxyType, twoLevelAgentIp,
            twoLevelAgentPortId, twoLevelAgentUserName, twoLevelAgentPassword, proxyDNS, isSupportIpv6, useDoh, customDohAddres, proxyToken);
        byte[] reverseProxySettings_ = Serializable.SMP2(reverseProxySettings);
        var startProxyResult = await reverseProxyService.StartProxyAsync(reverseProxySettings_);
        if (startProxyResult)
        {
            switch (proxyMode)
            {
                case ProxyMode.Hosts: 
/ </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    async Task<OperateProxyServiceResult> StopProxyServiceAsync(bool isExit = false)
    {
        try
        {
            var result = await StopProxyServiceCoreAsync(isExit);
            return result;
        }
        catch (Exception ex)
        {
            return ex;
        }
    }

    async Task<OperateProxyServiceResult> StopProxyServiceCoreAsync(bool isExit)
    {
        bool callSet = true;
#if WINDOWS
        if (isExit && !platformService.IsAdministrator)
        {
            
/ </summary>
    
/ <returns></returns>
    static async Task<string?> TryRequestServerSideProxyToken()
    {
        try
        {
            if (!string.IsNullOrEmpty(proxyTokenCache))
                return proxyTokenCache;

            var resp = await IMicroServiceClient.Instance.Account
                .GenerateServerSideProxyToken();

            if (resp != null && !string.IsNullOrEmpty(resp.Content?.AccessToken))
            {
                proxyTokenCache = resp.Content.AccessToken;
            }

            return proxyTokenCache;
        }
        catch (Exception ex)
        {
            ex.LogAndShowT();
            return null;
        }
    }

    
/ </summary>
    
/ <param name="Error"></param>
    readonly record struct OperateProxyServiceResult(string? Error, Exception? Exception = null)
    {
        public static implicit operator OperateProxyServiceResult(string error) => new(error);

        public static implicit operator OperateProxyServiceResult(Exception exception) => new(null, exception);

        
/ </summary>
        
/ <returns></returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool OnStartedShowToastReturnProxyStatus()
        {
            bool proxyStatus;
            if (string.IsNullOrWhiteSpace(Error))
            {
                Toast.Show(ToastIcon.Success, Strings.CommunityFix_StartProxySuccess);
                proxyStatus = true;
            }
            else if (Exception != null)
            {
                Exception.LogAndShowT(nameof(ProxyService));
                proxyStatus = false;
            }
            else
            {
                Toast.Show(ToastIcon.Error, Error);
                proxyStatus = false;
            }
            return proxyStatus;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool OnStopedShowToastReturnProxyStatus()
        {
            bool proxyStatus = default;
            if (!string.IsNullOrWhiteSpace(Error))
            {
                Toast.Show(ToastIcon.Error, Error);
                proxyStatus = true;
            }
            else if (Exception != null)
            {
                Exception.LogAndShowT(nameof(ProxyService));
                proxyStatus = true;
            }
            return proxyStatus;
        }
    }

    async Task<(long delayMs, string dns)> GetValidDNSAsync(string dns, CancellationToken cancellationToken = default)
    {
        var testDomain = "dnscheck-test.steampp.net";
        try
        {
            long delayMs;
            IPAddress[] address;
            if (ProxySettings.UseDoh.Value)
            {
                (delayMs, address) = await INetworkTestService.Instance.TestDNSOverHttpsAsync(testDomain, dns, cancellationToken: cancellationToken);
            }
            else
            {
                (delayMs, address) = await INetworkTestService.Instance.TestDNSAsync(testDomain, dns, 53, cancellationToken: cancellationToken);
            }
            if (address.Length == 0)
                throw new Exception("Parsing failed. Return empty ip address.");

            return (delayMs, dns);
        }
        catch (Exception ex)
        {
            Log.Error(nameof(StartOrStopProxyService), ex.ToString(), "DNS检测出错");
            return (0, dns);
        }
    }

    async Task<string?> GetFastestDNSAsync(IEnumerable<string> dnsAddresses, CancellationToken cancellationToken = default)
    {
        var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
        var tasks = new List<Task<(long delayMs, string dns)>>();

        foreach (var dns in dnsAddresses)
        {
            tasks.Add(GetValidDNSAsync(dns, cts.Token));
        }

        try
        {
            
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\Services\Mvvm\ProxyService.Operate.cs
MACCATALYST
REMOVE
WINDOWS
WINDOWS
REMOVE
WINDOWS
MACOS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\Services.Implementation\BackendAcceleratorServiceImpl.XunYou.cs
/*async*/
    void XunYouAccelStateToFrontendCallback(XunYouAccelStateModel m)
    {
        if (disposedValue)
            return;

        try
        {
            
/ <inheritdoc/>
    public async Task<ApiRsp<bool>> XY_IsInstall(CancellationToken cancellationToken = default)
    {
        if (!XunYouSDK.IsSupported)
        {
            return ApiRspHelper.Ok(false);
        }

        var result = XunYouSDK.IsInstall();
        await Task.CompletedTask;
        return result;
    }

    
/ <inheritdoc/>
    public async Task<ApiRsp<XunYouUninstallCode>> XY_Uninstall(CancellationToken cancellationToken = default)
    {
        if (!XunYouSDK.IsSupported)
        {
            return ApiRspHelper.Ok(XunYouUninstallCode.卸载成功);
        }

        var result = XunYouSDK.Uninstall();
        await Task.CompletedTask;
        return result;
    }

    
/ <inheritdoc/>
    public async Task<ApiRsp<int>> XY_StartEx2(
        string openid,
        string nickname,
        int gameid,
        int area,
        int server,
        string? areaPath = default,
        string? svrPath = default,
        CancellationToken cancellationToken = default)
    {
        if (!XunYouSDK.IsSupported)
        {
            return ApiRspHelper.Ok(0);
        }

        var show = XunYouShowCommands.SW_HIDE;
        var result = XunYouSDK.StartEx2(
            openid,
            nickname,
            show,
            gameid,
            area,
            server,
            null,
            default,
            GameAcceleratorSettings.WattAcceleratorDirPath.Value!,
            areaPath,
            svrPath);
        await Task.CompletedTask;
        return result;
    }

    
/ <inheritdoc/>
    public async Task<ApiRsp<int>> XY_StartAccel(
      int gameid,
      int area,
      int serverid = default,
      string? areaName = default,
      string? svrName = default,
      CancellationToken cancellationToken = default)
    {
        if (!XunYouSDK.IsSupported)
        {
            return ApiRspHelper.Ok(0);
        }

        var result = XunYouSDK.StartAccel(
            gameid,
            area,
            areaName,
            serverid,
            svrName);
        await Task.CompletedTask;
        return result == XunYouSendResultCode.发送失败 ? 300 : 101;
    }

    
/ <inheritdoc/>
    public async Task<ApiRsp<XunYouAccelStateModel?>> XY_GetAccelStateEx(CancellationToken cancellationToken = default)
    {
        if (!XunYouSDK.IsSupported)
        {
            return ApiRspHelper.Ok((XunYouAccelStateModel?)null);
        }

        var result = GetXunYouAccelStateModel(lastXunYouState);
        await Task.CompletedTask;
        return result;
    }

    
/ <inheritdoc/>
    public async IAsyncEnumerable<ApiRsp<int>> XY_Install(string installPath, [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        if (!XunYouSDK.IsSupported)
        {
            yield break;
        }

        var channel = Channel.CreateUnbounded<int>();
        int XunYouDownLoadCallback(int par, nint thisptr)
        {
            channel.Writer.TryWrite(par);
            if (par > 100)
            {
                channel.Writer.Complete();
            }
            return 0;
        }
        var installPackPath = Plugin.Instance.CacheDirectory;
        var result = XunYouSDK.Install(XunYouDownLoadCallback, default, installPath, installPackPath);
        if (result == 101) 
/ <inheritdoc/>
    public async Task<ApiRsp<XunYouSendResultCode>> XY_StopAccel(CancellationToken cancellationToken = default)
    {
        if (!XunYouSDK.IsSupported)
        {
            return ApiRspHelper.Ok(XunYouSendResultCode.发送成功);
        }

        var result = XunYouSDK.Stop();
        await Task.CompletedTask;
        return result;
    }

    
/ <inheritdoc/>
    public async Task<ApiRsp<XunYouIsRunningCode>> XY_IsRunning(CancellationToken cancellationToken = default)
    {
        if (!XunYouSDK.IsSupported)
        {
            return ApiRspHelper.Ok(XunYouIsRunningCode.加速器未启动);
        }

        var result = XunYouSDK.IsRunning();
        await Task.CompletedTask;
        return result;
    }

    
/ <inheritdoc/>
    public async Task<ApiRsp<XunYouStartGameCode>> XY_StartGame(CancellationToken cancellationToken = default)
    {
        if (!XunYouSDK.IsSupported)
        {
            return ApiRspHelper.Ok(XunYouStartGameCode.失败);
        }

        var result = XunYouSDK.StartGame();
        await Task.CompletedTask;
        return result;
    }

    
/ <inheritdoc/>
    public async Task<ApiRsp<int>> XY_ShowWinodw(bool showHide, CancellationToken cancellationToken = default)
    {
        if (!XunYouSDK.IsSupported)
        {
            return ApiRspHelper.Ok(0);
        }

        XunYouSDK.xunyou_show(Convert.ToInt32(showHide));
        await Task.CompletedTask;
        return ApiRspHelper.Ok(0);
    }
}

发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\Services.Implementation\BackendAcceleratorServiceImpl.XunYou.cs
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\Services.Implementation\NetworkEnvCheckService.cs
/etc/hosts";
#endif

    public async Task CheckNetworkEnvAsync(IProgress<(NetworkEnvCheckStep Step, bool HasError, string Msg)> progress, CancellationToken cancellationToken = default)
    {
        await Parallel.ForAsync(
               (int)NetworkEnvCheckStep.HostsFileCheck,
               (int)NetworkEnvCheckStep.LSPCheck + 1,
               cancellationToken,
               async (step, ct) =>
               {
                   (bool pass, string msg) = step switch
                   {
                       (int)NetworkEnvCheckStep.HostsFileCheck => await CheckHostsAsync(),
                       (int)NetworkEnvCheckStep.NetworkInterfaceCheck => CheckNetworkInterfaces(),
                       (int)NetworkEnvCheckStep.LSPCheck =>
#if WINDOWS
                            CheckLSP(HandleWSAProtocolInfo),
#else
                           (true, string.Empty),
#endif
                       _ => (true, string.Empty)
                   };

                   progress.Report(((NetworkEnvCheckStep)step, pass, msg));
               }
           ).ConfigureAwait(false);
    }

    private static Task<(bool Pass, string Msg)> CheckHostsAsync()
    {
        bool hostFileExist = File.Exists(HOST_FILE_PATH);

        if (!hostFileExist)
            return Task.FromResult((false, "未找到 hosts 文件"));

        return Task.FromResult((hostFileExist, string.Empty));
    }

    private static (bool Pass, string ErrorMsg) CheckNetworkInterfaces(NetworkInterface[]? interfaces = null)
    {
        interfaces ??= NetworkInterface.GetAllNetworkInterfaces();

        if (interfaces == null || interfaces.Length == 0)
            return (false, "未获取到网络适配器信息!");

        
/ 如何判断虚拟网卡?

        var useableNetworkInterfaces =
            interfaces.Where(x =>
                !x.Description.Contains("Virtual", StringComparison.OrdinalIgnoreCase) &&
                (x.NetworkInterfaceType == NetworkInterfaceType.Ethernet || x.NetworkInterfaceType == NetworkInterfaceType.Wireless80211));

        if (!useableNetworkInterfaces.Any())
            return (false, "未获取到可用的以太网,无线网络适配器");

        var checkResults =
            useableNetworkInterfaces.Select(x => new
            {
                Source = x,
                Result = CheckNetworkInterface(x)
            });

        if (checkResults.Any(x => x.Result.Pass))
            return (true, string.Empty);

        var firstError = checkResults.First(x => !x.Result.Pass);

        return (firstError.Result.Pass, $"{firstError.Source.Name}|{firstError.Source.Description} {firstError.Result.ErrorMsg}");
    }

    private static (bool Pass, string ErrorMsg) CheckNetworkInterface(NetworkInterface @interface)
    {
        var name = @interface.Name;
        var desc = @interface.Description;

        var ipProps = @interface.GetIPProperties();

        if (@interface.OperationalStatus != OperationalStatus.Up)
            return (false, "未启用网卡");

        if (ipProps == null)
            return (false, $"获取网络信息失败!");

        bool hasIPv4 = ipProps.UnicastAddresses
            .Any(x => x.Address.AddressFamily == AddressFamily.InterNetwork);

        bool hasIPv6 = ipProps.UnicastAddresses
            .Any(x => x.Address.AddressFamily == AddressFamily.InterNetworkV6);

        if (!hasIPv4 && !hasIPv6)
            return (false, "网络适配器未启用TCP/IP服务");

        
/ 获取 buffer 的大小
        _ = WSCEnumProtocols(null, IntPtr.Zero, ref bufferSize, ref error);

        IntPtr protocolBuffer = Marshal.AllocHGlobal(bufferSize);

        try
        {
            int result = WSCEnumProtocols(null, protocolBuffer, ref bufferSize, ref error);
            if (result == -1)
            {
                return (false, "获取LSP信息失败!");
            }

            int structSize = Marshal.SizeOf(typeof(WSAPROTOCOL_INFO));
            int count = bufferSize / structSize;

            for (int i = 0; i < count; i++)
            {
                IntPtr item = new(protocolBuffer + (i * structSize));

                WSAPROTOCOL_INFO protocolInfo = Marshal.PtrToStructure<WSAPROTOCOL_INFO>(item);

#if DEBUG
                
/ Console.WriteLine();
#endif
                var handle = predicate(in protocolInfo);

                if (!handle)
                    return (false, "LSP响应异常!");
            }

            return (true, string.Empty);
        }
        finally
        {
            Marshal.FreeHGlobal(protocolBuffer);
        }
    }

    #region P/Invoke

    
/ </summary>
    
/ <param name="info"></param>
    
/ <returns></returns>
    static bool HandleWSAProtocolInfo(in WSAPROTOCOL_INFO info)
    {
        const int MAX = 255;

        StringBuilder pathBuilder = new StringBuilder(MAX);
        int pathLength = MAX;

        Guid queryProviderId = info.ProviderId;

        int result = WSCGetProviderPath(ref queryProviderId, pathBuilder, ref pathLength, out int errorCode);

        if (result != 0)
        {
            
/learn.microsoft.com/zh-cn/windows/win32/api/winsock2/ns-winsock2-wsaprotocol_infoa"/>
    
/ </summary>
    [SuppressMessage("StyleCop.CSharp.NamingRules", "SA1307:Accessible fields should begin with upper-case letter", Justification = "<挂起>")]
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    private struct WSAPROTOCOL_INFO
    {
        
/ </summary>
        public uint dwServiceFlags1;

        
/ </summary>
        public uint dwServiceFlags2;

        
/ </summary>
        public uint dwServiceFlags3;

        
/ </summary>
        public uint dwServiceFlags4;

        
/ </summary>
        public uint dwProviderFlags;

        
/ </summary>
        public Guid ProviderId;

        
/ </summary>
        public uint dwCatalogEntryId;

        public WSAPROTOCOLCHAIN ProtocolChain;

        
/ </summary>
        public int iVersion;

        
/ </summary>
        public int iAddressFamily;

        
/ </summary>
        public int iMaxSockAddr;

        
/ </summary>
        public int iMinSockAddr;

        public int iSocketType;
        public int iProtocol;
        public int iProtocolMaxOffset;

        
/ </summary>
        public int iNetworkByteOrder;

        public int iSecurityScheme;

        
/ </summary>
        public uint dwMessageSize;

        public uint dwProviderReserved;

        
/ 一个字符数组，其中包含标识协议的可读名称，例如“MSAFD Tcpip [UDP/IP]”。 允许的最大字符数为 WSAPROTOCOL_LEN，定义为 255。
        
/ </summary>
        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
        public string szProtocol;
    }

    
/learn.microsoft.com/zh-cn/windows/win32/api/winsock2/ns-winsock2-wsaprotocolchain"/>
    
/ </summary>
    [StructLayout(LayoutKind.Sequential)]
    private struct WSAPROTOCOLCHAIN
    {
        
/ </summary>
        public int ChainLen;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 7)]
        public uint[] ChainEntries;
    }

    #endregion P/Invoke
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\Services.Implementation\NetworkEnvCheckService.cs
WINDOWS
WINDOWS
WINDOWS
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\Services.Implementation\NetworkTestService.cs
/ </summary>
    
/ <param name="testHostNameOrAddress"></param>
    
/ <param name="timeout"></param>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    public async Task<PingReply> TestPingAsync(string testHostNameOrAddress, TimeSpan timeout, CancellationToken cancellationToken = default)
    {
        using Ping p = new Ping();

        var reply = await p.SendPingAsync(
                testHostNameOrAddress,
                timeout,
                cancellationToken: cancellationToken
            );

        return reply;
    }

    #endregion Ping

    #region Open/Upload/Download Speed Test

    public async Task<(bool Success, long? DelayMs)> TestOpenUrlAsync(string url, Func<HttpClient>? httpClientFunc = null, CancellationToken cancellationToken = default)
    {
        using var testClient = httpClientFunc?.Invoke() ?? new HttpClient();

        Stopwatch watch = Stopwatch.StartNew();

        try
        {
            var resp = await testClient.GetAsync(url, HttpCompletionOption.ResponseContentRead, cancellationToken);

            watch.Stop();

            return (true, watch.ElapsedMilliseconds);
        }
        catch (Exception ex)
        {
            Log.Error(nameof(NetworkTestService), ex, "测试打开 URL 异常");
            return (false, default);
        }
    }

    public async Task<(bool Success, double? Rate)> TestUploadSpeedAsync(
            string uploadServerUrl,
            byte[] uploadBytes,
            CancellationToken cancellationToken = default
        )
    {
        using HttpClient testClient = new HttpClient();

        return await TestUploadSpeedCoreAsync(
                () => testClient,
                BuildUploadContent,
                uploadServerUrl,
                uploadBytes,
                cancellationToken
            );

        static MultipartFormDataContent BuildUploadContent(byte[] data)
        {
            MultipartFormDataContent content = new MultipartFormDataContent();

            content.Add(new ByteArrayContent(data));

            return content;
        }
    }

    public async Task<(bool Success, double? Rate)> TestDownloadSpeedAsync(string downloadUrl, CancellationToken cancellationToken = default)
    {
        using HttpClient testClient = new HttpClient();

        return await TestDownloadSpeedCoreAsync(downloadUrl, () => testClient, cancellationToken);
    }

    
/ </summary>
    
/ <param name="httpClientFunc">自定义用于发送 http 请求的 client </param>
    
/ <param name="uploadContentFunc">自定义上传内容类型</param>
    
/ <param name="uploadServerUrl"></param>
    
/ <param name="uploadBytes"></param>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    static async Task<(bool Success, double? Rate)> TestUploadSpeedCoreAsync(
                Func<HttpClient> httpClientFunc,
                Func<byte[], HttpContent> uploadContentFunc,
                string uploadServerUrl,
                byte[] uploadBytes,
                CancellationToken cancellationToken = default
            )
    {
        if (string.IsNullOrWhiteSpace(uploadServerUrl))
            return (false, null);

        var uploadContent = uploadContentFunc(uploadBytes);
        try
        {
            var httpClient = httpClientFunc();

            Stopwatch watch = Stopwatch.StartNew();

            var resp = await httpClient.PostAsync(uploadServerUrl, uploadContent, cancellationToken);

            resp.EnsureSuccessStatusCode();

            watch.Stop();

            return (true, GetRate(uploadBytes.Length, watch.Elapsed.TotalSeconds));
        }
        catch (Exception ex)
        {
            Log.Error(nameof(NetworkTestService), ex, "测试上传异常");
        }

        return (false, null);
    }

    
/ </summary>
    
/ <param name="url"></param>
    
/ <param name="httpClientFunc"></param>
    
/ <returns></returns>
    static async Task<(bool Success, double? Rate)> TestDownloadSpeedCoreAsync(string url, Func<HttpClient>? httpClientFunc = null, CancellationToken cancellationToken = default)
    {
        var httpClient = httpClientFunc?.Invoke() ?? new HttpClient();

        try
        {
            Stopwatch watch = Stopwatch.StartNew();

            var resp = await httpClient.GetAsync(url, HttpCompletionOption.ResponseHeadersRead, cancellationToken);

            resp.EnsureSuccessStatusCode();

            var bytesArray = await resp.Content.ReadAsByteArrayAsync(cancellationToken);

            watch.Stop();

            return (true, GetRate(bytesArray.Length, watch.Elapsed.TotalSeconds));
        }
        catch (Exception ex)
        {
            Log.Error(nameof(NetworkTestService), ex, "测试下载异常");
            return (false, null);
        }
        finally
        {
            if (httpClientFunc == null)
                httpClient.Dispose();
        }
    }

    static double GetRate(long byteArrayLength, double seconds)
    {
        if (seconds == 0)
            throw new ArgumentException("时间不能小于0", nameof(seconds));

        long bits = byteArrayLength * 8;
        double megabits = bits / 1_000_000.0; 
/ 将比特转换为兆比特

        return megabits / seconds; 
/ 返回速率，单位是 Mbps
    }

    #endregion Open/Upload/Download Speed Test

    #region STUN 测试

    #region RFC3489

    StunClient3489? _stunClient;

    
/ </summary>
    
/ <param name="testServerHostName">测试服务地址</param>
    
/ <param name="testServerPort">测试服务端口</param>
    
/ <param name="localIPEndPoint">本机 IP </param>
    
/ <param name="force">强制刷新</param>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    public async Task<ClassicStunResult?> TestStunClient3489Async(
            string? testServerHostName = DEFAULT_TESTSERVER_HOSTNAME,
            int? testServerPort = DEFAULT_TESTSTUN3489_PORT,
            IPEndPoint? localIPEndPoint = null,
            bool force = false,
            CancellationToken cancellationToken = default
        )
    {
        testServerHostName ??= DEFAULT_TESTSERVER_HOSTNAME;
        testServerPort ??= DEFAULT_TESTSTUN3489_PORT;

        if (_stunClient == null || force)
            _stunClient = await GetStunClient3489Async(testServerHostName, testServerPort.Value, localIPEndPoint);

        try
        {
            await _stunClient.QueryAsync(cancellationToken);
        }
        catch (OperationCanceledException) { throw; }
        catch (Exception ex)
        {
            Log.Error(nameof(NetworkTestService), ex, "TestStunClient3489Async 异常");
            return null;
        }

        return _stunClient.State;
    }

    private async ValueTask<StunClient3489> GetStunClient3489Async(string serverHostName, int port, IPEndPoint? localIPEndPoint = null)
    {
        IPEndPoint serverEndpoint = await GetServerIPEndPointAsync(serverHostName, port);

        IPEndPoint localEndpoint = localIPEndPoint ?? new IPEndPoint(IPAddress.Any, default);

        var client = new StunClient3489(
             serverEndpoint,
             localEndpoint
             );

        return client;
    }

    private async Task<IPEndPoint> GetServerIPEndPointAsync(string hostNameOrAddress, int port)
    {
        var serverIps = await Dns.GetHostAddressesAsync(hostNameOrAddress);

        IPEndPoint serverEndpoint = new IPEndPoint(serverIps.First(), port);

        return serverEndpoint;
    }

    #endregion RFC3489

    #region RFC5389

    
/ </summary>
    
/ <param name="protocol"></param>
    
/ <param name="testServerHostName"></param>
    
/ <param name="testServerPort"></param>
    
/ <param name="localIPEndPoint"></param>
    
/ <param name="force"></param>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    public async Task<StunResult5389?> TestStunClient5389Async(
            TransportProtocol protocol,
            string? testServerHostName = DEFAULT_TESTSERVER_HOSTNAME,
            int? testServerPort = DEFAULT_TESTSTUN5389_PORT,
            IPEndPoint? localIPEndPoint = null,
            CancellationToken cancellationToken = default
        )
    {
        testServerHostName ??= DEFAULT_TESTSERVER_HOSTNAME;
        testServerPort ??= DEFAULT_TESTSTUN5389_PORT;

        IStunClient5389 client = await GetStunClient5389Async(protocol, testServerHostName, testServerPort.Value, localIPEndPoint);

        if (client == null)
            return null;

        try
        {
            await client.QueryAsync(cancellationToken);
        }
        catch (OperationCanceledException) { throw; }
        catch (Exception ex)
        {
            Log.Error(nameof(NetworkTestService), ex, "TestStunClient5389Async 异常");
            return null;
        }

        return client.State;
    }

    private async ValueTask<IStunClient5389> GetStunClient5389Async(TransportProtocol protocol, string serverHostName, int port, IPEndPoint? localIPEndPoint = null)
    {
        IPEndPoint serverEndpoint = await GetServerIPEndPointAsync(serverHostName, port);

        IPEndPoint localEndpoint = localIPEndPoint ?? new IPEndPoint(IPAddress.Any, default);

        IStunClient5389 client = protocol == TransportProtocol.Tcp
            ? new StunClient5389TCP(serverEndpoint, localEndpoint)
            : new StunClient5389UDP(serverEndpoint, localEndpoint);

        return client;
    }

    #endregion RFC5389

    #endregion STUN 测试

    #region DNS 查询

    
/ </summary>
    
/ <param name="testDomain">要测试的域名</param>
    
/ <param name="dnsServerIp">DNS 服务地址</param>
    
/ <param name="dnsServerPort">DNS 服务端口</param>
    
/ <param name="dnsRecordType"> dns 测试类型 </param>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    public async Task<(long DelayMs, IPAddress[] Address)> TestDNSAsync(
            string testDomain,
            string dnsServerIp,
            int dnsServerPort,
            DnsQueryAnswerRecord.DnsRecordType dnsRecordType = DnsQueryAnswerRecord.DnsRecordType.A,
            CancellationToken cancellationToken = default
        )
    {
        using UdpClient udpClient = new UdpClient(dnsServerIp, dnsServerPort);
        udpClient.Client.SendTimeout = 3000;
        udpClient.Client.ReceiveTimeout = 3000;
        var query = new DnsQueryUdpRequest(testDomain, dnsRecordType);

        Stopwatch watch = Stopwatch.StartNew();

        await udpClient.SendAsync(query, cancellationToken);

        var receivedData = await udpClient.ReceiveAsync(cancellationToken);

        watch.Stop();

        var dnsQueryResponse = new DnsQueryUdpResponse(receivedData.Buffer);

        return (watch.ElapsedMilliseconds, dnsQueryResponse.GetAddresses().ToArray());
    }

    
/ </summary>
    
/ <param name="testDomain"></param>
    
/ <param name="dohServer"></param>
    
/ <param name="dnsRecordType"></param>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    public async Task<(long DelayMs, IPAddress[] Address)> TestDNSOverHttpsAsync(
        string testDomain,
        string dohServer,
        DnsQueryAnswerRecord.DnsRecordType dnsRecordType = DnsQueryAnswerRecord.DnsRecordType.A,
        CancellationToken cancellationToken = default)
    {
        var handler = new HttpClientHandler
        {
            UseCookies = false,
            UseProxy = false,
            Proxy = HttpNoProxy.Instance,
        };
        using HttpClient client = new HttpClient(handler);
        client.Timeout = TimeSpan.FromSeconds(3);
        string queryUrl = $"{dohServer}?name={testDomain}&type={dnsRecordType}";

        Stopwatch watch = Stopwatch.StartNew();

        HttpResponseMessage? resp = null;
        try
        {
            resp = await client.GetAsync(queryUrl, HttpCompletionOption.ResponseContentRead, cancellationToken);

            resp.EnsureSuccessStatusCode();
        }
        finally
        {
            watch.Stop();
        }

        var queryResp = await resp.Content.ReadFromJsonAsync<DnsQueryJsonResponse>();

        return (watch.ElapsedMilliseconds, queryResp?.GetAddresses().ToArray() ?? Array.Empty<IPAddress>());
    }

    #region DNS 解析定义

    internal interface IDnsQueryResponse
    {
        List<DnsQueryAnswerRecord> Answers { get; }

        IEnumerable<IPAddress> GetAddresses();
    }

    internal record DnsQueryUdpResponse : DnsQueryUdpRequest, IDnsQueryResponse
    {
        public ushort AnswerCount { get; init; } 
/ 如查询/响应（QR）、操作码（Opcode）、授权回答（AA）、截断（TC）、递归期望（RD）、递归可用（RA）等
                query[2] = 0x01;

                
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\Services.Implementation\ScriptManager.cs
/ <inheritdoc cref="IScriptManager"/>
public sealed class ScriptManager : GeneralHttpClientFactory, IScriptManager
{
    const string TAG = nameof(ScriptManager);
    const string HomepageURL = "HomepageURL";
    const string DownloadURL = "DownloadURL";
    const string UpdateURL = "UpdateURL";
    const string Exclude = "Exclude";
    const string Grant = "Grant";
    const string Require = "Require";
    const string Include = "Include";
    const string DescRegex = @"(?<={0})[\s\S]*?(?=\n)";

    protected override string? DefaultClientName => TAG;

    readonly IToast toast;
    readonly IMapper mapper;
    readonly IScriptRepository scriptRepository;
    readonly IMicroServiceClient csc;

    public ScriptManager(
        IHttpClientFactory clientFactory,
        IScriptRepository scriptRepository,
        IMapper mapper,
        ILoggerFactory loggerFactory,
        IToast toast,
        IHttpPlatformHelperService http_helper,
        IMicroServiceClient csc) : base(
            loggerFactory.CreateLogger(TAG),
            http_helper, clientFactory)
    {
        this.scriptRepository = scriptRepository;
        this.mapper = mapper;
        this.toast = toast;
        this.csc = csc;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    Task<T?> GetAsync<T>(string requestUri, string accept = MediaTypeNames.JSON, CancellationToken cancellationToken = default) where T : notnull
    {
        var client = CreateClient(null, HttpHandlerCategory.Default);
        return client.GetAsync<T>(logger, requestUri, accept,
            cancellationToken: cancellationToken, userAgent: http_helper.UserAgent);
    }

    public async Task<ScriptDTO?> ReadScriptAsync(string path)
    {

        var content = await File.ReadAllTextAsync(path);
        if (!string.IsNullOrEmpty(content))
        {
            var userScript = content.Substring("==UserScript==", "==/UserScript==");
            if (!string.IsNullOrEmpty(userScript))
            {
                var script = new ScriptDTO
                {
                    FilePath = path,
                    Content = content.Replace("</script>", "<\\/script>"),
/Content = content.Replace("</script>", "<\\/script>").Replace(" ", "").Replace("\r", "").Replace("\n", "").Replace("\t", ""),
                    Name = Regex.Match(userScript, string.Format(DescRegex, "@Name"), RegexOptions.IgnoreCase).GetValue(s => s.Success == true),
                    
/ </summary>
    
/ <param name="list"></param>
    
/ <returns></returns>
    public async Task<IEnumerable<ScriptDTO>> CheckFiles(IEnumerable<ScriptDTO> list)
    {
        var scripts = list.ToList();
        foreach (var item in list)
        {
            if (!CheckFile(item))
            {
                var temp = await DeleteScriptAsync(item);
                scripts.Remove(item);
                if (temp.IsSuccess)
                {
                    
/ </summary>
    
/ <param name="item"></param>
    
/ <param name="isReadContent"></param>
    
/ <returns></returns>
    public async Task<ScriptDTO> TryReadFileAsync(ScriptDTO item, bool isReadContent = false)
    {
        var cachePath = Path.Combine(Plugin.Instance.CacheDirectory, item.CachePath);
        if (File.Exists(cachePath))
        {
            item.Content = File.ReadAllText(cachePath);
        }
        else
        {
            var fileInfo = new FileInfo(cachePath);
            var infoPath = Path.Combine(Plugin.Instance.AppDataDirectory, item.FilePath);
            if (File.Exists(infoPath))
            {
                if (isReadContent)
                {
                    item.Content = File.ReadAllText(infoPath);
                }
                if (!await BuildScriptAsync(item, fileInfo, item.IsCompile))
                {
                    toast.Show(ToastIcon.Error, AppResources.Script_ReadFileError_.Format(item.Name));
                }
            }
            else
            {
                var temp = await DeleteScriptAsync(item);
                if (temp.IsSuccess)
                {
                    
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\Settings\GameAcceleratorSettings.cs
/ </summary>
    [MP2Key(0), JsonPropertyOrder(0)]
    public Dictionary<int, XunYouGameViewModel> MyGames { get; set; } = [];

    
/ </summary>
    [MP2Key(1), JsonPropertyOrder(1)]
    public string WattAcceleratorDirPath { get; set; } = DefaultWattAcceleratorDirPath;

    public static readonly string DefaultWattAcceleratorDirPath = OperatingSystem.IsWindows() ?
        Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ProgramFilesX86), "WattAccelerator") : string.Empty;

}

public static partial class GameAcceleratorSettings
{
    
/ <inheritdoc cref="GameAcceleratorSettingsModel.MyGames"/>
    public static SettingsProperty<int, XunYouGameViewModel, Dictionary<int, XunYouGameViewModel>, GameAcceleratorSettings_> MyGames { get; }
        = new();

    
/ <inheritdoc cref="GameAcceleratorSettingsModel.WattAcceleratorDirPath"/>
    public static SettingsProperty<string, GameAcceleratorSettings_> WattAcceleratorDirPath { get; }
        = new(GameAcceleratorSettings_.DefaultWattAcceleratorDirPath);
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\Settings\ProxySettings.cs
/ </auto-generated>

/ </summary>
    [MPKey(0), MP2Key(0), JsonPropertyOrder(0)]
    public bool IsAutoCheckScriptUpdate { get; set; } = IProxySettings.DefaultIsAutoCheckScriptUpdate;

    
/ </summary>
    [MPKey(1), MP2Key(1), JsonPropertyOrder(1)]
    public bool IsEnableScript { get; set; } = IProxySettings.DefaultIsEnableScript;

    
/ </summary>
    [MPKey(2), MP2Key(2), JsonPropertyOrder(2)]
    public IReadOnlyCollection<string>? SupportProxyServicesStatus { get; set; } = IProxySettings.DefaultSupportProxyServicesStatus;

    
/ </summary>
    [MPKey(3), MP2Key(3), JsonPropertyOrder(3)]
    public IReadOnlyCollection<int>? ScriptsStatus { get; set; } = IProxySettings.DefaultScriptsStatus;

    #region 代理设置

    
/ </summary>
    [MPKey(4), MP2Key(4), JsonPropertyOrder(4)]
    public bool ProgramStartupRunProxy { get; set; } = IProxySettings.DefaultProgramStartupRunProxy;

    
/ </summary>
    [MPKey(5), MP2Key(5), JsonPropertyOrder(5)]
    public ushort SystemProxyPortId { get; set; } = IProxySettings.DefaultSystemProxyPortId;

    
/ </summary>
    [MPKey(6), MP2Key(6), JsonPropertyOrder(6)]
    public string? SystemProxyIp { get; set; } = IProxySettings.DefaultSystemProxyIp;

    
/ </summary>
    [MPKey(7), MP2Key(7), JsonPropertyOrder(7)]
    public bool OnlyEnableProxyScript { get; set; } = IProxySettings.DefaultOnlyEnableProxyScript;

    
/ </summary>
    [MPKey(8), MP2Key(8), JsonPropertyOrder(8)]
    public string? ProxyMasterDns { get; set; } = IProxySettings.DefaultProxyMasterDns;

    
/ </summary>
    [MPKey(9), MP2Key(9), JsonPropertyOrder(9)]
    public bool EnableHttpProxyToHttps { get; set; } = IProxySettings.DefaultEnableHttpProxyToHttps;

    #endregion

    #region 本地代理设置

    
/ </summary>
    [MPKey(10), MP2Key(10), JsonPropertyOrder(10)]
    public bool Socks5ProxyEnable { get; set; } = IProxySettings.DefaultSocks5ProxyEnable;

    
/ </summary>
    [MPKey(11), MP2Key(11), JsonPropertyOrder(11)]
    public ushort Socks5ProxyPortId { get; set; } = IProxySettings.DefaultSocks5ProxyPortId;

    #endregion

    #region 二级代理设置

    
/ </summary>
    [MPKey(12), MP2Key(12), JsonPropertyOrder(12)]
    public bool TwoLevelAgentEnable { get; set; } = IProxySettings.DefaultTwoLevelAgentEnable;

    
/ </summary>
    [MPKey(13), MP2Key(13), JsonPropertyOrder(13)]
    public ExternalProxyType TwoLevelAgentProxyType { get; set; } = IProxySettings.DefaultTwoLevelAgentProxyType;

    
/ </summary>
    [MPKey(14), MP2Key(14), JsonPropertyOrder(14)]
    public string? TwoLevelAgentIp { get; set; } = IProxySettings.DefaultTwoLevelAgentIp;

    
/ </summary>
    [MPKey(15), MP2Key(15), JsonPropertyOrder(15)]
    public ushort TwoLevelAgentPortId { get; set; } = IProxySettings.DefaultTwoLevelAgentPortId;

    
/ </summary>
    [MPKey(16), MP2Key(16), JsonPropertyOrder(16)]
    public string? TwoLevelAgentUserName { get; set; } = IProxySettings.DefaultTwoLevelAgentUserName;

    
/ </summary>
    [MPKey(17), MP2Key(17), JsonPropertyOrder(17)]
    public string? TwoLevelAgentPassword { get; set; } = IProxySettings.DefaultTwoLevelAgentPassword;

    #endregion

    #region 代理模式设置

    
/ </summary>
    [MPKey(18), MP2Key(18), JsonPropertyOrder(18)]
    public ProxyMode ProxyMode { get; set; } = IProxySettings.DefaultProxyMode;

    #endregion

    
/ </summary>
    [MPKey(19), MP2Key(19), JsonPropertyOrder(19)]
    public bool IsProxyGOG { get; set; } = IProxySettings.DefaultIsProxyGOG;

    
/ </summary>
    [MPKey(20), MP2Key(20), JsonPropertyOrder(20)]
    public bool IsOnlyWorkSteamBrowser { get; set; } = IProxySettings.DefaultIsOnlyWorkSteamBrowser;

    
/ </summary>
    [MPKey(21), MP2Key(21), JsonPropertyOrder(21)]
    public bool UseDoh { get; set; } = IProxySettings.DefaultUseDoh;

    
/ </summary>
    [MPKey(22), MP2Key(22), JsonPropertyOrder(22)]
    public string? CustomDohAddres2 { get; set; } = IProxySettings.DefaultCustomDohAddres2;

    
/ </summary>
    [MPKey(23), MP2Key(23), JsonPropertyOrder(23)]
    public int AcceleratorTabsSelectedIndex { get; set; } = IProxySettings.DefaultAcceleratorTabsSelectedIndex;

    
/ </summary>
    [MPKey(24), MP2Key(24), JsonPropertyOrder(24)]
    public bool AutoShowWattAcceleratorWindow { get; set; } = IProxySettings.DefaultAutoShowWattAcceleratorWindow;

    
/ </summary>
    [MPKey(25), MP2Key(25), JsonPropertyOrder(25)]
    public bool ProxyBeforeDNSCheck { get; set; } = IProxySettings.DefaultProxyBeforeDNSCheck;

}

public static partial class ProxySettings
{
    
/ </summary>
    public static SettingsStructProperty<bool, ProxySettings_> IsAutoCheckScriptUpdate { get; }
        = new(DefaultIsAutoCheckScriptUpdate);

    
/ </summary>
    public static SettingsStructProperty<bool, ProxySettings_> IsEnableScript { get; }
        = new(DefaultIsEnableScript);

    
/ </summary>
    public static SettingsProperty<IReadOnlyCollection<string>, ProxySettings_> SupportProxyServicesStatus { get; }
        = new(DefaultSupportProxyServicesStatus);

    
/ </summary>
    public static SettingsProperty<IReadOnlyCollection<int>, ProxySettings_> ScriptsStatus { get; }
        = new(DefaultScriptsStatus);

    #region 代理设置

    
/ </summary>
    public static SettingsStructProperty<bool, ProxySettings_> ProgramStartupRunProxy { get; }
        = new(DefaultProgramStartupRunProxy);

    
/ </summary>
    public static SettingsStructProperty<ushort, ProxySettings_> SystemProxyPortId { get; }
        = new(DefaultSystemProxyPortId);

    
/ </summary>
    public static SettingsProperty<string, ProxySettings_> SystemProxyIp { get; }
        = new(DefaultSystemProxyIp);

    
/ </summary>
    public static SettingsStructProperty<bool, ProxySettings_> OnlyEnableProxyScript { get; }
        = new(DefaultOnlyEnableProxyScript);

    
/ </summary>
    public static SettingsProperty<string, ProxySettings_> ProxyMasterDns { get; }
        = new(DefaultProxyMasterDns);

    
/ </summary>
    public static SettingsStructProperty<bool, ProxySettings_> EnableHttpProxyToHttps { get; }
        = new(DefaultEnableHttpProxyToHttps);

    #endregion

    #region 本地代理设置

    
/ </summary>
    public static SettingsStructProperty<bool, ProxySettings_> Socks5ProxyEnable { get; }
        = new(DefaultSocks5ProxyEnable);

    
/ </summary>
    public static SettingsStructProperty<ushort, ProxySettings_> Socks5ProxyPortId { get; }
        = new(DefaultSocks5ProxyPortId);

    #endregion

    #region 二级代理设置

    
/ </summary>
    public static SettingsStructProperty<bool, ProxySettings_> TwoLevelAgentEnable { get; }
        = new(DefaultTwoLevelAgentEnable);

    
/ </summary>
    public static SettingsStructProperty<ExternalProxyType, ProxySettings_> TwoLevelAgentProxyType { get; }
        = new(DefaultTwoLevelAgentProxyType);

    
/ </summary>
    public static SettingsProperty<string, ProxySettings_> TwoLevelAgentIp { get; }
        = new(DefaultTwoLevelAgentIp);

    
/ </summary>
    public static SettingsStructProperty<ushort, ProxySettings_> TwoLevelAgentPortId { get; }
        = new(DefaultTwoLevelAgentPortId);

    
/ </summary>
    public static SettingsProperty<string, ProxySettings_> TwoLevelAgentUserName { get; }
        = new(DefaultTwoLevelAgentUserName);

    
/ </summary>
    public static SettingsProperty<string, ProxySettings_> TwoLevelAgentPassword { get; }
        = new(DefaultTwoLevelAgentPassword);

    #endregion

    #region 代理模式设置

    
/ </summary>
    public static SettingsStructProperty<ProxyMode, ProxySettings_> ProxyMode { get; }
        = new(DefaultProxyMode);

    #endregion

#if (WINDOWS || MACCATALYST || MACOS || LINUX) && !(IOS || ANDROID)

    
/ </summary>
    public static SettingsStructProperty<bool, ProxySettings_> IsProxyGOG { get; }
        = new(DefaultIsProxyGOG);

    
/ </summary>
    public static SettingsStructProperty<bool, ProxySettings_> IsOnlyWorkSteamBrowser { get; }
        = new(DefaultIsOnlyWorkSteamBrowser);

#endif

    
/ </summary>
    public static SettingsStructProperty<bool, ProxySettings_> UseDoh { get; }
        = new(DefaultUseDoh);

    
/ </summary>
    public static SettingsProperty<string, ProxySettings_> CustomDohAddres2 { get; }
        = new(DefaultCustomDohAddres2);

    
/ </summary>
    public static SettingsStructProperty<int, ProxySettings_> AcceleratorTabsSelectedIndex { get; }
        = new(DefaultAcceleratorTabsSelectedIndex);

    
/ </summary>
    public static SettingsStructProperty<bool, ProxySettings_> AutoShowWattAcceleratorWindow { get; }
        = new(DefaultAutoShowWattAcceleratorWindow);

    
/ </summary>
    public static SettingsStructProperty<bool, ProxySettings_> ProxyBeforeDNSCheck { get; }
        = new(DefaultProxyBeforeDNSCheck);

}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\Settings\ProxySettings.ProxyMode.cs
/ <inheritdoc cref="ProxyMode"/>
    public static EProxyMode ProxyModeValue
    {
        get
        {
            var value = ProxyMode?.Value ?? ProxyModes[0];
            if (ProxyModes.Contains(value)) return value;
            return ProxyModes[0];
        }
        set => ProxyMode.Value = value;
    }

    public static string ToStringByProxyMode(EProxyMode mode) => mode switch
    {
        EProxyMode.DNSIntercept => AppResources.ProxyMode_DNSIntercept,
        EProxyMode.Hosts => AppResources.ProxyMode_Hosts,
        EProxyMode.System => AppResources.ProxyMode_System,
        EProxyMode.VPN => AppResources.ProxyMode_VPN,
        EProxyMode.ProxyOnly => AppResources.ProxyMode_ProxyOnly,
        _ => string.Empty,
    };

    public static string ProxyModeValueString => ToStringByProxyMode(ProxyModeValue);
}

发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\Settings\ProxySettings.ProxyMode.cs
WINDOWS
MACCATALYST
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\Settings\Abstractions\IProxySettings.cs
/ </auto-generated>

/ </summary>
    bool IsAutoCheckScriptUpdate { get; set; }

    
/ </summary>
    bool IsEnableScript { get; set; }

    
/ </summary>
    IReadOnlyCollection<string>? SupportProxyServicesStatus { get; set; }

    
/ </summary>
    IReadOnlyCollection<int>? ScriptsStatus { get; set; }

    #region 代理设置

    
/ </summary>
    bool ProgramStartupRunProxy { get; set; }

    
/ </summary>
    ushort SystemProxyPortId { get; set; }

    
/ </summary>
    string? SystemProxyIp { get; set; }

    
/ </summary>
    bool OnlyEnableProxyScript { get; set; }

    
/ </summary>
    string? ProxyMasterDns { get; set; }

    
/ </summary>
    bool EnableHttpProxyToHttps { get; set; }

    #endregion

    #region 本地代理设置

    
/ </summary>
    bool Socks5ProxyEnable { get; set; }

    
/ </summary>
    ushort Socks5ProxyPortId { get; set; }

    #endregion

    #region 二级代理设置

    
/ </summary>
    bool TwoLevelAgentEnable { get; set; }

    
/ </summary>
    ExternalProxyType TwoLevelAgentProxyType { get; set; }

    
/ </summary>
    string? TwoLevelAgentIp { get; set; }

    
/ </summary>
    ushort TwoLevelAgentPortId { get; set; }

    
/ </summary>
    string? TwoLevelAgentUserName { get; set; }

    
/ </summary>
    string? TwoLevelAgentPassword { get; set; }

    #endregion

    #region 代理模式设置

    
/ </summary>
    ProxyMode ProxyMode { get; set; }

    #endregion

#if (WINDOWS || MACCATALYST || MACOS || LINUX) && !(IOS || ANDROID)

    
/ </summary>
    bool IsProxyGOG { get; set; }

    
/ </summary>
    bool IsOnlyWorkSteamBrowser { get; set; }

#endif

    
/ </summary>
    bool UseDoh { get; set; }

    
/ </summary>
    string? CustomDohAddres2 { get; set; }

    
/ </summary>
    int AcceleratorTabsSelectedIndex { get; set; }

    
/ </summary>
    bool AutoShowWattAcceleratorWindow { get; set; }

    
/ </summary>
    bool ProxyBeforeDNSCheck { get; set; }

    
/ </summary>
    const bool DefaultIsAutoCheckScriptUpdate = true;

    
/ </summary>
    const bool DefaultIsEnableScript = false;

    
/ </summary>
    static readonly IReadOnlyCollection<string> DefaultSupportProxyServicesStatus = Array.Empty<string>();

    
/ </summary>
    static readonly IReadOnlyCollection<int> DefaultScriptsStatus = Array.Empty<int>();

    
/ </summary>
    const bool DefaultProgramStartupRunProxy = false;

    
/ </summary>
    const ushort DefaultSystemProxyPortId = 26561;

    
/ </summary>
    static readonly string DefaultSystemProxyIp = IPAddress.Any.ToString();

    
/ </summary>
    const bool DefaultOnlyEnableProxyScript = false;

    
/ </summary>
    const string DefaultProxyMasterDns = "223.5.5.5";

    
/ </summary>
    const bool DefaultEnableHttpProxyToHttps = true;

    
/ </summary>
    const bool DefaultSocks5ProxyEnable = false;

    
/ </summary>
    const ushort DefaultSocks5ProxyPortId = 8868;

    
/ </summary>
    const bool DefaultTwoLevelAgentEnable = false;

    
/ </summary>
    const ExternalProxyType DefaultTwoLevelAgentProxyType = IReverseProxyService.Constants.DefaultTwoLevelAgentProxyType;

    
/ </summary>
    static readonly string DefaultTwoLevelAgentIp = IPAddress.Loopback.ToString();

    
/ </summary>
    const ushort DefaultTwoLevelAgentPortId = 7890;

    
/ </summary>
    const string? DefaultTwoLevelAgentUserName = null;

    
/ </summary>
    const string? DefaultTwoLevelAgentPassword = null;

    
/ </summary>
    static readonly ProxyMode DefaultProxyMode = Enums.ProxyMode.Hosts;

    
/ </summary>
    const bool DefaultIsProxyGOG = false;

    
/ </summary>
    const bool DefaultIsOnlyWorkSteamBrowser = false;

    
/ </summary>
    const bool DefaultUseDoh = true;

    
/ </summary>
    const string? DefaultCustomDohAddres2 = null;

    
/ </summary>
    static readonly int DefaultAcceleratorTabsSelectedIndex = 0;

    
/ </summary>
    const bool DefaultAutoShowWattAcceleratorWindow = true;

    
/ </summary>
    const bool DefaultProxyBeforeDNSCheck = true;

}

发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\UI\ViewModels\AcceleratorPageViewModel.cs
LINUX
LINUX
LINUX
LINUX
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\UI\ViewModels\NetworkCheckControlViewModel.cs
/]+\.[^/]{2,}$";

        public override string FormatErrorMessage(string name) => "请填入不带分隔符 \"/\" 的域名";

        public DomainValidationAttribute() : base(RegPattern)
        {
        }
    }

    private readonly INetworkTestService _networkTestService = INetworkTestService.Instance;

    public record NATFetchResult(string PublicEndPoint, string LocalEndPoint, string NATLevel, string NATTypeTip, bool PingResult);

    public string DefaultTestDomain { get; } = "store.steampowered.com";

    [Reactive]
    public string SelectedSTUNAddress { get; set; }

    public string[] STUNAddress { get; } =
    [
        "stun.syncthing.net",
        "stun.hot-chilli.net",
        "stun.fitauto.ru",
        "stun.miwifi.com",
    ];

    [ObservableAsProperty]
    public string NATLevel { get; } = string.Empty;

    [ObservableAsProperty]
    public string NATTypeTip { get; } = string.Empty;

    [ObservableAsProperty]
    public string LocalEndPoint { get; } = string.Empty;

    [ObservableAsProperty]
    public string PublicEndPoint { get; } = string.Empty;

    [ObservableAsProperty]
    public bool PingOkVisible { get; }

    [ObservableAsProperty]
    public bool PingErrorVisible { get; }

    [ObservableAsProperty]
    public bool IsNATChecking { get; }

    [ObservableAsProperty]
    public bool IsDNSChecking { get; }

    [ObservableAsProperty]
    public bool IsIPv6Checking { get; }

    [DomainValidation]
    [Reactive]
    public string DomainPendingTest { get; set; } = string.Empty;

    [Reactive]
    public string DNSTestDelay { get; set; } = string.Empty;

    [Reactive]
    public string DNSTestResult { get; set; } = string.Empty;

    [Reactive]
    public string IPv6Address { get; set; } = string.Empty;

    [Reactive]
    public bool IsSupportIPv6 { get; set; }

    public ReactiveCommand<Unit, NATFetchResult> NATCheckCommand { get; }

    public ReactiveCommand<Unit, Unit> DNSCheckCommand { get; }

    public ReactiveCommand<Unit, Unit> IPv6CheckCommand { get; }

    public NetworkCheckControlViewModel()
    {
        SelectedSTUNAddress = STUNAddress[0];

        NATCheckCommand = ReactiveCommand.CreateFromTask(async () =>
        {
            var natCheckResult = await _networkTestService.TestStunClient3489Async(testServerHostName: SelectedSTUNAddress) ?? new ClassicStunResult { NatType = NatType.Unknown };
            var (netSucc, _) = await _networkTestService.TestOpenUrlAsync("https:
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\UI\ViewModels\GameAccelerator\GameAcceleratorViewModel.cs
/ </summary>
public sealed partial class GameAcceleratorViewModel
{
    
/ Initializes a new instance of the <see cref="GameAcceleratorViewModel"/> class.
    
/ </summary>
    public GameAcceleratorViewModel()
    {
        GameAcceleratorService.Current.Games
            .Connect()
            .Sort(new LastAccelerateTimeComparer())
            .ObserveOn(RxApp.MainThreadScheduler)
            .Bind(out _Games)
            .Subscribe();

        GameAcceleratorCommand = ReactiveCommand.Create<XunYouGameViewModel>(app =>
        {
            app.IsAccelerated = !app.IsAccelerated;
        });
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\UI\ViewModels\GameAccelerator\GameAcceleratorViewModel.props.cs
/ </summary>
    private readonly ReadOnlyObservableCollection<XunYouGameViewModel>? _Games;

    public ReadOnlyObservableCollection<XunYouGameViewModel>? Games => _Games;

    
/ 游戏加速点击 <see cref="ICommand"/>
    
/ </summary>
    public ICommand GameAcceleratorCommand { get; }

    [Reactive]
    public string? SearchText { get; set; }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\UI\Views\Controls\GameAccelerator.axaml.cs
/ </summary>
public partial class GameAccelerator : ReactiveUserControl<GameAcceleratorViewModel>
{
    
/ Defines the <see cref="ItemsPerPage"/> property.
    
/ </summary>
    public static readonly StyledProperty<int> ItemsPerPageProperty =
        AvaloniaProperty.Register<CarouselItems, int>(nameof(ItemsPerPage), 4);

    
/ </summary>
    public int ItemsPerPage
    {
        get => GetValue(ItemsPerPageProperty);
        set => SetValue(ItemsPerPageProperty, value);
    }

    
/ Initializes a new instance of the <see cref="GameAccelerator"/> class.
    
/ </summary>
    public GameAccelerator()
    {
        InitializeComponent();
        DataContext = new GameAcceleratorViewModel();

        SearchGameBox.SelectionChanged += SearchGameBox_SelectionChanged;
    }

    private void SearchGameBox_SelectionChanged(object? sender, SelectionChangedEventArgs e)
    {
        if (SearchGameBox.SelectedItem is XunYouGame xunYouGame && xunYouGame is not null)
        {
            GameAcceleratorService.AddMyGame(xunYouGame);
            SearchGameBox.Text = null;
        }
    }

    protected override void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change)
    {
        base.OnPropertyChanged(change);

        if (change.Property == ItemsPerPageProperty)
        {
            GameCarousel.ItemsPerPage = ItemsPerPage;
        }
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\UI\Views\Controls\GameAppItem.axaml.cs
/update.xunyou.com/gamelogo2014/26276.ico",
                LogoUrl = "https:
/image.xunyou.com/images/client/7/logo/26276.png",
                LogoMD5 = "https:
/www.xunyou.com/client/7/cover/26276.json",
                PicUrl = "https:
/image.xunyou.com/images/client/7/cover/26276.png",
                PicMD5 = "https:
/www.xunyou.com/client/7/logo/26276.json",
            },
            IsAccelerated = false,
            LastAccelerateTime = DateTime.Now.AddHours(-12),
            SelectedArea = new XunYouGameArea { Id = 1 },
            SelectedServer = new XunYouGameServer { Id = 2 },
        };

        Design.SetDataContext(this, data);
#endif
    }
}

发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\UI\Views\Controls\GameAppItem.axaml.cs
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\UI\Views\Controls\GameDetail.axaml.cs
/update.xunyou.com/gamelogo2014/26276.ico",
                LogoUrl = "https:
/image.xunyou.com/images/client/7/logo/26276.png",
                LogoMD5 = "https:
/www.xunyou.com/client/7/cover/26276.json",
                PicUrl = "https:
/image.xunyou.com/images/client/7/cover/26276.png",
                PicMD5 = "https:
/www.xunyou.com/client/7/logo/26276.json",
            },
            IsAccelerated = true,
            LastAccelerateTime = DateTime.Now.AddHours(-12),
            SelectedArea = new XunYouGameArea { Id = 1 },
            SelectedServer = new XunYouGameServer { Id = 2 },
        };

        Design.SetDataContext(this, data);
        this.Content = data;
#endif
    }
}

发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\UI\Views\Controls\GameDetail.axaml.cs
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\UI\Views\Controls\ProxyChartView.axaml.cs
/Stroke = LiveChartsSkiaSharp.DefaultPaint,
        Name = Strings.Upload,
        YToolTipLabelFormatter = (e) => $"{IOPath.GetDisplayFileSizeString(e.Coordinate.PrimaryValue)}/s",
        Mapping = (rate, point) =>
        {
            return new(rate.Timestamp, rate.Rate);
            
/Stroke = LiveChartsSkiaSharp.DefaultPaint,
        YToolTipLabelFormatter = (e) => $"{IOPath.GetDisplayFileSizeString(e.Coordinate.PrimaryValue)}/s",
        Mapping = (rate, point) =>
        {
            return new(rate.Timestamp, rate.Rate);
            
/point.SecondaryValue = rate.Timestamp;
        }
    };

    private readonly ObservableCollection<RateTick> writes = new();
    private readonly ObservableCollection<RateTick> reads = new();

    public Func<double, string> XFormatter { get; } = timestamp => ((long)timestamp).ToDateTimeS().ToString("HH:mm:ss");

    public Func<double, string> YFormatter { get; } = value => $"{IOPath.GetDisplayFileSizeString(value)}/s";

    CancellationTokenSource cancellation = new();

    public static readonly AvaloniaProperty<IEnumerable<ISeries>> SeriesProperty =
        AvaloniaProperty.Register<CartesianChart, IEnumerable<ISeries>>("Series", Enumerable.Empty<ISeries>(), inherits: true);

    public ObservableCollection<ISeries> Series
    {
        get
        {
            return (ObservableCollection<ISeries>)GetValue(SeriesProperty);
        }

        set
        {
            SetValue(SeriesProperty, value);
        }
    }

    public ProxyChartView()
    {
        InitializeComponent();

        this.readSeries.Values = reads;
        this.writeSeries.Values = writes;
        Series = [readSeries, writeSeries];

        if (Chart != null)
        {
            
/github.com/beto-rodriguez/LiveCharts2/issues/1080#issuecomment-1601536016
    
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\UI\Views\Pages\AcceleratorPage2.axaml.cs
/ </summary>
public partial class AcceleratorPage2 : PageBase<AcceleratorPageViewModel>
{
    readonly Dictionary<string, string[]> dictPinYinArray = new();

    List<int> acceleratorTabsSelectedIndexs = new();

    
/ Initializes a new instance of the <see cref="AcceleratorPage2"/> class.
    
/ </summary>
    public AcceleratorPage2()
    {
        
/ <inheritdoc/>
    
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Enums\XunYouAccelStateEx.cs
/ <para>10.接口 xunyou_accel_state_ex</para>

/ </summary>
public enum XunYouAccelStateEx
{
    
/ </summary>
    获取失败 = -1,

    
/ </summary>
    未加速 = 0,

    
/ </summary>
    已加速 = 1,

    
/ </summary>
    启动加速中 = 2,

    
/ </summary>
    停止加速中 = 3,

    
/ </summary>
    加速已断开 = 4,

    
/ </summary>
    加速失败 = 5,
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Enums\XunYouDownLoadCode.cs
/ <para>1.接口 xunyou_install</para>

/ </summary>
public enum XunYouDownLoadCode
{
    
/ <item>迅游正在运行，并弹出迅游的客户端界面。</item>
    
/ <item>迅游未运行，但专版已经安装，直接运行专版迅游进行加速。</item>
    
/ <item>下载专版安装包成功。</item>
    
/ </list>
    
/ </summary>
    安装成功 = 101,

    
/ <item>场景一：如果专版正在下载，若再次下载返回该值。</item>
    
/ <item>场景二：下载专版安装包失败。</item>
    
/ </list>
    
/ </summary>
    下载失败 = 102,

    
/ </summary>
    执行安装程序失败 = 103,

    
/ </summary>
    新建下载内存空间失败 = 104,

    
/ </summary>
    创建Http流失败 = 201,

    
/ </summary>
    获取专版迅游的下载地址失败 = 202,

    
/ </summary>
    下载地址解析错误 = 203,

    
/ </summary>
    启动安装程序失败 = 300,
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Enums\XunYouGameOperatorId.cs
/ </summary>
public enum XunYouGameOperatorId
{
    未知类型 = 0,

    STEAM = 10001,

    ORIGIN = 10002,

    BATTLE_NET = 66,

    XBOX_ONE = 11006,

    PS = 11002,

    SWITCH = 11007,

    STEAM_DECK = 11093,

    EPIC = 718,

    UPLAY = 1683,

    GOG = 811,

    微软商店 = 753,
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Enums\XunYouIsRunningCode.cs
/ <para>19.接口 xunyou_is_running</para>

/ </summary>
public enum XunYouIsRunningCode
{
    加速器已启动 = 0,

    加速器未启动 = -1,
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Enums\XunYouSendResultCode.cs
/ </summary>
public enum XunYouSendResultCode
{
    
/ </summary>
    发送失败 = -1,

    
/ </summary>
    发送成功 = 0,
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Enums\XunYouShowCommands.cs
/learn.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-showwindow</para>

/ </summary>
public enum XunYouShowCommands
{
    
/ </summary>
    SW_HIDE = 0,

    
/ </summary>
    SW_SHOWNORMAL = 1,

    SW_SHOWMINIMIZED = 2,

    SW_SHOWMAXIMIZED = 3,

    SW_SHOWNOACTIVATE = 4,

    SW_SHOW = 5,

    SW_MINIMIZE = 6,

    SW_SHOWMINNOACTIVE = 7,

    SW_SHOWNA = 8,

    SW_RESTORE = 9,

    SW_SHOWDEFAULT = 10,

    SW_FORCEMINIMIZE = 11,
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Enums\XunYouSpeedNotifyState.cs
/ <para>7.接口 xunyou_testspeed</para>

/ </summary>
public enum XunYouSpeedNotifyState
{
    
/ </summary>
    TEST_INIT = 1,

    
/ </summary>
    TEST = 2,

    
/ </summary>
    Test_FAILED = 3,
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Enums\XunYouStartGameCode.cs
/ <para>23.接口 xunyou_start_game</para>

/ </summary>
public enum XunYouStartGameCode
{
    
/ </summary>
    失败 = -1,

    
/ </summary>
    成功 = 0,
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Enums\XunYouState.cs
/ <para>17.接口 xunyou_accel_state_ex2</para>

/ </summary>
public enum XunYouState
{
    更新中 = 100,
    更新失败 = 101,
    更新成功 = 102,
    启动中 = 200,
    启动失败 = 201,
    启动成功 = 202,
    退出 = 203,
    登录中 = 300,
    登录成功 = 301,
    登录失败 = 302,
    退出登录 = 303,
    未加速 = 400,
    加速中 = 401,
    加速已完成 = 402,
    停止加速中 = 403,
    加速已断开 = 404,
    加速失败 = 405,
    启动游戏失败 = 406,
    启动游戏成功 = 407,
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Enums\XunYouTestSpeedCode.cs
/ <para>7.接口 xunyou_testspeed</para>

/ </summary>
public enum XunYouTestSpeedCode
{
    
/ </summary>
    失败 = -1,

    
/ </summary>
    成功 = 0,
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Enums\XunYouUninstallCode.cs
/ <para>11.接口 xunyou_uninstall</para>

/ </summary>
public enum XunYouUninstallCode
{
    
/ </summary>
    卸载失败 = -1,

    
/ </summary>
    卸载成功 = 0,
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Methods\1.接口 xunyou_install.cs
/ </summary>
    
/ <param name="par">若 par 小于等于 100 表示安装进度，若 par 大于 100 表示异步安装中返回的状态值，参见 1.4.2 返回值说明。</param>
    
/ <param name="thisptr">用户自定义，回调参数指针</param>
    
/ <returns>返回值为 0 即可。</returns>
    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    public delegate int XunYouDownLoadCallback(int par, nint thisptr);

    static XunYouDownLoadCallback? globalXunYouDownLoadCallback_xunyou_install;

    
/ </summary>
    
/ <param name="callback">迅游启动进度(包含下载和加速，无安装)</param>
    
/ <param name="ptr">保存回调函数的返回参数可以为传默认值</param>
    
/ <param name="installPath">迅游加速器安装路径，不指定，则默认安装在 xunyoucall.dll 所在目录</param>
    
/ <param name="installPackPath">迅游加速器安装包下载文件夹路径，不指定，则默认下载在xunyoucall.dll所在目录</param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int Install(XunYouDownLoadCallback? callback = null,
        nint ptr = default,
        string? installPath = null,
        string? installPackPath = null)
    {
        int result;
        unsafe
        {
            var xunyou_callback = callback is null ? null : (delegate* unmanaged[Stdcall]<int, nint, int>)
                Marshal.GetFunctionPointerForDelegate(globalXunYouDownLoadCallback_xunyou_install = callback);
            result = xunyou_install_ex(appId, xunyou_callback, ptr,
                installPackPath, installPackPath?.Length ?? 0,
                installPath, installPath?.Length ?? 0);
        }
        return result;
    }

    [LibraryImport(libraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvStdcall)])]
    private static unsafe partial int xunyou_install_ex(int id,
        delegate* unmanaged[Stdcall]<int, nint, int> callback = null,
        nint ptr = default,
        [MarshalAs(UnmanagedType.LPStr)] string? installpack_path = default,
        int installpack_path_len = 0,
        [MarshalAs(UnmanagedType.LPStr)] string? install_path = default,
        int install_path_len = 0);
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Methods\10.接口 xunyou_accel_state_ex.cs
/ </summary>
    
/ <param name="gameid">当前加速的游戏 id。</param>
    
/ <param name="areaid">当前加速的游戏区 id。</param>
    
/ <param name="serverid">当前加速游戏的服 id，没有则为 0。</param>
    
/ <returns></returns>
    public static XunYouAccelStateEx GetAccelStateEx(out int gameid,
        out int areaid,
        out int serverid)
    {
        var result = xunyou_accel_state_ex(appId, out gameid, out areaid, out serverid);
        return (XunYouAccelStateEx)result;
    }

    
/ </summary>
    
/ <param name="id">合作 id，由迅游给出明确值</param>
    
/ <param name="gameid">当前加速的游戏 id。</param>
    
/ <param name="areaid">当前加速的游戏区 id。</param>
    
/ <param name="serverid">当前加速游戏的服 id，没有则为 0。</param>
    
/ <returns></returns>
    [LibraryImport(libraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvStdcall)])]
    private static partial int xunyou_accel_state_ex(
        int id,
        out int gameid,
        out int areaid,
        out int serverid);
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Methods\11.接口 xunyou_uninstall.cs
/ </summary>
    
/ <param name="id">合作id，由迅游给出明确值。</param>
    
/ <returns>0 卸载成功, -1 卸载失败</returns>
    [LibraryImport(libraryName, EntryPoint = "xunyou_uninstall")]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvStdcall)])]
    public static partial XunYouUninstallCode Uninstall(int id = appId);
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Methods\12.接口 xunyou_start_ex2.cs
/ <item>此接口支持自动登录，对指定启动游戏，并对传入的游戏分区进行加速（OpenId）。</item>
    
/ <item>如果没有安装迅游，则先下载并安装，然后启动迅游或启动加速。</item>
    
/ <item>如果 xunyou_callback 为空，则该接口走同步的方式；</item>
    
/ <item>如果 xunyou_callback 不为空，则该接口走异步的方式。</item>
    
/ <item>异步启动是直接启动线程操作，返回值在回调函数里面调用；</item>
    
/ <item>同步是直接返回相关结果。异步回调的方式会返回一个系统默认值 1。</item>
    
/ </list>
    
/ </summary>
    
/ <param name="openid">登录 token，由调用方提供</param>
    
/ <param name="nickname">账号昵称</param>
    
/ <param name="show"><see cref="PInvoke.User32.WindowStyles"/></param>
    
/ <param name="gameid">游戏 id，由迅游给出明确值，或传 0，如果传 0，表示只启动迅游，不自动加速。</param>
    
/ <param name="area">游戏分区 id ，由游戏给出区服名和 id 对照表，或传 0，如果传 0，表示只启动迅游，不自动加速。</param>
    
/ <param name="server">游戏服 id</param>
    
/ <param name="callback"></param>
    
/ <param name="ptr"></param>
    
/ <param name="installPath">迅游加速器安装路径，不指定，则默认安装在 xunyoucall.dll 所在目录</param>
    
/ <param name="areaName">游戏区名</param>
    
/ <param name="svrName">游戏服名</param>
    
/ <returns></returns>
    public static int StartEx2(
        string openid,
        string nickname,
        XunYouShowCommands show = XunYouShowCommands.SW_HIDE,
        int gameid = 0,
        int area = 0,
        int server = 0,
        XunYouDownLoadCallback? callback = null,
        nint ptr = default,
        string? installPath = default,
        string? areaName = default,
        string? svrName = default)
    {
        int result;
        unsafe
        {
            var xunyou_callback = callback is null ? null :
                (delegate* unmanaged[Stdcall]<int, nint, int>)Marshal.GetFunctionPointerForDelegate(
                    globalXunYouDownLoadCallback_xunyou_start_ex2 = callback);
            int install_path_len = installPath?.Length ?? 0;
            int area_name_len = areaName?.Length ?? 0;
            int svr_name_len = svrName?.Length ?? 0;
            int openid_len = openid?.Length ?? 0;
            int nickname_len = openid?.Length ?? 0;

            result = xunyou_start_ex2(appId, openid, openid_len,
                userType, channel_no, channel_no.Length,
                nickname, nickname_len, show,
                gameid,
                area, server, xunyou_callback, ptr,
                installPath, install_path_len, areaName,
                area_name_len, svrName, svr_name_len);
        }
        return result;
    }

    [LibraryImport(libraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvStdcall)])]
    private static unsafe partial int xunyou_start_ex2(
        int id,
        [MarshalAs(UnmanagedType.LPStr)] string? openid,
        int openid_len,
        int user_type,
        [MarshalAs(UnmanagedType.LPStr)] string? channel_no,
        int channel_no_len,
        [MarshalAs(UnmanagedType.LPUTF8Str)] string? nickname,
        int nickname_len,
        XunYouShowCommands show = XunYouShowCommands.SW_HIDE,
        int gameid = 0,
        int area = 0,
        int server = 0,
        delegate* unmanaged[Stdcall]<int, nint, int> callback = null,
        nint ptr = default,
        [MarshalAs(UnmanagedType.LPStr)] string? install_path = default,
        int install_path_len = 0,
        [MarshalAs(UnmanagedType.LPStr)] string? area_name = default,
        int area_name_len = 0,
        [MarshalAs(UnmanagedType.LPStr)] string? svr_name = default,
        int svr_name_len = 0);
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Methods\13.接口 xunyou_get_all_games.cs
/ </summary>
    
/ <returns></returns>
    public static XunYouGame[]? GetAllGames()
    {
        try
        {
            unsafe
            {
                int gamelist_size = 0;
                var result = xunyou_get_all_games(default, ref gamelist_size);
                if (result == 0)
                {
                    Span<byte> gamelist = new byte[gamelist_size];
                    fixed (byte* gamelist_intptr = gamelist)
                    {
                        result = xunyou_get_all_games(gamelist_intptr, ref gamelist_size);
                        if (result == 0) 
/ </summary>
    
/ <param name="gamelist">支持加速的所有游戏列表，为空则 gamelist_size 会返回所需的空间大小。</param>
    
/ <param name="gamelist_size">sizeof(gamelist)</param>
    
/ <returns></returns>
    [LibraryImport(libraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvStdcall)])]
    private static unsafe partial int xunyou_get_all_games(byte* gamelist,
        ref int gamelist_size);
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Methods\14.接口 xunyou_get_hot_games.cs
/ </summary>
    
/ <returns></returns>
    public static XunYouGame[]? GetHotGames()
    {
        try
        {
            unsafe
            {
                int gamelist_size = 0;
                var result = xunyou_get_hot_games(default, ref gamelist_size);
                if (result == 0)
                {
                    Span<byte> gamelist = new byte[gamelist_size];
                    fixed (byte* gamelist_intptr = gamelist)
                    {
                        result = xunyou_get_hot_games(gamelist_intptr, ref gamelist_size);
                        if (result == 0) 
/ </summary>
    
/ <param name="gamelist">支持加速的热门游戏列表，为空则 gamelist_size 会返回所需的空间大小。</param>
    
/ <param name="gamelist_size">sizeof(gamelist)</param>
    
/ <returns></returns>
    [LibraryImport(libraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvStdcall)])]
    private static unsafe partial int xunyou_get_hot_games(byte* gamelist,
        ref int gamelist_size);
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Methods\15.接口 xunyou_get_gameinfo.cs
/ </summary>
    
/ <param name="gameId">迅游对应的游戏 Id</param>
    
/ <returns></returns>
    public static XunYouGameInfo? GetGameInfo(int gameId)
    {
        try
        {
            unsafe
            {
                int gamelist_size = 0;
                var result = xunyou_get_gameinfo(gameId, default, ref gamelist_size);
                if (result == 0)
                {
                    Span<byte> gamelist = new byte[gamelist_size];
                    fixed (byte* gamelist_intptr = gamelist)
                    {
                        result = xunyou_get_gameinfo(gameId, gamelist_intptr, ref gamelist_size);
                        if (result == 0) 
/ </summary>
    
/ <param name="game_id">迅游对应的游戏 Id/param>
    
/ <param name="gamelist">游戏 Id 对应的游戏信息，为空则 gameinfo_size 会返回所需的空间大小，该指针的生命周期由调用方维护。</param>
    
/ <param name="gamelist_size">sizeof(gamelist)</param>
    
/ <returns></returns>
    [LibraryImport(libraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvStdcall)])]
    private static unsafe partial int xunyou_get_gameinfo(int game_id, byte* gameinfo,
        ref int gameinfo_size);
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Methods\16.接口 xunyou_stop_accel.cs
/ </summary>
    
/ <returns></returns>
    public static XunYouSendResultCode Stop()
    {
        int result;
        unsafe
        {
            result = xunyou_stop_accel(appId);
        }
        return (XunYouSendResultCode)result;
    }

    
/ </summary>
    
/ <param name="id">合作 id，由迅游给出明确值</param>
    
/ <returns></returns>
    [LibraryImport(libraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvStdcall)])]
    private static unsafe partial int xunyou_stop_accel(int id);
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Methods\17.接口 xunyou_accel_state_ex2.cs
/ </summary>
    
/ <param name="status">迅游加速状态</param>
    
/ <param name="thisptr">用户自定义，回调参数指针，该指针的生命周期由调用方维护</param>
    
/ <returns>返回值为 0 即可。</returns>
    [UnmanagedFunctionPointer(CallingConvention.StdCall)]
    public delegate int XunYouStateCallback(XunYouState status, nint thisptr);

    static XunYouStateCallback? globalXunYouStateCallback;

    
/ </summary>
    
/ <param name="callback">加速结果回调</param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static XunYouAccelStateEx GetState(XunYouStateCallback callback)
    {
        int result;
        unsafe
        {
            var xunyou_callback = (delegate* unmanaged[Stdcall]<int, nint, int>)Marshal.GetFunctionPointerForDelegate(globalXunYouStateCallback = callback);
            result = xunyou_status(appId, default, xunyou_callback);
        }
        return (XunYouAccelStateEx)result;
    }

    
/ </summary>
    
/ <param name="id">合作 id，由迅游给出明确值。</param>
    
/ <param name="ptr">用户自定义，回调参数指针，该指针的生命周期由调用方维护</param>
    
/ <param name="callback">加速结果回调</param>
    
/ <returns></returns>
    [LibraryImport(libraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvStdcall)])]
    private static unsafe partial int xunyou_status(
        int id,
        nint ptr,
        delegate* unmanaged[Stdcall]<int, nint, int> callback);
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Methods\18.接口 xunyou_start_accel.cs
/ </summary>
    
/ <param name="gameid">游戏 Id</param>
    
/ <param name="area">区 Id</param>
    
/ <param name="areaName">游戏区名</param>
    
/ <param name="server">服 Id</param>
    
/ <param name="svrName">游戏服名</param>
    
/ <returns></returns>
    public static XunYouSendResultCode StartAccel(
        int gameid,
        int area,
        string? areaName,
        int server,
        string? svrName)
    {
        int result;
        unsafe
        {
            int area_name_len = areaName?.Length ?? 0;
            int svr_name_len = svrName?.Length ?? 0;

            result = xunyou_start_accel(appId, gameid,
                area, areaName, area_name_len,
                server, svrName, svr_name_len);
        }
        return (XunYouSendResultCode)result;
    }

    [LibraryImport(libraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvStdcall)])]
    private static unsafe partial int xunyou_start_accel(
        int id,
        int gameid = 0,
        int area = 0,
        [MarshalAs(UnmanagedType.LPStr)] string? area_name = default,
        int area_name_len = 0,
        int server = 0,
        [MarshalAs(UnmanagedType.LPStr)] string? svr_name = default,
        int svr_name_len = 0);
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Methods\19.接口 xunyou_is_running.cs
/ </summary>
    
/ <param name="id">合作id，由迅游给出明确值。</param>
    
/ <returns>0 已启动, -1 未启动</returns>
    [LibraryImport(libraryName, EntryPoint = "xunyou_is_running")]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvStdcall)])]
    public static partial XunYouIsRunningCode IsRunning(int id = appId);
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Methods\2.接口 xunyou_is_install.cs
/ </summary>
    
/ <param name="id">合作 id，由迅游给出明确值</param>
    
/ <returns></returns>
    [LibraryImport(libraryName, EntryPoint = "xunyou_is_install")]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvStdcall)])]
    [return: MarshalAs(UnmanagedType.U1)] 
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Methods\20.接口 xunyou_testspeed_ex.cs
/ </summary>
    
/ <param name="gameid">游戏 id，由迅游给出明确值。</param>
    
/ <param name="area">游戏分区 id ，由游戏给出区服名和 id 对照表。</param>
    
/ <param name="server">游戏服ID</param>
    
/ <param name="callback">测速回调函数。</param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static XunYouTestSpeedCode TestSpeed(int gameid,
        int area,
        int server,
        TestSpeedCallback callback)
    {
        int testSpeedCode = int.MinValue;
        unsafe
        {
            [UnmanagedCallConv(CallConvs = [typeof(CallConvStdcall)])]
            int TestSpeedCallback_Wrapper(XunYouSpeedNotifyState state, SpeedCallbackInfo* info)
            {
                var info_ = Marshal.PtrToStructure<SpeedCallbackInfo>((nint)info);
                var result = callback(new SpeedCallbackWrapper
                {
                    Struct = info_,
                    State = state,
                    Code = (XunYouTestSpeedCode)testSpeedCode,
                    ErrorDesc = info_.GetErrorDescString(),
                });
                return result;
            }
            var xunyou_callback = (delegate* unmanaged[Stdcall]<XunYouSpeedNotifyState, SpeedCallbackInfo*, int>)Marshal.GetFunctionPointerForDelegate(testSpeedCallback = TestSpeedCallback_Wrapper);
            testSpeedCode = xunyou_testspeed_ex(gameid, area, server, xunyou_callback);
        }

        return (XunYouTestSpeedCode)testSpeedCode;
    }

    [LibraryImport(libraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvStdcall)])]
    private static unsafe partial int xunyou_testspeed_ex(int gameid,
        int area,
        int server,
        delegate* unmanaged[Stdcall]<XunYouSpeedNotifyState, SpeedCallbackInfo*, int> callback = null);
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Methods\22.接口 xunyou_start_ex3.cs
/ <item>此接口支持自动登录，对指定启动游戏，并对传入的游戏分区进行加速（Jwt）。</item>
    
/ <item>如果没有安装迅游，则先下载并安装，然后启动迅游或启动加速。</item>
    
/ <item>如果 xunyou_callback 为空，则该接口走同步的方式；</item>
    
/ <item>如果 xunyou_callback 不为空，则该接口走异步的方式。</item>
    
/ <item>异步启动是直接启动线程操作，返回值在回调函数里面调用；</item>
    
/ <item>同步是直接返回相关结果。异步回调的方式会返回一个系统默认值 1。</item>
    
/ </list>
    
/ </summary>
    
/ <param name="jwt">登录 token，由调用方提供</param>
    
/ <param name="nickname">账号昵称</param>
    
/ <param name="show"><see cref="PInvoke.User32.WindowStyles"/></param>
    
/ <param name="gameid">游戏 id，由迅游给出明确值，或传 0，如果传 0，表示只启动迅游，不自动加速。</param>
    
/ <param name="area">游戏分区 id ，由游戏给出区服名和 id 对照表，或传 0，如果传 0，表示只启动迅游，不自动加速。</param>
    
/ <param name="server">游戏服 id</param>
    
/ <param name="callback"></param>
    
/ <param name="ptr"></param>
    
/ <param name="installPath">迅游加速器安装路径，不指定，则默认安装在 xunyoucall.dll 所在目录</param>
    
/ <param name="areaName">游戏区名</param>
    
/ <param name="svrName">游戏服名</param>
    
/ <returns></returns>
    public static int StartEx3(
        string jwt,
        string nickname,
        XunYouShowCommands show = XunYouShowCommands.SW_HIDE,
        int gameid = 0,
        int area = 0,
        int server = 0,
        XunYouDownLoadCallback? callback = null,
        nint ptr = default,
        string? installPath = default,
        string? areaName = default,
        string? svrName = default)
    {
        int result;
        unsafe
        {
            var xunyou_callback = callback is null ? null :
                (delegate* unmanaged[Stdcall]<int, nint, int>)Marshal.GetFunctionPointerForDelegate(
                    globalXunYouDownLoadCallback_xunyou_start_ex2 = callback);
            int install_path_len = installPath?.Length ?? 0;
            int area_name_len = areaName?.Length ?? 0;
            int svr_name_len = svrName?.Length ?? 0;
            int jwt_len = jwt?.Length ?? 0;
            int nickname_len = jwt?.Length ?? 0;

            result = xunyou_start_ex2(appId, jwt, jwt_len,
                userType, channel_no, channel_no.Length,
                nickname, nickname_len, show,
                gameid,
                area, server, xunyou_callback, ptr,
                installPath, install_path_len, areaName,
                area_name_len, svrName, svr_name_len);
        }
        return result;
    }

    [LibraryImport(libraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvStdcall)])]
    private static unsafe partial int xunyou_start_ex3(
        int id,
        [MarshalAs(UnmanagedType.LPStr)] string? jwt,
        int jwt_len,
        int user_type,
        [MarshalAs(UnmanagedType.LPStr)] string? channel_no,
        int channel_no_len,
        [MarshalAs(UnmanagedType.LPUTF8Str)] string? nickname,
        int nickname_len,
        XunYouShowCommands show = XunYouShowCommands.SW_HIDE,
        int gameid = 0,
        int area = 0,
        int server = 0,
        delegate* unmanaged[Stdcall]<int, nint, int> callback = null,
        nint ptr = default,
        [MarshalAs(UnmanagedType.LPStr)] string? install_path = default,
        int install_path_len = 0,
        [MarshalAs(UnmanagedType.LPStr)] string? area_name = default,
        int area_name_len = 0,
        [MarshalAs(UnmanagedType.LPStr)] string? svr_name = default,
        int svr_name_len = 0);
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Methods\23.接口 xunyou_start_game.cs
/ </summary>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static XunYouStartGameCode StartGame()
    {
        int result = xunyou_start_game();
        return (XunYouStartGameCode)result;
    }

    [LibraryImport(libraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvStdcall)])]
    private static unsafe partial int xunyou_start_game();
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Methods\24.接口 xunyou_get_picinfo.cs
/ </summary>
    
/ <param name="game_id">迅游对应的游戏 id</param>
    
/ <returns></returns>
    public static XunYouPicInfo? GetPicInfo(int game_id)
    {
        try
        {
            unsafe
            {
                int picinfo_size = 0;
                var result = xunyou_get_picinfo(game_id, default, ref picinfo_size);
                if (result == 0)
                {
                    Span<byte> span = new byte[picinfo_size];
                    fixed (byte* span_intptr = span)
                    {
                        result = xunyou_get_picinfo(game_id, span_intptr, ref picinfo_size);
                        if (result == 0) 
/ </summary>
    
/ <param name="game_id">迅游对应的游戏 id</param>
    
/ <param name="picinfo">游戏 id 对应的游戏信息，为空则 picinfo_size 会返回所需的空间大小</param>
    
/ <param name="picinfo_size">会返回数据的大小</param>
    
/ <returns></returns>
    [LibraryImport(libraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvStdcall)])]
    private static unsafe partial int xunyou_get_picinfo(int game_id, byte* picinfo,
        ref int picinfo_size);
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Methods\25.接口 xunyou_show.cs
/ </summary>
    
/ <param name="show">客户端显示状态(SW_HIDE)</param>
    [LibraryImport(libraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvStdcall)])]
    public static partial void xunyou_show(int show = 0);
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Methods\7.接口 xunyou_testspeed.cs
/ </summary>
    
/ <param name="m">测速回调信息</param>
    
/ <returns></returns>
    public delegate int TestSpeedCallback(SpeedCallbackWrapper m);

    
/ </summary>
    
/ <param name="gameid">游戏 id，由迅游给出明确值。</param>
    
/ <param name="area">游戏分区 id ，由游戏给出区服名和 id 对照表。</param>
    
/ <param name="callback">测速回调函数。</param>
    
/ <returns></returns>
    
/ </summary>
    
/ <param name="gameid">游戏 id，由迅游给出明确值。</param>
    
/ <param name="area">游戏分区 id ，由游戏给出区服名和 id 对照表。</param>
    
/ <returns></returns>
    
/ <exception cref="NotSupportedException"></exception>
    
/ </summary>
    
/ <param name="value"></param>
    
/ <returns></returns>
    static string? GetErrorDescString(this SpeedCallbackInfo value)
    {
        if (value.ErrorDesc == default || value.ErrorDescLen == 0 || value.ErrorDescLen > int.MaxValue)
            return null;
        var result = Marshal.PtrToStringUni(value.ErrorDesc, (int)value.ErrorDescLen);
        return result;
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Methods\8.接口 xunyou_stop_testspeded.cs
/ </summary>
    public static void StopTestSpeded()
    {
        xunyou_stop_testspeed();
    }

    
/ </summary>
    [LibraryImport(libraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvStdcall)])]
    private static partial void xunyou_stop_testspeed();
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Methods\9.接口 xunyou_get_steam_games.cs
/ </summary>
    
/ <returns></returns>
    public static XunYouSteamGame[]? GetSteamGames()
    {
        try
        {
            unsafe
            {
                int gamelist_size = 0;
                var result = xunyou_get_steam_games(default, ref gamelist_size);
                if (result == 0)
                {
                    Span<byte> gamelist = new byte[gamelist_size];
                    fixed (byte* gamelist_intptr = gamelist)
                    {
                        result = xunyou_get_steam_games(gamelist_intptr, ref gamelist_size);
                        if (result == 0) 
/ </summary>
    
/ <param name="gamelist">支持加速的 steam 游戏列表，为空则 gamelist_size 会返回所需的空间大小。</param>
    
/ <param name="gamelist_size">sizeof(gamelist)</param>
    
/ <returns></returns>
    [LibraryImport(libraryName)]
    [UnmanagedCallConv(CallConvs = [typeof(CallConvStdcall)])]
    private static unsafe partial int xunyou_get_steam_games(byte* gamelist,
        ref int gamelist_size);
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Models\SpeedCallbackInfo.cs
/ <para>7.接口 xunyou_testspeed</para>

/ </summary>
[StructLayout(LayoutKind.Sequential)]
[MP2Obj(MP2SerializeLayout.Explicit)]
public readonly partial record struct SpeedCallbackInfo
{
    
/ </summary>
    [MP2Key(0)]
    public readonly nint ErrorDesc { get; init; }

    
/ </summary>
    [MP2Key(1)]
    public readonly uint ErrorDescLen { get; init; }

    
/ </summary>
    [MP2Key(2)]
    public readonly uint ErrorCode { get; init; }

    
/ </summary>
    [MP2Key(3)]
    public readonly uint PingSpeed { get; init; }

    
/ </summary>
    [MP2Key(4)]
    public readonly uint PingLocal { get; init; }

    
/ </summary>
    [MP2Key(5)]
    public readonly float PingSpeedLoss { get; init; }

    
/ </summary>
    [MP2Key(6)]
    public readonly float PingLocalLoss { get; init; }
}


发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Models\SpeedCallbackWrapper.cs
/ <see cref="SpeedCallbackInfo"/> 的包装类，可用于传输数据

/ <para>7.接口 xunyou_testspeed</para>

/ </summary>
[MP2Obj(MP2SerializeLayout.Explicit)]
public partial record class SpeedCallbackWrapper
{
    
/ <inheritdoc cref="SpeedCallbackInfo"/>
    [MP2Key(0)]
    public SpeedCallbackInfo Struct { get; set; }

    
/ </summary>
    [MP2Key(1)]
    public string? ErrorDesc { get; set; }

    
/ <inheritdoc cref="XunYouSpeedNotifyState"/>
    [MP2Key(2)]
    public XunYouSpeedNotifyState State { get; set; }

    
/ <inheritdoc cref="XunYouTestSpeedCode"/>
    [MP2Key(3)]
    public XunYouTestSpeedCode Code { get; set; }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Models\SystemTextJsonSerializerContext_XunYouSDK.cs
/ </summary>
[JsonSerializable(typeof(xunyou_get_gamelist_result<XunYouSteamGame>))]
[JsonSerializable(typeof(xunyou_get_gamelist_result<XunYouGame>))]
[JsonSerializable(typeof(xunyou_get_gameinfo_result<XunYouGameInfo>))]
[JsonSerializable(typeof(XunYouPicInfo))]
[JsonSerializable(typeof(XunYouVipEndTimeRequest))]
[JsonSerializable(typeof(XunYouVipEndTimeResponse))]
[JsonSourceGenerationOptions(
    AllowTrailingCommas = true)]
sealed partial class SystemTextJsonSerializerContext_XunYouSDK : SystemTextJsonSerializerContext
{
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Models\XunYouGame.cs
/ <para>13.接口 xunyou_get_all_games</para>

/ <para>14.接口 xunyou_get_hot_games</para>

/ </summary>
[MP2Obj(MP2SerializeLayout.Explicit)]
public sealed partial record class XunYouGame
{
    
/ </summary>
    [JsonPropertyName("game_id")]
    [MP2Key(0)]
    public int Id { get; set; }

    
/ </summary>
    [JsonPropertyName("game_name")]
    [MP2Key(1)]
    public string? Name { get; set; }

    
/ </summary>
    [JsonPropertyName("game_icon_url")]
    [MP2Key(2)]
    public string? IconUrl { get; set; }

    
/ </summary>
    [JsonPropertyName("game_pic_url")]
    [MP2Key(3)]
    public string? PicUrl { get; set; }

    
/ 游戏图片的 <see cref="MD5"/>
    
/ </summary>
    [JsonPropertyName("game_pic_md5_url")]
    [MP2Key(4)]
    public string? PicMD5 { get; set; }

    
/ </summary>
    [JsonPropertyName("game_logo_url")]
    [MP2Key(5)]
    public string? LogoUrl { get; set; }

    
/ 游戏 Logo 图片的 <see cref="MD5"/>
    
/ </summary>
    [JsonPropertyName("game_logo_md5_url")]
    [MP2Key(6)]
    public string? LogoMD5 { get; set; }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Models\XunYouGameArea.cs
/ </summary>
[MP2Obj(MP2SerializeLayout.Explicit)]
public sealed partial record class XunYouGameArea
{
    
/ </summary>
    [JsonPropertyName("area_id")]
    [MP2Key(0)]
    public int Id { get; set; }

    
/ </summary>
    [JsonPropertyName("area_name")]
    [MP2Key(1)]
    public string? Name { get; set; }

    
/ </summary>
    [JsonPropertyName("game_server")]
    [MP2Key(2)]
    public List<XunYouGameServer>? Servers { get; set; }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Models\XunYouGameInfo.cs
/ <para>15.接口 xunyou_get_gameinfo</para>

/ </summary>
public sealed record class XunYouGameInfo
{
    
/ </summary>
    [JsonPropertyName("game_id")]
    public int Id { get; set; }

    
/ <inheritdoc cref="XunYouGameOperatorId"/>
    [JsonPropertyName("game_operator_id")]
    public XunYouGameOperatorId OperatorId { get; set; }

    
/ </summary>
    [JsonPropertyName("show_start")]
    public bool ShowStart { get; set; }

    
/ </summary>
    [JsonPropertyName("game_area")]
    public List<XunYouGameArea>? Areas { get; set; }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Models\XunYouGameServer.cs
/ </summary>
[MP2Obj(MP2SerializeLayout.Explicit)]
public sealed partial record class XunYouGameServer
{
    
/ </summary>
    [JsonPropertyName("server_id")]
    [MP2Key(0)]
    public int Id { get; set; }

    
/ </summary>
    [JsonPropertyName("server_name")]
    [MP2Key(1)]
    public string? Name { get; set; }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Models\XunYouPicInfo.cs
/ <para>24.接口 xunyou_get_picinfo</para>

/ </summary>
public sealed record class XunYouPicInfo
{
    
/ </summary>
    [JsonPropertyName("icon")]
    public XunYouPicInfoUrl? Icon { get; set; }

    
/ </summary>
    [JsonPropertyName("large")]
    public XunYouPicInfoUrl? Large { get; set; }

    
/ </summary>
    [JsonPropertyName("logo")]
    public XunYouPicInfoUrl? Logo { get; set; }

    
/ </summary>
    [JsonPropertyName("small")]
    public XunYouPicInfoUrl? Small { get; set; }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Models\XunYouPicInfoUrl.cs
/ <para>24.接口 xunyou_get_picinfo</para>

/ </summary>
public sealed record class XunYouPicInfoUrl
{
    
/ </summary>
    [JsonPropertyName("crc")]
    public string? Crc { get; set; }

    
/ </summary>
    [JsonPropertyName("url")]
    public string? Url { get; set; }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator\XunYouSDK\Models\XunYouSteamGame.cs
/ <para>9.接口 xunyou_get_steam_games</para>

/ </summary>
public sealed record class XunYouSteamGame
{
    
/ </summary>
    [JsonPropertyName("steamid")]
    public int SteamAppId { get; set; }

    
/ </summary>
    [JsonPropertyName("xunyou_gameid")]
    public int Id { get; set; }

    
/ </summary>
    [JsonPropertyName("game_name")]
    public string? Name { get; set; }

    
/ </summary>
    [JsonPropertyName("game_icon_url")]
    public string? IconUrl { get; set; }

    
/ </summary>
    [JsonPropertyName("game_pic_url")]
    public string? PicUrl { get; set; }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Program.cs
/Console.WriteLine($"This: {moduleName} / Program.Start");
var consoleTitle = $"[{Environment.ProcessId}, {IsProcessElevated_DEBUG_Only().ToLowerString()}] {Constants.CUSTOM_URL_SCHEME_NAME}({moduleName}) {string.Join(' ', Environment.GetCommandLineArgs().Skip(1))}";
SetConsoleTitle(consoleTitle);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
static void SetConsoleTitle(string title)
{
    try
    {
        Console.Title = title;
    }
    catch
    {

    }
}

[MethodImpl(MethodImplOptions.AggressiveInlining)]
static bool IsProcessElevated_DEBUG_Only()
{
    if (!OperatingSystem.IsWindows())
    {
        return false;
    }
    
/ 添加反向代理服务（子进程实现）
    services.AddReverseProxyService();
    services.AddSingleton<ICertificateManager, CertificateManagerImpl>();
}

sealed class RepositorySecureStorage : Repository<KeyValuePair, string>, ISecureStorage
{
    bool ISecureStorage.IsNativeSupportedBytes => true;

    static string GetKey(string key) => Hashs.String.SHA256(key);

    async Task<byte[]?> ISecureStorage.GetBytesAsync(string key)
    {
        key = GetKey(key);
        var item = await FirstOrDefaultAsync(x => x.Id == key);
        var value = item?.Value;
        var value2 = value;
        return value2;
    }

    async Task InsertOrUpdateAsync(string key, byte[] value)
    {
        var value2 = value;
        await InsertOrUpdateAsync(new KeyValuePair
        {
            Id = key,
            Value = value2.ThrowIsNull(nameof(value2)),
        });
    }

    Task ISecureStorage.SetAsync(string key, byte[]? value)
    {
        key = GetKey(key);
        if (value == null || value.Length <= 0)
        {
            return DeleteAsync(key);
        }
        else
        {
            return InsertOrUpdateAsync(key, value);
        }
    }

    async Task<bool> ISecureStorage.RemoveAsync(string key)
    {
        key = GetKey(key);
        var result = await DeleteAsync(key);
        return result > 0;
    }

    async Task<bool> ISecureStorage.ContainsKeyAsync(string key)
    {
        key = GetKey(key);
        var item = await FirstOrDefaultAsync(x => x.Id == key);
        return item != null;
    }
}

sealed class HttpPlatformHelperConsoleService : HttpPlatformHelperService
{
    new const string DefaultUserAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36 Edg/90.0.818.51";

    public override string UserAgent => DefaultUserAgent;
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Program.cs
DEBUG
DEBUG
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Enums\FlowType.cs
/ </summary>
public enum FlowType : byte
{
    
/ </summary>
    Read,

    
/ </summary>
    Wirte,
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Extensions\ApplicationBuilderExtensions.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.HttpServer/ApplicationBuilderExtensions.cs


/ </summary>
    
/ <param name="app"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static IApplicationBuilder UseHttpProxyPac(this IApplicationBuilder app)
    {
        var middleware = app.ApplicationServices.GetRequiredService<HttpProxyPacMiddleware>();
        return app.Use(next => context => middleware.InvokeAsync(context, next));
    }

    
/ </summary>
    
/ <param name="app"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static IApplicationBuilder UseHttpLocalRequest(this IApplicationBuilder app)
    {
        var middleware = app.ApplicationServices.GetRequiredService<HttpLocalRequestMiddleware>();
        return app.Use(next => context => middleware.InvokeAsync(context, next));
    }

    
/ </summary>
    
/ <param name="app"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static IApplicationBuilder UseRequestLogging(this IApplicationBuilder app)
    {
        var middleware = app.ApplicationServices.GetRequiredService<RequestLoggingMiddleware>();
        return app.Use(next => context => middleware.InvokeAsync(context, next));
    }

    
/ </summary>
    
/ <param name="app"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static IApplicationBuilder DisableRequestLogging(this IApplicationBuilder app)
    {
        return app.Use(next => context =>
        {
            var loggingFeature = context.Features.Get<IRequestLoggingFeature>();
            if (loggingFeature != null)
            {
                loggingFeature.Enable = false;
            }
            return next(context);
        });
    }

    
/ </summary>
    
/ <param name="app"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static IApplicationBuilder UseHttpReverseProxy(this IApplicationBuilder app)
    {
        var middleware = app.ApplicationServices.GetRequiredService<HttpReverseProxyMiddleware>();
        return app.Use(next => context => middleware.InvokeAsync(context, next));
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Extensions\KestrelServerOptionsExtensions.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.HttpServer/KestrelServerOptionsExtensions.cs


/ </summary>
    
/ <param name="options"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void NoLimit(this KestrelServerOptions options)
    {
        options.Limits.MaxRequestBodySize = null;
        options.Limits.MinResponseDataRate = null;
        options.Limits.MinRequestBodyDataRate = null;
    }

    
/ </summary>
    
/ <param name="options"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void ListenHttpProxy(this KestrelServerOptions options)
    {
        var reverseProxyConfig = options.ApplicationServices.GetRequiredService<IReverseProxyConfig>();
        var httpProxyPort = reverseProxyConfig.HttpProxyPort;

        if (!IReverseProxyConfig.IsAvailableTcp(httpProxyPort))
        {
            throw new ApplicationException(
                $"TCP port {httpProxyPort} is already occupied by other processes.");
        }

        options.Listen(IReverseProxyService.Constants.Instance.ProxyIp, httpProxyPort, listen =>
        {
            var proxyMiddleware = options.ApplicationServices.GetRequiredService<HttpProxyMiddleware>();
            var tunnelMiddleware = options.ApplicationServices.GetRequiredService<TunnelMiddleware>();

            listen.UseFlowAnalyze();
            listen.Use(next => context => proxyMiddleware.InvokeAsync(next, context));
            listen.UseTls();
            listen.Use(next => context => tunnelMiddleware.InvokeAsync(next, context));
        });

        options.GetLogger().LogInformation(
            "Listened http:
/ </summary>
    
/ <param name="options"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void ListenSshReverseProxy(this KestrelServerOptions options)
    {
        var sshPort = IReverseProxyConfig.SshPort;
        options.ListenLocalhost(sshPort, listen =>
        {
            listen.UseFlowAnalyze();
            listen.UseConnectionHandler<GithubSshReverseProxyHandler>();
        });

        var logger = options.GetLogger();
        logger.LogInformation(
            "Listened ssh:
/ </summary>
    
/ <param name="options"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void ListenGitReverseProxy(this KestrelServerOptions options)
    {
        var gitPort = IReverseProxyConfig.GitPort;
        options.ListenLocalhost(gitPort, listen =>
        {
            listen.UseFlowAnalyze();
            listen.UseConnectionHandler<GithubGitReverseProxyHandler>();
        });

        var logger = options.GetLogger();
        logger.LogInformation(
            "Listened git:
/ </summary>
    
/ <param name="options"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void ListenHttpReverseProxy(this KestrelServerOptions options)
    {
        var httpPort = IReverseProxyConfig.HttpPort;
        options.Listen(IReverseProxyService.Constants.Instance.ProxyIp, httpPort);

        var logger = options.GetLogger();
        logger.LogInformation(
            "Listened http:
/ </summary>
    
/ <param name="options"></param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void ListenHttpsReverseProxy(this KestrelServerOptions options)
    {
        var certService = options.ApplicationServices.GetRequiredService<CertService>();
        
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Extensions\KestrelServerOptionsExtensions.cs
WINDOWS
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Extensions\ListenOptionsExtensions.cs
/ </summary>
    
/ <param name="listen"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ListenOptions UseFlowAnalyze(this ListenOptions listen)
    {
        var flowAnalyzer = listen.ApplicationServices.GetRequiredService<IFlowAnalyzer>();
        listen.Use(next => async context =>
        {
            var oldTransport = context.Transport;
            try
            {
                await using var loggingDuplexPipe = new FlowAnalyzeDuplexPipe(context.Transport, flowAnalyzer);
                context.Transport = loggingDuplexPipe;
                await next(context);
            }
            finally
            {
                context.Transport = oldTransport;
            }
        });
        return listen;
    }

    
/ </summary>
    
/ <param name="listen"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ListenOptions UseTls(this ListenOptions listen)
    {
        var certService = listen.ApplicationServices.GetRequiredService<CertService>();
        listen.Use(next => context => TlsInvadeMiddleware.InvokeAsync(next, context));
        listen.UseHttps(new TlsHandshakeCallbackOptions
        {
            OnConnection = ctx =>
            {
                var o = new SslServerAuthenticationOptions
                {
                    ServerCertificate = certService.GetOrCreateServerCert(ctx.ClientHelloInfo.ServerName),
                };
                return ValueTask.FromResult(o);
            },
        });
        listen.Use(next => context => TlsRestoreMiddleware.InvokeAsync(next, context));
        return listen;
    }

    
/ </summary>
    
/ <param name="listen"></param>
    
/ <param name="configureOptions">https配置</param>
    
/ <returns></returns>
    
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Extensions\ServiceCollectionExtensions.cs
/ </summary>
    
/ <param name="services"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IServiceCollection AddReverseProxyService(this IServiceCollection services)
    {
        services.AddSingleton<YarpReverseProxyServiceImpl>();
        services.AddSingleton<IReverseProxySettings>(s => s.GetRequiredService<YarpReverseProxyServiceImpl>());
        services.AddSingleton<IReverseProxyService>(s => s.GetRequiredService<YarpReverseProxyServiceImpl>());
        return services;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static IServiceCollection AddConfiguration(this IServiceCollection services, YarpReverseProxyServiceImpl reverseProxyService)
    {
        
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.Configuration/ServiceCollectionExtensions.cs#L18
        TypeConverterBinder.Bind(IPAddress2.ParseNullable, val => val?.ToString());
        TypeConverterBinder.Bind(IPEndPoint.Parse, val => val?.ToString());

        
/ </summary>
    
/ <param name="services"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static IServiceCollection AddDomainResolve(this IServiceCollection services)
    {
        
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.DomainResolve/ServiceCollectionExtensions.cs#L17
        
/ </summary>
    
/ <param name="services"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static IServiceCollection AddReverseProxyHttpClient(this IServiceCollection services)
    {
        
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.Http/ServiceCollectionExtensions.cs#L17
        services.TryAddSingleton<IReverseProxyHttpClientFactory, ReverseProxyHttpClientFactory>();
        return services;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void AddCommonHttpClientFactory(this IServiceCollection services)
    {
        services.AddSingleton<IHttpClientFactory_Common>(
            s => new HttpClientFactoryWrapper(s));
    }

    sealed class HttpClientFactoryWrapper : IHttpClientFactory_Common
    {
        readonly IServiceProvider s;

        public HttpClientFactoryWrapper(IServiceProvider s)
        {
            this.s = s;
        }

        HttpClient IHttpClientFactory_Common.CreateClient(string name, HttpHandlerCategory category)
            => s.GetRequiredService<IHttpClientFactory_Extensions_Http>().CreateClient(name);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void AddCookieHttpClient(this IServiceCollection services)
    {
        services.AddCommonHttpClientFactory();
        services.AddSingleton<CookieHttpClient>();
        services.AddHttpClient(CookieHttpClient.HttpClientName, (s, c) =>
        {
            c.Timeout = GeneralHttpClientFactory.DefaultTimeout;
        }).ConfigurePrimaryHttpMessageHandler(() => new HttpHandlerType()
        {
            UseCookies = true,
            CookieContainer = CookieHttpClient.CookieContainer,
        });
    }

    
/ </summary>
    
/ <param name="services"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static IServiceCollection AddReverseProxyServer(this IServiceCollection services)
    {
        
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.HttpServer/ServiceCollectionExtensions.cs#L15

        services.AddCookieHttpClient();

        return services
            .AddMemoryCache()
            .AddHttpForwarder()
            .AddSingleton<CertService>()
            
/ </summary>
    
/ <param name="services"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static IServiceCollection AddFlowAnalyze(this IServiceCollection services)
    {
        
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.FlowAnalyze/ServiceCollectionExtensions.cs#L16
        return services.AddSingleton<IFlowAnalyzer, FlowAnalyzer>();
    }

#if WINDOWS

#if !REMOVE_DNS_INTERCEPT
    
/ </summary>
    
/ <param name="services"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static IServiceCollection AddPacketIntercept(this IServiceCollection services)
    {
        
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.PacketIntercept/ServiceCollectionExtensions.cs#L21
        
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Extensions\ServiceCollectionExtensions.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Extensions\SystemWebExtensions.cs
/docs.microsoft.com/zh-cn/dotnet/api/system.web.httprequest</para>

/ </summary>
public static class SystemWebExtensions
{
    
/ 获取所提供的客户端浏览器的原始用户代理字符串。 请注意此字符串可能为 <see langword="null"/>
    
/ </summary>
    
/ <param name="request"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static string? UserAgent(this HttpRequest request)
    {
        return request.Headers.TryGetValue("User-Agent", out var value) ? value.ToString() : null;
    }

    
/docs.microsoft.com/zh-cn/dotnet/api/system.web.httpresponse.contentencoding?view=netframework-4.8</para>
    
/ </summary>
    
/ <param name="response"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Encoding? ContentTextEncoding(this HttpResponse response)
    {
        if (MediaTypeHeaderValue.TryParse(response.ContentType, out var contentType))
        {
            
/github.com/dotnet/aspnetcore/blob/v6.0.6/src/Http/Headers/src/MediaTypeHeaderValue.cs#L113
            try
            {
                return contentType.Encoding;
            }
            catch
            {

            }
        }
        
/github.com/dotnet/runtime/blob/v6.0.6/src/libraries/System.Net.Http/src/System/Net/Http/HttpContent.cs#L24
        return null;
    }

    
/ </summary>
    
/www.contoso.com/articles/recent.aspx中，原始 URL 为/articles/recent.aspx。 原始 URL 包括查询字符串（如果存在）</remarks>
    
/ <param name="request"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static string RawUrl(this HttpRequest request)
    {
        
/github.com/dotnet/aspnetcore/blob/v3.1.5/src/Http/Http.Extensions/src/UriHelper.cs#L196
        var pathBase = request.PathBase.Value ?? string.Empty;
        var path = request.Path.Value ?? string.Empty;
        var queryString = request.QueryString.Value ?? string.Empty;
        var length = pathBase.Length + path.Length + queryString.Length;
        return new StringBuilder(length)
            .Append(pathBase)
            .Append(path)
            .Append(queryString)
            .ToString();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static string? Action(this IUrlHelper helper, string action, QueryString values)
    {
        var url = helper.Action(action);
        if (values.HasValue)
        {
            var length = url.Length + values.Value!.Length;
            return new StringBuilder(length)
               .Append(url)
               .Append(values.Value)
               .ToString();
        }
        else
        {
            return url;
        }
    }

    
/ </summary>
    
/ <param name="request"></param>
    
/ <param name="ipv4"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static string UserHostAddress(this HttpRequest request, bool ipv4 = true)
    {
        var remoteIpAddress = request.HttpContext.Connection.RemoteIpAddress;
        if (remoteIpAddress == null) throw new ArgumentNullException(nameof(remoteIpAddress));
        try
        {
            return ipv4
                ? (remoteIpAddress.AddressFamily == AddressFamily.InterNetwork ? remoteIpAddress.ToString() : remoteIpAddress.MapToIPv4().ToString())
                : (remoteIpAddress.AddressFamily == AddressFamily.InterNetworkV6 ? remoteIpAddress.ToString() : remoteIpAddress.MapToIPv6().ToString());
        }
        catch
        {
            return remoteIpAddress.ToString();
        }
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Models\FlowStatistics.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.FlowAnalyze/FlowStatistics.cs


/ </summary>
[MP2Obj(SerializeLayout.Explicit)]
public partial record FlowStatistics
{
    
/ </summary>
    [MP2Key(0)]
    public long TotalRead { get; init; }

    
/ </summary>
    [MP2Key(1)]
    public long TotalWrite { get; init; }

    
/ </summary>
    [MP2Key(2)]
    public double ReadRate { get; init; }

    
/ </summary>
    [MP2Key(3)]
    public double WriteRate { get; init; }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Models\ReverseProxyConfig.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.Configuration/FastGithubConfig.cs


/}

                dict.Add(new KeyValuePair<DomainPattern, IScriptConfig>(new DomainPattern(domainNames) { Order = item.Order }, item));
            }

            static string GetDomainPatternString(string s)
            {
                if (s.IndexOf("/") != 0)
                {
                    return "/^" + Regex.Escape(s).Replace("\\*", ".*").Replace("\\?", ".") + "$";
                }
                return s;
            }
        }
    }

    
/ </summary>
    
/ <param name="domainConfigs"></param>
    
/ <returns></returns>
    
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Models\Abstractions\IReverseProxyConfig.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.Configuration/FastGithubConfig.cs


/ </summary>
    
/ <param name="domain"></param>
    
/ <returns></returns>
    bool IsMatch(string url) => TryGetDomainConfig(url, out _);

    
/ </summary>
    
/ <param name="domain"></param>
    
/ <param name="value"></param>
    
/ <returns></returns>
    bool TryGetDomainConfig(string url, [MaybeNullWhen(false)] out IDomainConfig value);

    
/ </summary>
    
/ <param name="domain"></param>
    
/ <param name="value"></param>
    
/ <returns></returns>
    bool TryGetScriptConfig(string url, [MaybeNullWhen(false)] out IEnumerable<IScriptConfig> value);

    
/ </summary>
    
/ <param name="lid"></param>
    
/ <param name="content"></param>
    
/ <returns></returns>
    bool TryGetScriptContent(int lid, out string? content);

    
/ </summary>
    
/ <returns></returns>
    DomainPattern[] GetDomainPatterns();
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Models\Abstractions\IReverseProxyConfig.GlobalListener.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.Configuration/GlobalListener.cs

using System.Net.NetworkInformation;


/ </summary>
    static int SshPort { get; } = GetAvailableTcpPort(SshPortDefault);

    const int GitHubDesktopPort = 9418;

    
/ </summary>
    static int GitPort { get; } = GetAvailableTcpPort(GitHubDesktopPort);

    const int HttpPortDefault = 80;

    
/ </summary>
    static int HttpPort { get; } = GetAvailableTcpPort(HttpPortDefault);

    const int HttpsPortDefault = 443;

    
/ </summary>
    static int HttpsPort { get; } = GetAvailableTcpPort(HttpsPortDefault);

    
/ </summary>
    
/ <param name="func"></param>
    
/ <returns></returns>
    private static HashSet<int> GetListenPorts(Func<IPEndPoint[]> func)
    {
        var hashSet = new HashSet<int>();
        try
        {
            foreach (var endpoint in func())
            {
                hashSet.Add(endpoint.Port);
            }
        }
        catch (Exception)
        {
        }
        return hashSet;
    }

    
/ </summary>
    
/ <param name="port"></param>
    
/ <returns></returns>
    public static bool IsAvailableTcp(int port) => tcpListenPorts.Contains(port) == false;

    
/ </summary>
    
/ <param name="port"></param>
    
/ <returns></returns>
    public static bool IsAvailableUdp(int port) => udpListenPorts.Contains(port) == false;

    
/ </summary>
    
/ <param name="port"></param>
    
/ <returns></returns>
    public static bool IsAvailableTcpAndUdp(int port) => IsAvailableTcp(port) && IsAvailableUdp(port);

    
/ </summary>
    
/ <param name="minPort"></param>
    
/ <returns></returns>
    public static int GetAvailableTcpPort(int minPort) => GetAvailablePort(IsAvailableTcp, minPort);

    
/ </summary>
    
/ <param name="minPort"></param>
    
/ <returns></returns>
    public static int GetAvailableUdpPort(int minPort) => GetAvailablePort(IsAvailableUdp, minPort);

    
/ </summary>
    
/ <param name="minPort"></param>
    
/ <returns></returns>
    public static int GetAvailableTcpAndUdpPort(int minPort) => GetAvailablePort(IsAvailableTcpAndUdp, minPort);

    static int GetAvailablePort(Func<int, bool> isAvailable, int minPort)
    {
        for (var port = minPort; port < IPEndPoint.MaxPort; port++)
        {
            if (isAvailable(port) == true)
            {
                return port;
            }
        }
        throw new ApplicationException("Failed to get available ports. There are no available ports.");
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services\IDnsInterceptor.cs
/ </summary>
interface IDnsInterceptor : IInterceptor
{
}

#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services\IDnsInterceptor.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services\IDomainResolver.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.DomainResolve/IDomainResolver.cs


/ </summary>
public interface IDomainResolver
{
    
/ </summary>
    
/ <param name="endPoint"></param>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    IAsyncEnumerable<IPAddress> ResolveAsync(DnsEndPoint endPoint, CancellationToken cancellationToken = default);

    
/ </summary>
    
/ <param name="cancellationToken"></param>
    void CheckIpv6SupportAsync(CancellationToken cancellationToken = default);

    
/ </summary>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    Task TestSpeedAsync(CancellationToken cancellationToken = default);
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services\IFlowAnalyzer.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.FlowAnalyze/FlowAnalyzer.cs


/ </summary>
public interface IFlowAnalyzer
{
    
/ </summary>
    
/ <param name="flowType"></param>
    
/ <param name="length"></param>
    void OnFlow(FlowType flowType, int length);

    
/ </summary>
    
/ <returns></returns>
    FlowStatistics GetFlowStatistics();
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services\IInterceptor.cs
/ </summary>
interface IInterceptor
{
    
/ </summary>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    Task InterceptAsync(CancellationToken cancellationToken);
}

#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services\IInterceptor.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services\IRequestLoggingFeature.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.HttpServer/IRequestLoggingFeature.cs


/ </summary>
internal interface IRequestLoggingFeature
{
    
/ </summary>
    bool Enable { get; set; }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services\IReverseProxyHttpClientFactory.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.Http/IHttpClientFactory.cs


/ </summary>
public interface IReverseProxyHttpClientFactory
{
    
/ </summary>
    
/ <param name="domain"></param>
    
/ <param name="domainConfig"></param>
    
/ <returns></returns>
    ReverseProxyHttpClient CreateHttpClient(string domain, IDomainConfig domainConfig);
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services\IReverseProxyService.Constants.cs
/ </summary>
[IpcPublic(Timeout = AssemblyInfo.IpcTimeout, IgnoresIpcException = false)]
public partial interface IReverseProxyService : IDisposable
{
    
/ </summary>
    static class Constants
    {
        internal static InstanceReverseProxyService Instance => Ioc.Get<InstanceReverseProxyService>();

        
/ <inheritdoc cref="CertificateConstants.CertificateName"/>
        public const string CertificateName = CertificateConstants.CertificateName;

        
/ <inheritdoc cref="CertificateConstants.RootCertificateName"/>
        public const string RootCertificateName = CertificateConstants.RootCertificateName;

        public const ExternalProxyType DefaultTwoLevelAgentProxyType = ExternalProxyType.Socks5;

        public const string LocalDomain = "local.steampp.net";

        public static IPAddress DefaultProxyIp => IPAddress.Any;
    }

    
/ </summary>
    bool ProxyRunning { get; }

    
/ <inheritdoc cref="IReverseProxySettings.Scripts"/>
    IReadOnlyCollection<ScriptIPCDTO>? Scripts { get; set; }

    
/ </summary>
    Task<StartProxyResult> StartProxyAsync(byte[] reverseProxySettings);

    
/ </summary>
    void Exit();

    
/ </summary>
    
/ <returns></returns>
    Task StopProxyAsync();

#if DEBUG

    string GetDebugString()
    {
        return $"Pid: {Environment.ProcessId}, Exe: {Environment.ProcessPath}, Asm: {Assembly.GetAssembly(GetType())?.FullName}";
    }

    Task<StartProxyResult> GetDebugString2()
    {
        StartProxyResult r = new(StartProxyResultCode.Exception, new Exception("aaaa"));
        return Task.FromResult(r);
    }

#endif
}


/ </summary>
public partial interface IReverseProxySettings
{
    
/ </summary>
    IReadOnlyCollection<AccelerateProjectDTO>? ProxyDomains { get; set; }

    
/ </summary>
    IReadOnlyCollection<ScriptIPCDTO>? Scripts { get; set; }

    
/ </summary>
    bool IsEnableScript { get; set; }

    
/ </summary>
    bool IsOnlyWorkSteamBrowser { get; set; }

    
/ </summary>
    ushort ProxyPort { get; set; }

    
/ </summary>
    IPAddress ProxyIp { get; set; }

    
/ </summary>
    ProxyMode ProxyMode { get; set; }

    
/ </summary>
    bool IsProxyGOG { get; set; }

    
/ </summary>
    bool OnlyEnableProxyScript { get; set; }

    
/ </summary>
    bool EnableHttpProxyToHttps { get; set; }

    #region Socks5

    
/ </summary>
    bool Socks5ProxyEnable { get; set; }

    
/ </summary>
    ushort Socks5ProxyPortId { get; set; }

    #endregion Socks5

    #region TwoLevelAgent(二级代理)

    bool TwoLevelAgentEnable { get; set; }

    ExternalProxyType TwoLevelAgentProxyType { get; set; }

    string? TwoLevelAgentIp { get; set; }

    ushort TwoLevelAgentPortId { get; set; }

    string? TwoLevelAgentUserName { get; set; }

    string? TwoLevelAgentPassword { get; set; }

    #endregion TwoLevelAgent(二级代理)

    IPAddress? ProxyDNS { get; set; }

    
/ </summary>
    bool IsSupportIpv6 { get; set; }

    bool UseDoh { get; set; }

    string? CustomDohAddres { get; set; }

    
/ </summary>
    string? ServerSideProxyToken { get; set; }
}

[MP2Obj(SerializeLayout.Explicit)]
public readonly partial record struct ReverseProxySettings(
    [property: MP2Key(0)]
    IReadOnlyCollection<AccelerateProjectDTO>? ProxyDomains,
    [property:MP2Key(1)]
    IReadOnlyCollection<ScriptIPCDTO>? Scripts,
    [property:MP2Key(2)]
    bool IsEnableScript,
    [property:MP2Key(3)]
    bool IsOnlyWorkSteamBrowser,
    [property:MP2Key(4)]
    ushort ProxyPort,
    [property:MP2Key(5)]
    string? ProxyIp,
    [property:MP2Key(6)]
    ProxyMode ProxyMode,
    [property:MP2Key(7)]
    bool IsProxyGOG,
    [property:MP2Key(8)]
    bool OnlyEnableProxyScript,
    [property:MP2Key(9)]
    bool EnableHttpProxyToHttps,
    [property:MP2Key(10)]
    bool Socks5ProxyEnable,
    [property:MP2Key(11)]
    ushort Socks5ProxyPortId,
    [property:MP2Key(12)]
    bool TwoLevelAgentEnable,
    [property:MP2Key(13)]
    ExternalProxyType TwoLevelAgentProxyType,
    [property:MP2Key(14)]
    string? TwoLevelAgentIp,
    [property:MP2Key(15)]
    ushort TwoLevelAgentPortId,
    [property:MP2Key(16)]
    string? TwoLevelAgentUserName,
    [property:MP2Key(17)]
    string? TwoLevelAgentPassword,
    [property:MP2Key(18)]
    string? ProxyDNS,
    [property:MP2Key(19)]
    bool IsSupportIpv6,
    [property:MP2Key(20)]
    bool UseDoh,
    [property:MP2Key(21)]
    string? CustomDohAddres,
    [property:MP2Key(22)]
    string? ServerSideProxyToken)
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal IPAddress GetProxyIp() => GetProxyIp(ProxyIp);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal IPAddress? GetProxyDNS()
    {
        var result = IPAddress2.TryParse(ProxyDNS, out var proxyDNS) ? proxyDNS : null;
        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static string GetTwoLevelAgentIp(string? twoLevelAgentIp)
    {
        var result = IPAddress2.TryParse(twoLevelAgentIp, out var twoLevelAgentIp_) ?
            twoLevelAgentIp_.ToString() : IPAddress.Loopback.ToString();
        return result;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static IPAddress GetProxyIp(string? proxyIp)
    {
        var result = IPAddress2.TryParse(proxyIp, out var ip) ? ip : IPAddress.Any;
        return result;
    }

#if APP_REVERSE_PROXY
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal void SetValue(IReverseProxySettings settings)
    {
        settings.ProxyDomains = ProxyDomains;
        settings.Scripts = Scripts;
        settings.IsEnableScript = IsEnableScript;
        settings.IsOnlyWorkSteamBrowser = IsOnlyWorkSteamBrowser;
        settings.ProxyPort = ProxyPort == default ? ReverseProxyServiceImpl.DefaultProxyPort : ProxyPort;
        settings.ProxyIp = GetProxyIp();
        settings.ProxyMode = ProxyMode;
        settings.IsProxyGOG = IsProxyGOG;
        settings.OnlyEnableProxyScript = OnlyEnableProxyScript;
        settings.EnableHttpProxyToHttps = EnableHttpProxyToHttps;
        settings.Socks5ProxyEnable = Socks5ProxyEnable;
        settings.Socks5ProxyPortId = Socks5ProxyPortId;
        settings.TwoLevelAgentEnable = TwoLevelAgentEnable;
        settings.TwoLevelAgentProxyType = TwoLevelAgentProxyType;
        settings.TwoLevelAgentIp = TwoLevelAgentIp;
        settings.TwoLevelAgentPortId = TwoLevelAgentPortId;
        settings.TwoLevelAgentUserName = TwoLevelAgentUserName;
        settings.TwoLevelAgentPassword = TwoLevelAgentPassword;
        settings.ProxyDNS = GetProxyDNS();
        settings.IsSupportIpv6 = IsSupportIpv6;
        settings.UseDoh = UseDoh;
        settings.CustomDohAddres = CustomDohAddres;
        settings.ServerSideProxyToken = ServerSideProxyToken;
    }
#endif
}


/ </summary>
public enum StartProxyResultCode : byte
{
    
/ </summary>
    IpcCallFailOrDefault = default,

    
/ </summary>
    GenerateCertificateFail,

    
/ </summary>
    GenerateCerFilePathFail,

    
/ </summary>
    GetCertificatePackableFail,

    
/ </summary>
    TrustRootCertificateFail,

    GetX509Certificate2Fail,

    
/ </summary>
    Ok = 121,

    
/ </summary>
    [Obsolete("use GenerateCertificateFail/TrustRootCertificateFail")]
    SetupRootCertificateFail,

    
/ 反序列化 <see cref="ReverseProxySettings"/> 失败
    
/ </summary>
    DeserializeReverseProxySettingsFail,

    
/ </summary>
    Exception,

    
/ </summary>
    BindPortError,
}


/ </summary>

/ <param name="Code">状态码</param>

/ <param name="Exception">未处理的异常</param>
public readonly record struct StartProxyResult(StartProxyResultCode Code, Exception? Exception)
{
    public static implicit operator bool(StartProxyResult result) => result.Code == StartProxyResultCode.Ok;

    public static implicit operator StartProxyResult(StartProxyResultCode code) => new(code, default);

    public static implicit operator StartProxyResult(Exception? exception) => exception == null ? new(StartProxyResultCode.Ok, default) : new(StartProxyResultCode.Exception, exception);
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services\IReverseProxyService.Constants.cs
APP
DEBUG
APP
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services\IReverseProxyService.cs
/ </summary>
    
/ <returns></returns>
    [Obsolete("not supported")]
    bool WirtePemCertificateToGoGSteamPlugins();

    
/ </summary>
    
/ <returns></returns>
    byte[]? GetFlowStatistics_Bytes();

    
/ </summary>
    
/ <returns></returns>
    string? GetLogAllMessage();
}

public static partial class ReverseProxyServiceExtensions
{
    
/ <inheritdoc cref="IReverseProxyService.GetFlowStatistics_Bytes"/>
    public static FlowStatistics? GetFlowStatistics(this IReverseProxyService s)
    {
        var bytes = s.GetFlowStatistics_Bytes();
        if (bytes == default) return default;
        var flowStatistics = Serializable.DMP2<FlowStatistics>(bytes);
        return flowStatistics;
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services\ITcpInterceptor.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.PacketIntercept/ITcpInterceptor.cs

#if WINDOWS


/ </summary>
interface ITcpInterceptor : IInterceptor
{
}

#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services\ITcpInterceptor.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services\Certificate\ICertificateManager.cs
/ 证书管理(安装/卸载)

/ </summary>
[IpcPublic(Timeout = AssemblyInfo.IpcTimeout, IgnoresIpcException = false)]
public interface ICertificateManager
{
    static class Constants
    {
        public static ICertificateManager Instance => Ioc.Get<ICertificateManager>(); 
/ </summary>
        
/ <param name="certificateManager"></param>
        
/ <returns></returns>
        internal static StartProxyResultCode CheckRootCertificate(
            IPCPlatformService platformService,
            ICertificateManager certificateManager)
        {
            string? cerFilePathLazy = null;
            string? GetCerFilePath()
            {
                if (cerFilePathLazy != null)
                    return cerFilePathLazy;
                cerFilePathLazy = certificateManager.GetCerFilePathGeneratedWhenNoFileExists();
                return cerFilePathLazy;
            }

            X509CertificatePackable GetRootCertificatePackable()
            {
#if APP_REVERSE_PROXY
                return ((CertificateManagerImpl)certificateManager).RootCertificatePackable;
#else
                try
                {
                    var packableBytes = certificateManager.RootCertificatePackable;
                    if (packableBytes.Any_Nullable())
                    {
                        var result = Serializable.DMP2<X509CertificatePackable>(packableBytes);
                        return result;
                    }
                }
                catch
                {

                }
                return default;
#endif
            }

            
/ </summary>
    byte[]? PfxPassword { get; }

    #region Path

    
/ </summary>
    string PfxFilePath => CertificateConstants.DefaultPfxFilePath;

    
/ </summary>
    string CerFilePath => CertificateConstants.DefaultCerFilePath;

    #endregion

    
/ 获取当前 Root 证书，<see cref="X509CertificatePackable"/> 类型可隐式转换为 <see cref="X509Certificate2"/>
    
/ </summary>
    byte[]? RootCertificatePackable { get; }

    
/ </summary>
    
/ <returns></returns>
    string? GetCerFilePathGeneratedWhenNoFileExists();

    
/ </summary>
    void TrustRootCertificate();

    
/ </summary>
    
/ <returns>返回根证书是否受信任</returns>
    bool SetupRootCertificate();

    
/ 删除根证书，如果没有证书将返回 <see langword="true"/>
    
/ </summary>
    
/ <returns></returns>
    bool DeleteRootCertificate();

    
/ </summary>
    [Obsolete("use IsRootCertificateInstalled2")]
    bool IsRootCertificateInstalled { get; }

    
/ </summary>
    bool? IsRootCertificateInstalled2 { get; }

    
/ </summary>
    
/ <param name="filePath"></param>
    
/ <returns></returns>
    bool? GenerateCertificate();

    
/ </summary>
    
/ <returns></returns>
    string GetCertificateInfo();
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services\Certificate\ICertificateManager.cs
APP
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services\Net\IDnsAnalysisService.Constants.cs
/ </summary>
public partial interface IDnsAnalysisService 
/dns.alidns.com/resolve";
    const string DNS_Ali_DohAddres2 = "https:
/223.6.6.6/resolve";
    const string DNS_Ali_DohAddres3 = "https:
/223.5.5.5/resolve";

    const string Dnspod_DohAddres = "https:
/1.12.12.12/resolve";
    const string Dnspod_DohAddres2 = "https:
/doh.pub/resolve";
    const string Dnspod_DohAddres3 = "https:
/120.53.53.53/resolve";

    const string Google_DohAddres = "https:
/dns.google/resolve";
    const string Cloudflare_DohAddres = "https:
/cloudflare-dns.com/resolve";
    const string DohAddres_360 = "https:
/doh.360.cn/resolve";
    const string TUNA_DohAddres = "https:
/101.6.6.6:8443/resolve";

    const string PrimaryDNS_IPV6_Ali = "2400:3200::1";

    const string PrimaryDNS_Ali = "223.5.5.5";
    const string SecondaryDNS_Ali = "223.6.6.6";

    const string PrimaryDNS_Dnspod = "119.29.29.29";
    const string SecondaryDNS_Dnspod = "182.254.116.116";

    const string PrimaryDNS_114 = "114.114.114.114";
    const string SecondaryDNS_114 = "114.114.115.115";

    const string PrimaryDNS_Google = "8.8.8.8";
    const string SecondaryDNS_Google = "8.8.4.4";

    const string PrimaryDNS_Cloudflare = "1.1.1.1";
    const string SecondaryDNS_Cloudflare = "1.0.0.1";

    const string PrimaryDNS_Baidu = "180.76.76.76";

    static readonly IPAddress[] DNS_Alis = new[] { IPAddress.Parse(PrimaryDNS_Ali), IPAddress.Parse(SecondaryDNS_Ali) };
    static readonly IPAddress[] DNS_Dnspods = new[] { IPAddress.Parse(PrimaryDNS_Dnspod), IPAddress.Parse(SecondaryDNS_Dnspod) };
    static readonly IPAddress[] DNS_114s = new[] { IPAddress.Parse(PrimaryDNS_114), IPAddress.Parse(SecondaryDNS_114) };
    static readonly IPAddress[] DNS_Googles = new[] { NameServer.GooglePublicDns.Address, NameServer.GooglePublicDns2.Address };
    static readonly IPAddress[] DNS_Cloudflares = new[] { NameServer.Cloudflare.Address, NameServer.Cloudflare2.Address };

    static readonly Uri[] DoH_Alis = new[] { new Uri(DNS_Ali_DohAddres), new Uri(DNS_Ali_DohAddres2), new Uri(DNS_Ali_DohAddres3) };
    static readonly Uri[] DoH_Dnspods = new[] { new Uri(Dnspod_DohAddres), new Uri(Dnspod_DohAddres2), new Uri(Dnspod_DohAddres3) };

    private static class NameServer
    {
        public static readonly IPEndPoint GooglePublicDns = new(IPAddress.Parse(SecondaryDNS_Google), 53);

        public static readonly IPEndPoint GooglePublicDns2 = new(IPAddress.Parse(PrimaryDNS_Google), 53);

        public static readonly IPEndPoint Cloudflare = new(IPAddress.Parse("1.1.1.1"), 53);

        public static readonly IPEndPoint Cloudflare2 = new(IPAddress.Parse("1.0.0.1"), 53);
    }

    #endregion DNS 常量
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services\Net\IDnsAnalysisService.cs
/ </summary>
    
/ <param name="hostNameOrAddress">要解析的主机名或 IP 地址</param>
    
/ <param name="isIPv6"></param>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    IAsyncEnumerable<IPAddress> AnalysisDomainIpAsync(string hostNameOrAddress, bool isIPv6, CancellationToken cancellationToken = default)
        => AnalysisDomainIpAsync(hostNameOrAddress, default, isIPv6, cancellationToken);

    
/ </summary>
    
/ <param name="hostNameOrAddress">要解析的主机名或 IP 地址</param>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    IAsyncEnumerable<IPAddress> AnalysisDomainIpAsync(string hostNameOrAddress, CancellationToken cancellationToken = default)
        => AnalysisDomainIpAsync(hostNameOrAddress, default, default, cancellationToken);

    
/ </summary>
    
/ <param name="hostNameOrAddress">要解析的主机名或 IP 地址</param>
    
/ <param name="dnsServers">自定义 DNS 服务器，可选的值有 <see cref="DNS_Alis"/>, <see cref="DNS_114s"/>, <see cref="DNS_Cloudflares"/>, <see cref="DNS_Dnspods"/>, <see cref="DNS_Googles"/></param>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    IAsyncEnumerable<IPAddress> AnalysisDomainIpAsync(string hostNameOrAddress, IPAddress[]? dnsServers, CancellationToken cancellationToken = default)
        => AnalysisDomainIpAsync(hostNameOrAddress, dnsServers, default, cancellationToken);

    
/ </summary>
    
/ <param name="hostNameOrAddress">要解析的主机名或 IP 地址</param>
    
/ <param name="dnsServers">自定义 DNS 服务器，可选的值有 <see cref="DNS_Alis"/>, <see cref="DNS_114s"/>, <see cref="DNS_Cloudflares"/>, <see cref="DNS_Dnspods"/>, <see cref="DNS_Googles"/></param>
    
/ <param name="isIPv6"></param>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    async IAsyncEnumerable<IPAddress> AnalysisDomainIpAsync(string hostNameOrAddress, IPAddress[]? dnsServers, bool isIPv6, [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        var items = await
#if NET6_0_OR_GREATER
            Dns.GetHostAddressesAsync(hostNameOrAddress, cancellationToken);
#else
            Dns.GetHostAddressesAsync(hostNameOrAddress);
#endif
        foreach (var item in items)
        {
            yield return item;
        }
    }

    async Task<string?> GetHostByIPAddressAsync(IPAddress ip)
    {
        var hostEntry = await Dns.GetHostEntryAsync(ip);
        return hostEntry.HostName;
    }

    Task<bool> GetIsIpv6SupportAsync() => Task.FromResult(false);

    Task<IPAddress?> GetHostIpv6AddresAsync() => Task.FromResult(default(IPAddress));
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services\Net\IDnsAnalysisService.cs
NET
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\DomainResolver.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.DomainResolve/DomainResolver.cs


发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\ReverseProxyHttpClientFactory.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.Http/HttpClientFactory.cs


/ </summary>
    readonly TimeSpan firstLiftTime = TimeSpan.FromSeconds(10d);

    
/ </summary>
    readonly TimeSpan nextLifeTime = TimeSpan.FromSeconds(100d);

    
/ <see cref="LifetimeHttpHandler"/> 清理器
    
/ </summary>
    readonly LifetimeHttpHandlerCleaner httpHandlerCleaner = new();

    
/ </summary>
    readonly ConcurrentDictionary<LifeTimeKey, Lazy<LifetimeHttpHandler>> httpHandlerLazyCache = new();

    public ReverseProxyHttpClientFactory(IDomainResolver domainResolver, IReverseProxyConfig reverseProxyConfig)
    {
        this.domainResolver = domainResolver;
        if (reverseProxyConfig.Service.TwoLevelAgentEnable)
        {
            this.webProxy = new WebProxy($"{reverseProxyConfig.Service.TwoLevelAgentProxyType}:
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\ReverseProxyServiceImpl.cs
/ </summary>
    public X509Certificate2? RootCertificate
    {
        get => CertificateManager.RootCertificatePackable;
    }

    
/ <inheritdoc cref="IReverseProxyService.ProxyRunning"/>
    public abstract bool ProxyRunning { get; }

    
/ <inheritdoc cref="IReverseProxyService.ProxyDomains"/>
    public IReadOnlyCollection<AccelerateProjectDTO>? ProxyDomains { get; set; }

    
/ <inheritdoc cref="IReverseProxyService.Scripts"/>
    public IReadOnlyCollection<ScriptIPCDTO>? Scripts { get; set; }

    
/ <inheritdoc cref="IReverseProxyService.IsEnableScript"/>
    public bool IsEnableScript { get; set; }

    
/ <inheritdoc cref="IReverseProxyService.IsOnlyWorkSteamBrowser"/>
    public bool IsOnlyWorkSteamBrowser { get; set; }

    public const ushort DefaultProxyPort = 26501;

    
/ <inheritdoc cref="IReverseProxyService.ProxyPort"/>
    public ushort ProxyPort { get; set; } = DefaultProxyPort;

    
/ <inheritdoc cref="IReverseProxyService.ProxyIp"/>
    public IPAddress ProxyIp { get; set; } = IReverseProxyService.Constants.DefaultProxyIp;

    
/ <inheritdoc cref="IReverseProxyService.ProxyMode"/>
    public ProxyMode ProxyMode { get; set; }

    
/ <inheritdoc cref="IReverseProxyService.IsProxyGOG"/>
    public bool IsProxyGOG { get; set; }

    
/ <inheritdoc cref="IReverseProxyService.OnlyEnableProxyScript"/>
    public bool OnlyEnableProxyScript { get; set; }

    
/ <inheritdoc cref="IReverseProxyService.EnableHttpProxyToHttps"/>
    public bool EnableHttpProxyToHttps { get; set; }

    
/ <inheritdoc cref="IReverseProxyService.Socks5ProxyEnable"/>
    public bool Socks5ProxyEnable { get; set; }

    
/ <inheritdoc cref="IReverseProxyService.Socks5ProxyPortId"/>
    public ushort Socks5ProxyPortId { get; set; }

    
/ </summary>
    
/ <returns></returns>
    protected int GetRandomUnusedPort() => SocketHelper.GetRandomUnusedPort(ProxyIp);

    
/ <inheritdoc cref="IReverseProxyService.WirtePemCertificateToGoGSteamPlugins"/>
    public bool WirtePemCertificateToGoGSteamPlugins()
    {
        /* https:
/www.gog.com/galaxy
         * GOG GALAXY 2.0 公测需要 Windows 8 或更新版本。
         * 也同时支持 Mac OS X。
         * OSX 也是这个路径？？？？
         * https:
/snapcraft.io/gog-galaxy-wine
         * 作废
         */
        var local = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
        var gogPlugins = Path.Combine(local, "GOG.com", "Galaxy", "plugins", "installed");
        if (Directory.Exists(gogPlugins))
        {
            foreach (var dir in Directory.GetDirectories(gogPlugins))
            {
                if (dir.Contains("steam"))
                {
                    var pem = RootCertificate!.GetPublicPemCertificateString();
                    var certifi = Path.Combine(local, dir, "certifi", "cacert.pem");
                    if (File.Exists(certifi))
                    {
                        var file = File.ReadAllText(certifi);
                        var s = file.Substring(Constants.CERTIFICATE_TAG, Constants.CERTIFICATE_TAG, true);
                        if (string.IsNullOrEmpty(s))
                        {
                            File.AppendAllText(certifi, Environment.NewLine + pem);
                        }
                        else if (s.Trim() != pem.Trim())
                        {
                            var index = file.IndexOf(Constants.CERTIFICATE_TAG);
                            File.WriteAllText(certifi, file.Remove(index, s.Length) + pem);
                        }
                        return true;
                    }
                }
            }
        }
        return false;
    }

    
/ </summary>
    
/ <param name="exception"></param>
    protected virtual void OnException(Exception exception)
    {
        Log.Error(TAG, exception, "OnException");
    }

    public async Task<StartProxyResult> StartProxyAsync(byte[] reverseProxySettings_)
    {
        ReverseProxySettings reverseProxySettings;
        try
        {
            reverseProxySettings = Serializable.DMP2<ReverseProxySettings>(reverseProxySettings_);
        }
        catch
        {
            return StartProxyResultCode.DeserializeReverseProxySettingsFail;
        }

        
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\YarpReverseProxyServiceImpl.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub/Program.cs#L29
        try
        {
            IOPath.DirCreateByNotExists(RootPath);

            var builder = WebApplication.CreateBuilder(new WebApplicationOptions
            {
                ContentRootPath = RootPath,
                WebRootPath = RootPath,
            });

            builder.Logging.AddProvider(new LogConsoleService.Utf8StringLoggerProvider(AssemblyInfo.Accelerator));

            builder.Services.Configure<HostFilteringOptions>(static o =>
            {
                o.AllowEmptyHosts = true;
                o.AllowedHosts = new List<string>
                {
                    "*",
                };
            });

            builder.Host.UseNLog();
            StartupConfigureServices(builder.Services);
            builder.WebHost.UseShutdownTimeout(TimeSpan.FromSeconds(1d));
            builder.WebHost.UseKestrel(options =>
            {
                options.AddServerHeader = false;
                options.RequestHeaderEncodingSelector = _ => Encoding.UTF8;
                options.ResponseHeaderEncodingSelector = _ => Encoding.UTF8;
                options.NoLimit();
#if WINDOWS
#if !NET7_0_OR_GREATER
                if (OperatingSystem2.IsWindows7())
                {
                    
/github.com/dotnet/aspnetcore/issues/22563
                    options.ConfigureHttpsDefaults(httpsOptions =>
                    {
                        httpsOptions.SslProtocols = SslProtocols.Tls12 | SslProtocols.Tls13;
                    });
                }
#endif
                
/docs.microsoft.com/zh-cn/dotnet/standard/garbage-collection/implementing-disposeasync#implement-both-dispose-and-async-dispose-patterns

    async ValueTask DisposeAsyncCore()
    {
        if (app is not null)
        {
            await app.DisposeAsync().ConfigureAwait(false);
        }
    }

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        await DisposeAsyncCore().ConfigureAwait(false);

        Dispose(disposing: false);
        GC.SuppressFinalize(this);
    }
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\YarpReverseProxyServiceImpl.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\YarpReverseProxyServiceImpl.Startup.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub/Startup.cs


发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\YarpReverseProxyServiceImpl.Startup.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\Certificate\CertGenerator.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.HttpServer/CertGenerator.cs

using X509Certificate2 = System.Security.Cryptography.X509Certificates.X509Certificate2;


/ </summary>
public static class CertGenerator
{
    const string X500DistinguishedNameValue = $"C=CN, O=BeyondDimension, OU=Technical Department, CN={CertificateConstants.RootCertificateName}";

    private static readonly Oid tlsServerOid = new("1.3.6.1.5.5.7.3.1");
    private static readonly Oid tlsClientOid = new("1.3.6.1.5.5.7.3.2");

    public const int KEY_SIZE_BITS = 2048;

    
/ </summary>
    
/ <param name="keySizeBits"></param>
    
/ <param name="notBefore">此证书被视为有效的最早日期和时间。通常是 UtcNow，加上或减去几秒钟</param>
    
/ <param name="notAfter">此证书不再被视为有效的日期和时间</param>
    
/ <param name="caPfxPath"></param>
    
/ <param name="password"></param>
    
/ <returns></returns>
    public static X509Certificate2 GenerateBySelfPfx(
        string? x509Name,
        DateTimeOffset notBefore,
        DateTimeOffset notAfter,
        string? caPfxPath,
        string? password = default)
    {
        var r = CreateCACertificate(new X500DistinguishedName(string.IsNullOrEmpty(x509Name) ? X500DistinguishedNameValue : x509Name), notBefore, notAfter);
        if (!string.IsNullOrEmpty(caPfxPath))
        {
            byte[] exported = r.Export(X509ContentType.Pkcs12, password);
            File.WriteAllBytes(caPfxPath, exported);
        }
        return r;
    }

    
/ </summary>
    
/ <param name="subjectName"></param>
    
/ <param name="notBefore"></param>
    
/ <param name="notAfter"></param>
    
/ <param name="rsaKeySizeInBits"></param>
    
/ <param name="pathLengthConstraint"></param>
    
/ <returns></returns>
    public static X509Certificate2 CreateCACertificate(
        X500DistinguishedName subjectName,
        DateTimeOffset notBefore,
        DateTimeOffset notAfter,
        int rsaKeySizeInBits = 2048,
        int pathLengthConstraint = 1)
    {
        using var rsa = RSA.Create(rsaKeySizeInBits);
        var request = new CertificateRequest(subjectName, rsa, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);

        var basicConstraints = new X509BasicConstraintsExtension(true, pathLengthConstraint > 0, pathLengthConstraint, true);
        request.CertificateExtensions.Add(basicConstraints);

        var keyUsage = new X509KeyUsageExtension(X509KeyUsageFlags.DigitalSignature | X509KeyUsageFlags.CrlSign | X509KeyUsageFlags.KeyCertSign, true);
        request.CertificateExtensions.Add(keyUsage);

        var oids = new OidCollection { tlsServerOid, tlsClientOid };
        var enhancedKeyUsage = new X509EnhancedKeyUsageExtension(oids, true);
        request.CertificateExtensions.Add(enhancedKeyUsage);

        var dnsBuilder = new SubjectAlternativeNameBuilder();
        dnsBuilder.Add(CertificateConstants.RootCertificateName);
        request.CertificateExtensions.Add(dnsBuilder.Build());

        var subjectKeyId = new X509SubjectKeyIdentifierExtension(request.PublicKey, false);
        request.CertificateExtensions.Add(subjectKeyId);

        return request.CreateSelfSigned(notBefore, notAfter);
    }

    
/ </summary>
    
/ <param name="issuerCertificate"></param>
    
/ <param name="subjectName"></param>
    
/ <param name="extraDnsNames"></param>
    
/ <param name="notBefore"></param>
    
/ <param name="notAfter"></param>
    
/ <param name="rsaKeySizeInBits"></param>
    
/ <returns></returns>
    public static X509Certificate2 CreateEndCertificate(
        X509Certificate2 issuerCertificate,
        X500DistinguishedName subjectName,
        IEnumerable<string>? extraDnsNames = default,
        DateTimeOffset? notBefore = default,
        DateTimeOffset? notAfter = default,
        int rsaKeySizeInBits = 2048)
    {
        using var rsa = RSA.Create(rsaKeySizeInBits);
        var request = new CertificateRequest(subjectName, rsa, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);

        var basicConstraints = new X509BasicConstraintsExtension(false, false, 0, true);
        request.CertificateExtensions.Add(basicConstraints);

        var keyUsage = new X509KeyUsageExtension(X509KeyUsageFlags.DigitalSignature | X509KeyUsageFlags.KeyEncipherment, true);
        request.CertificateExtensions.Add(keyUsage);

        var oids = new OidCollection { tlsServerOid, tlsClientOid };
        var enhancedKeyUsage = new X509EnhancedKeyUsageExtension(oids, true);
        request.CertificateExtensions.Add(enhancedKeyUsage);

        var authorityKeyId = GetAuthorityKeyIdentifierExtension(issuerCertificate);
        request.CertificateExtensions.Add(authorityKeyId);

        var subjectKeyId = new X509SubjectKeyIdentifierExtension(request.PublicKey, false);
        request.CertificateExtensions.Add(subjectKeyId);

        var dnsBuilder = new SubjectAlternativeNameBuilder();
        dnsBuilder.Add(subjectName.Name[3..]);

        if (extraDnsNames != null)
        {
            foreach (var dnsName in extraDnsNames)
            {
                dnsBuilder.Add(dnsName);
            }
        }

        var dnsNames = dnsBuilder.Build();
        request.CertificateExtensions.Add(dnsNames);

        if (notBefore == null || notBefore.Value < issuerCertificate.NotBefore)
        {
            notBefore = issuerCertificate.NotBefore;
        }

        if (notAfter == null || notAfter.Value > issuerCertificate.NotAfter)
        {
            notAfter = issuerCertificate.NotAfter;
        }

        var serialNumber = BitConverter.GetBytes(Random.Shared.NextInt64());
        using var certOnly = request.Create(issuerCertificate, notBefore.Value, notAfter.Value, serialNumber);
        return certOnly.CopyWithPrivateKey(rsa);
    }

    private static void Add(this SubjectAlternativeNameBuilder builder, string name)
    {
        if (IPAddress.TryParse(name, out var address))
        {
            builder.AddIpAddress(address);
        }
        else
        {
            try
            {
                builder.AddDnsName(name);
            }
            catch
            {
                /* name = Environment.MachineName
                 * System.ArgumentException: Decoded string is not a valid IDN name. (Parameter 'unicode')
                 * at System.Globalization.IdnMapping.IcuGetAsciiCore(String unicodeString, Char* unicode, Int32 count)
                 * at System.Globalization.IdnMapping.GetAscii(String unicode, Int32 index, Int32 count)
                 * at System.Security.Cryptography.X509Certificates.SubjectAlternativeNameBuilder.AddDnsName(String dnsName)
                 * at BD.WTTS.Services.Implementation.CertGenerator.Add(SubjectAlternativeNameBuilder builder, String name)
                 * at BD.WTTS.Services.Implementation.CertGenerator.CreateEndCertificate(X509Certificate2 issuerCertificate, X500DistinguishedName subjectName, IEnumerable`1 extraDnsNames, Nullable`1 notBefore, Nullable`1 notAfter, Int32 rsaKeySizeInBits)
                 */
            }
        }
    }

    private static X509Extension GetAuthorityKeyIdentifierExtension(X509Certificate2 certificate)
    {
        var extension = new X509SubjectKeyIdentifierExtension(certificate.PublicKey, false);
#if NET7_0_OR_GREATER
        return X509AuthorityKeyIdentifierExtension.CreateFromSubjectKeyIdentifier(extension);
#else
            var subjectKeyIdentifier = extension.RawData.AsSpan(2);
            var rawData = new byte[subjectKeyIdentifier.Length + 4];
            rawData[0] = 0x30;
            rawData[1] = 0x16;
            rawData[2] = 0x80;
            rawData[3] = 0x14;
            subjectKeyIdentifier.CopyTo(rawData);

            return new X509Extension("2.5.29.35", rawData, false);
#endif
    }
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\Certificate\CertGenerator.cs
NET
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\Certificate\CertificateManagerImpl.cs
/ <inheritdoc cref="ICertificateManager.RootCertificate"/>
    public X509Certificate2? RootCertificate { get; set; }

    public X509CertificatePackable RootCertificatePackable { get; set; }

    readonly object lock_RootCertificatePackable = new();

    byte[]? ICertificateManager.RootCertificatePackable
    {
        get
        {
            lock (lock_RootCertificatePackable)
            {
                RootCertificate ??= LoadRootCertificate();
            }
            return RootCertificate == default ? default : Serializable.SMP2(RootCertificatePackable);
        }
    }

    
/ <inheritdoc cref="ICertificateManager.PfxPassword"/>
    public byte[]? PfxPassword { get; set; }

    string? GetPfxPassword()
    {
        var pfxPassword_ = Interface.PfxPassword;
        var pfxPassword = pfxPassword_.Any_Nullable() ?
                 Encoding.UTF8.GetString(pfxPassword_!) :
                 null;
        return pfxPassword;
    }

    X509Certificate2? LoadRootCertificate()
    {
        try
        {
            ICertificateManager thiz = Interface;
            if (!File.Exists(thiz.PfxFilePath))
                return null;
            X509Certificate2 rootCert;
            try
            {
                RootCertificatePackable = X509CertificatePackable.CreateX509Certificate2(
                    thiz.PfxFilePath, GetPfxPassword(), X509KeyStorageFlags.Exportable);
                rootCert = RootCertificatePackable!;
                rootCert.ThrowIsNull();
            }
            catch (PlatformNotSupportedException)
            {
                
/github.com/dotnet/runtime/issues/71603
                return null;
            }
            catch (CryptographicException e)
            {
                if (e.InnerException is PlatformNotSupportedException) return null;
                throw;
            }
            if (rootCert.NotAfter <= DateTime.Now)
            {
                Log.Error(TAG, "Loaded root certificate has expired.");
                return null;
            }
            return rootCert;
        }
        catch (Exception ex)
        {
            Log.Error(TAG, ex, nameof(LoadRootCertificate));
            return null;
        }
    }

    [Obsolete("use ICertificateManager.Constants.TrustRootCertificate")]
    void SharedTrustRootCertificate()
    {
        if (RootCertificate == null)
        {
            throw new ApplicationException(
                "Could not install certificate as it is null or empty.");
        }

        using var store = new X509Store(StoreName.Root, StoreLocation.LocalMachine);
        try
        {
            store.Open(OpenFlags.ReadWrite);

            
/ <inheritdoc cref="ICertificateManager.GetCerFilePathGeneratedWhenNoFileExists"/>
    public string? GetCerFilePathGeneratedWhenNoFileExists()
    {
        var filePath = Interface.CerFilePath;
        lock (lockGenerateCertificate)
        {
            if (!File.Exists(filePath))
            {
                if (!GenerateCertificateUnlock(filePath))
                    return null;
            }
            else if (RootCertificate == null)
            {
                RootCertificate = LoadRootCertificate();
            }
            return filePath;
        }
    }

    
/ </summary>
    
/ <param name="filePath"></param>
    
/ <returns></returns>
    bool GenerateCertificateUnlock(string filePath)
    {
        var result = SharedCreateRootCertificate();
        if (!result || RootCertificate == null)
        {
            Log.Error(TAG, "Failed to create certificate");
            toast.Show(
                IPCToastService.ToastIcon.Error,
                IPCToastService.ToastText.CreateCertificateFaild);
            return false;
        }

        RootCertificate.SaveCerCertificateFile(filePath);

        return true;
    }

    
/ </summary>
    
/ <param name="filePath"></param>
    
/ <returns></returns>
    bool GenerateCertificate(string? filePath = null)
    {
        filePath ??= Interface.CerFilePath;
        lock (lockGenerateCertificate)
        {
            return GenerateCertificateUnlock(filePath);
        }
    }

    bool? ICertificateManager.GenerateCertificate()
    {
        return GenerateCertificate(null);
    }

    
/await platformService.RunShellAsync($"security add-trusted-cert -d -r trustRoot -k /Users/{Environment.UserName}/Library/Keychains/login.keychain-db \\\"{filePath}\\\"", true);
        if (state.HasValue && !state.Value)
            TrustRootCertificateMacOS();
    }

    [Obsolete("use ICertificateManager.Constants.TrustRootCertificate")]
    [SupportedOSPlatform("Linux")]
    void TrustRootCertificateLinux()
    {
        var filePath = GetCerFilePathGeneratedWhenNoFileExists();
        if (filePath == null) return;
        var state = platformService.TrustRootCertificateAsync(filePath);
        
/platformService.RunShell($"cp -f \"{crtFile}\" \"/usr/local/share/ca-certificates\" && sudo update-ca-certificates", true);
        
/ <inheritdoc cref="ICertificateManager.SetupRootCertificate"/>
    public bool SetupRootCertificate()
    {
        if (!GenerateCertificate())
            return false;
        var isRootCertificateInstalled = IsRootCertificateInstalled;
        if (!isRootCertificateInstalled)
        {
            TrustRootCertificate();
            isRootCertificateInstalled = IsRootCertificateInstalled;
            return isRootCertificateInstalled;
        }
        return true;
    }

    
/ <inheritdoc cref="ICertificateManager.DeleteRootCertificate"/>
    public bool DeleteRootCertificate()
    {
        
/ <inheritdoc cref="ICertificateManager.IsRootCertificateInstalled"/>
    public bool IsRootCertificateInstalled
    {
        get
        {
            var result = ICertificateManager.Constants.IsRootCertificateInstalled(this, platformService, RootCertificatePackable);
            return result;
        }
    }

    bool? ICertificateManager.IsRootCertificateInstalled2 => IsRootCertificateInstalled;

    
/ </summary>
    
/ <param name="certificate2"></param>
    
/ <returns></returns>
    bool IsCertificateInstalled(X509CertificatePackable packable)
    {
        var result = ICertificateManager.Constants.IsCertificateInstalled(platformService, packable);
        return result;
    }

    public string GetCertificateInfo()
    {
        var rootCert = RootCertificate;
        if (rootCert == null)
        {
            GenerateCertificate();
        }
        rootCert = RootCertificate;

        if (rootCert == null)
        {
            return "";
        }

        StringBuilder b = new();
        b.AppendLine("Subject：");
        b.AppendLine(rootCert.Subject);
        b.AppendLine("SerialNumber：");
        b.AppendLine(rootCert.SerialNumber);
        b.AppendLine("PeriodValidity：");
        b.Append(rootCert.GetEffectiveDateString());
        b.Append(" ~ ");
        b.Append(rootCert.GetExpirationDateString());
        b.AppendLine();
        b.AppendLine("SHA256：");
        b.AppendLine(rootCert.GetCertHashStringCompat(HashAlgorithmName.SHA256));
        b.AppendLine("SHA1：");
        b.AppendLine(rootCert.GetCertHashStringCompat(HashAlgorithmName.SHA1));

        return b.ToString();
    }
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\Certificate\CertificateManagerImpl.cs
DEBUG
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\FlowAnalyze\FlowAnalyzeDuplexPipe.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.FlowAnalyze/FlowAnalyzeDuplexPipe.cs


发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\FlowAnalyze\FlowAnalyzer.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.FlowAnalyze/FlowAnalyzer.cs


/ </summary>
    
/ <param name="flowType"></param>
    
/ <param name="length"></param>
    public void OnFlow(FlowType flowType, int length)
    {
        if (flowType == FlowType.Read)
            readQueues.OnFlow(length);
        else
            writeQueues.OnFlow(length);
    }

    
/ </summary>
    
/ <returns></returns>
    public FlowStatistics GetFlowStatistics() => new()
    {
        TotalRead = readQueues.TotalBytes,
        TotalWrite = writeQueues.TotalBytes,
        ReadRate = readQueues.GetRate(),
        WriteRate = writeQueues.GetRate(),
    };

    sealed class FlowQueues
    {
        int cleaning = 0;
        long totalBytes = 0L;

        record QueueItem(long Ticks, int Length);

        readonly ConcurrentQueue<QueueItem> queues = new();

        readonly int intervalSeconds;

        public long TotalBytes => totalBytes;

        public FlowQueues(int intervalSeconds)
        {
            this.intervalSeconds = intervalSeconds;
        }

        public void OnFlow(int length)
        {
            Interlocked.Add(ref totalBytes, length);
            CleanInvalidRecords();
            queues.Enqueue(new QueueItem(Environment.TickCount64, length));
        }

        public double GetRate()
        {
            CleanInvalidRecords();
            double intervalSecondsDouble = intervalSeconds;
            return queues.Sum(item => item.Length) / intervalSecondsDouble;
        }

        
/ </summary>
        
/ <returns></returns>
        bool CleanInvalidRecords()
        {
            if (Interlocked.CompareExchange(ref cleaning, 1, 0) != 0)
                return false;

            var ticks = Environment.TickCount64;
            while (queues.TryPeek(out var item))
                if (ticks - item.Ticks < intervalSeconds * 1000)
                    break;
                else
                    queues.TryDequeue(out _);

            Interlocked.Exchange(ref cleaning, 0);
            return true;
        }
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\FlowAnalyze\FlowAnalyzeStream.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.FlowAnalyze/FlowAnalyzeStream.cs


发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\Http\LifetimeHttpHandler.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.Http/LifetimeHttpHandler.cs


/ 具有生命周期的 <see cref="HttpMessageHandler"/>

/ </summary>
sealed class LifetimeHttpHandler : DelegatingHandler
{
    readonly Timer timer;

    public LifeTimeKey LifeTimeKey { get; }

    public LifetimeHttpHandler(IDomainResolver domainResolver, IWebProxy webProxy, LifeTimeKey lifeTimeKey, TimeSpan lifeTime, Action<LifetimeHttpHandler> deactivateAction)
    {
        LifeTimeKey = lifeTimeKey;
        InnerHandler = new ReverseProxyHttpClientHandler(lifeTimeKey.DomainConfig, domainResolver, webProxy);
        timer = new Timer(OnTimerCallback, deactivateAction, lifeTime, Timeout.InfiniteTimeSpan);
    }

    
/ <see cref="timer"/> 触发时
    
/ </summary>
    
/ <param name="state"></param>
    void OnTimerCallback(object? state)
    {
        timer.Dispose();
        ((Action<LifetimeHttpHandler>)state!)(this);
    }

    protected override void Dispose(bool disposing)
    {
        
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\Http\LifetimeHttpHandlerCleaner.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.Http/LifetimeHttpHandlerCleaner.cs


/ <see cref="LifetimeHttpHandler"/> 清理器

/ </summary>
sealed class LifetimeHttpHandlerCleaner
{
    
/ </summary>
    int trackingEntryCount = 0;

    
/ </summary>
    private readonly ConcurrentQueue<TrackingEntry> trackingEntries = new();

    
/ </summary>
    public TimeSpan CleanupInterval { get; set; } = TimeSpan.FromSeconds(10d);

    
/ 添加要清除的 <see cref="LifetimeHttpHandler"/>
    
/ </summary>
    
/ <param name="handler"></param>
    public void Add(LifetimeHttpHandler handler)
    {
        var entry = new TrackingEntry(handler);
        trackingEntries.Enqueue(entry);

        
/ </summary>
    async void StartCleanup()
    {
        await Task.Yield();
        while (Cleanup() == false)
        {
            await Task.Delay(CleanupInterval);
        }
    }

    
/ </summary>
    
/ <returns></returns>
    bool Cleanup()
    {
        var cleanCount = trackingEntries.Count;
        for (var i = 0; i < cleanCount; i++)
        {
            trackingEntries.TryDequeue(out var entry);
            Debug.Assert(entry != null);

            if (entry.CanDispose == false)
            {
                trackingEntries.Enqueue(entry);
                continue;
            }

            entry.Dispose();
            if (Interlocked.Decrement(ref trackingEntryCount) == 0)
            {
                return true;
            }
        }
        return false;
    }

    
/ </summary>
    sealed class TrackingEntry : IDisposable
    {
        
/ </summary>
        readonly IDisposable disposable;

        
/ </summary>
        readonly WeakReference weakReference;

        
/ </summary>
        
/ <returns></returns>
        public bool CanDispose => weakReference.IsAlive == false;

        
/ </summary>
        
/ <param name="handler">激活状态的httpHandler</param>
        public TrackingEntry(LifetimeHttpHandler handler)
        {
            disposable = handler.InnerHandler!;
            weakReference = new WeakReference(handler);
        }

        
/ </summary>
        public void Dispose()
        {
            try
            {
                disposable.Dispose();
            }
            catch (Exception)
            {
            }
        }
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\Http\LifeTimeKey.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.Http/LifeTimeKey.cs


/ </summary>
record LifeTimeKey
{
    
/ </summary>
    public string Domain { get; }

    
/ </summary>
    public IDomainConfig DomainConfig { get; }

    public LifeTimeKey(string domain, IDomainConfig domainConfig)
    {
        Domain = domain;
        DomainConfig = domainConfig;
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\Http\RequestContext.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.Http/RequestContext.cs


/ </summary>
sealed class RequestContext
{
    
/ </summary>
    public bool IsHttps { get; }

    
/ </summary>
    public TlsSniPattern TlsSniValue { get; }

    public RequestContext(bool isHttps, TlsSniPattern tlsSniValue)
    {
        IsHttps = isHttps;
        TlsSniValue = tlsSniValue;
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\Http\RequestContextExtensions.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.Http/RequestContextExtensions.cs


/ 设置 <see cref="RequestContext"/>
    
/ </summary>
    
/ <param name="httpRequestMessage"></param>
    
/ <param name="requestContext"></param>
    public static void SetRequestContext(this HttpRequestMessage httpRequestMessage, RequestContext requestContext)
    {
        httpRequestMessage.Options.Set(key, requestContext);
    }

    
/ 获取 <see cref="RequestContext"/>
    
/ </summary>
    
/ <param name="httpRequestMessage"></param>
    
/ <returns></returns>
    public static RequestContext GetRequestContext(this HttpRequestMessage httpRequestMessage)
    {
        return httpRequestMessage.Options.TryGetValue(key, out var requestContext)
            ? requestContext
            : throw new InvalidOperationException($"Please call first {nameof(SetRequestContext)}.");
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\Http\ReverseProxyHttpClient.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.Http/HttpClient.cs


/ </summary>
public class ReverseProxyHttpClient : HttpMessageInvoker
{
    
/ </summary>
    
/ </summary>
    
/ <param name="request"></param>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    
/ <exception cref="Exception"></exception>
    public override async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
    {
        
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\Http\ReverseProxyHttpClientHandler.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.Http/HttpClientHandler.cs


/ </summary>
    
/ <param name="request"></param>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    protected override async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
    {
        var uri = request.RequestUri ??
            throw new ApplicationException("The requested URI must be specified.");

        
/ 创建转发代理的 <see cref="HttpMessageHandler"/>
    
/ </summary>
    
/ <returns></returns>
    HttpHandlerType CreateSocketsHttpHandler() => new()
    {
        Proxy = HttpNoProxy.Instance,
        UseProxy = false,
        PreAuthenticate = false,
        UseCookies = false,
        AllowAutoRedirect = false,
        AutomaticDecompression = DecompressionMethods.None,
        ConnectCallback = ConnectCallback,
        EnableMultipleHttp2Connections = true,
        RequestHeaderEncodingSelector = (_, _) => Encoding.UTF8,
        ResponseHeaderEncodingSelector = (_, _) => Encoding.UTF8,
    };

    private async ValueTask<Stream> ConnectThroughProxyAsync(SocketsHttpConnectionContext context, CancellationToken cancellationToken)
    {
        if (context.InitialRequestMessage.RequestUri == null)
        {
            throw new InvalidOperationException("Request URI is null");
        }
        var proxyUri = webProxy.GetProxy(context.InitialRequestMessage.RequestUri);
        if (proxyUri == null)
        {
            throw new InvalidOperationException("Proxy URI is null");
        }

        var proxyEndPoint = new DnsEndPoint(proxyUri.Host, proxyUri.Port);
        var socket = new Socket(SocketType.Stream, ProtocolType.Tcp);
        await socket.ConnectAsync(proxyEndPoint, cancellationToken);

        var stream = new NetworkStream(socket, ownsSocket: true);

        
/ 确定代理类型
        var proxyType = DetermineProxyType(proxyUri);

        switch (proxyType)
        {
            case ExternalProxyType.Http:
                await ConnectHttpProxy(stream, context, cancellationToken);
                break;
            case ExternalProxyType.Socks4:
                await ConnectSocks4Proxy(stream, context, cancellationToken);
                break;
            case ExternalProxyType.Socks5:
                await ConnectSocks5Proxy(stream, context, cancellationToken);
                break;
        }

        if (context.InitialRequestMessage.RequestUri.Scheme == "https" || context.InitialRequestMessage.RequestUri.Port == 443)
        {
            var requestContext = context.InitialRequestMessage.GetRequestContext();
            var tlsSniValue = requestContext.TlsSniValue;
            var sslStream = new SslStream(stream, leaveInnerStreamOpen: false);
            await sslStream.AuthenticateAsClientAsync(new SslClientAuthenticationOptions
            {
                TargetHost = tlsSniValue.Value,
                RemoteCertificateValidationCallback = (sender, cert, chain, errors) => true,
            }, cancellationToken);

            return sslStream;
        }

        return stream;
    }

    private ExternalProxyType DetermineProxyType(Uri proxyUri)
    {
        return proxyUri.Scheme.ToLower() switch
        {
            "socks4" => ExternalProxyType.Socks4,
            "socks5" => ExternalProxyType.Socks5,
            _ => ExternalProxyType.Http
        };

        throw new NotImplementedException("Proxy type determination needs to be implemented");
    }

    private async Task ConnectHttpProxy(NetworkStream stream, SocketsHttpConnectionContext context, CancellationToken cancellationToken)
    {
        var credentials = webProxy.Credentials as NetworkCredential;
        var authHeader = credentials != null
            ? $"Proxy-Authorization: Basic {Convert.ToBase64String(Encoding.ASCII.GetBytes($"{credentials.UserName}:{credentials.Password}"))}\r\n"
            : string.Empty;

        var connectRequest = $"CONNECT {context.DnsEndPoint.Host}:{context.DnsEndPoint.Port} HTTP/1.1\r\n" +
                             $"Host: {context.DnsEndPoint.Host}:{context.DnsEndPoint.Port}\r\n" +
                             $"{authHeader}\r\n";

        var connectBytes = Encoding.ASCII.GetBytes(connectRequest);
        await stream.WriteAsync(connectBytes, cancellationToken);

        var buffer = new byte[1024];
        var bytesRead = await stream.ReadAsync(buffer, cancellationToken);
        var response = Encoding.ASCII.GetString(buffer, 0, bytesRead);

        if (!response.StartsWith("HTTP/1.1 200"))
        {
            throw new Exception($"Proxy connection failed: {response}");
        }
    }

    private async Task ConnectSocks4Proxy(NetworkStream stream, SocketsHttpConnectionContext context, CancellationToken cancellationToken)
    {
        var credentials = webProxy.Credentials as NetworkCredential;
        var userId = credentials?.UserName ?? string.Empty;

        var destinationAddress = await GetIPEndPointsAsync(context.DnsEndPoint, cancellationToken).FirstAsync();
        var portBytes = BitConverter.GetBytes((ushort)context.DnsEndPoint.Port);
        if (BitConverter.IsLittleEndian) Array.Reverse(portBytes);

        var request = new byte[] { 0x04, 0x01 }
            .Concat(portBytes)
            .Concat(destinationAddress.Address.GetAddressBytes())
            .Concat(Encoding.ASCII.GetBytes(userId))
            .Concat(new byte[] { 0x00 })
            .ToArray();

        await stream.WriteAsync(request, cancellationToken);

        var response = new byte[8];
        await stream.ReadAsync(response, cancellationToken);

        if (response[1] != 0x5A)
        {
            throw new Exception($"SOCKS4 proxy connection failed: {response[1]}");
        }
    }

    private async Task ConnectSocks5Proxy(NetworkStream stream, SocketsHttpConnectionContext context, CancellationToken cancellationToken)
    {
        var credentials = webProxy.Credentials as NetworkCredential;

        
/ </summary>
    
/ <param name="context"></param>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    async ValueTask<Stream> ConnectCallback(SocketsHttpConnectionContext context, CancellationToken cancellationToken)
    {
        if (webProxy != null && !HttpNoProxy.IsNoProxy(webProxy))
        {
            return await ConnectThroughProxyAsync(context, cancellationToken);
        }

        var innerExceptions = new List<Exception>();
        var ipEndPoints = GetIPEndPointsAsync(context.DnsEndPoint, cancellationToken);

        await foreach (var ipEndPoint in ipEndPoints)
        {
            try
            {
                using var timeoutTokenSource = new CancellationTokenSource(connectTimeout);
                using var linkedTokenSource = CancellationTokenSource.CreateLinkedTokenSource(timeoutTokenSource.Token, cancellationToken);
                return await ConnectAsync(context, ipEndPoint, linkedTokenSource.Token);
            }
            catch (OperationCanceledException)
            {
                cancellationToken.ThrowIfCancellationRequested();
                innerExceptions.Add(new TimeoutException(
                    $"HTTP connection to {ipEndPoint.Address} timed out."));
            }
            catch (Exception ex)
            {
                innerExceptions.Add(ex);
            }
        }

        throw new AggregateException("Could not find any IP that can be successfully connected.", innerExceptions);
    }

    
/ </summary>
    
/ <param name="context"></param>
    
/ <param name="ipEndPoint"></param>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    async ValueTask<Stream> ConnectAsync(SocketsHttpConnectionContext context, IPEndPoint ipEndPoint, CancellationToken cancellationToken)
    {
        var socket = new Socket(ipEndPoint.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
        await socket.ConnectAsync(ipEndPoint, cancellationToken);
        var stream = new NetworkStream(socket, ownsSocket: true);

        var requestContext = context.InitialRequestMessage.GetRequestContext();
        if (requestContext.IsHttps == false)
        {
            return stream;
        }
        var tlsSniValue = requestContext.TlsSniValue.WithIPAddress(ipEndPoint.Address);
        var sslStream = new SslStream(stream, leaveInnerStreamOpen: false);
        await sslStream.AuthenticateAsClientAsync(new SslClientAuthenticationOptions
        {
            TargetHost = tlsSniValue.Value,
            RemoteCertificateValidationCallback = ValidateServerCertificate
        }, cancellationToken);

        return sslStream;

        
/ 解析为 <see cref="IPEndPoint"/>
    
/ </summary>
    
/ <param name="dnsEndPoint"></param>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    async IAsyncEnumerable<IPEndPoint> GetIPEndPointsAsync(DnsEndPoint dnsEndPoint, [EnumeratorCancellation] CancellationToken cancellationToken)
    {
        if (IPAddress.TryParse(dnsEndPoint.Host, out var address))
        {
            yield return new IPEndPoint(address, dnsEndPoint.Port);
        }
        else
        {
            if (domainConfig.IPAddress != null)
            {
                yield return new IPEndPoint(domainConfig.IPAddress, dnsEndPoint.Port);
            }

            if (domainConfig.ForwardDestination != null)
            {
                await foreach (var item in domainResolver.ResolveAsync(new DnsEndPoint(domainConfig.ForwardDestination, dnsEndPoint.Port), cancellationToken))
                {
                    yield return new IPEndPoint(item, dnsEndPoint.Port);
                }
            }

            await foreach (var item in domainResolver.ResolveAsync(dnsEndPoint, cancellationToken))
            {
                yield return new IPEndPoint(item, dnsEndPoint.Port);
            }
        }
    }

    
/ </summary>
    
/ <param name="cert"></param>
    
/ <returns></returns>
    static IEnumerable<string> ReadDnsNames(X509Certificate? cert)
    {
        if (cert is X509Certificate2 x509)
        {
            var extension = x509.Extensions
                .OfType<X509SubjectAlternativeNameExtension>().FirstOrDefault();
            if (extension != null)
            {
                return extension.EnumerateDnsNames();
            }
        }
        return Array.Empty<string>();

        
/ </summary>
    
/ <param name="dnsName"></param>
    
/ <param name="domain"></param>
    
/ <returns></returns>
    static bool IsMatch(string dnsName, string? domain)
    {
        if (domain == null)
        {
            return false;
        }
        if (dnsName == domain)
        {
            return true;
        }
        if (dnsName[0] == '*')
        {
            return domain.EndsWith(dnsName[1..]);
        }
        return false;
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\HttpServer\GithubGitReverseProxyHandler.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.HttpServer/GithubGitReverseProxyHandler.cs


/ </summary>
sealed class GithubGitReverseProxyHandler : TcpReverseProxyHandler
{
    public GithubGitReverseProxyHandler(IDomainResolver domainResolver)
        : base(domainResolver, new("github.com", IReverseProxyConfig.GitPort))
    {

    }
}
#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\HttpServer\GithubGitReverseProxyHandler.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\HttpServer\GithubSshReverseProxyHandler.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.HttpServer/GithubSshReverseProxyHandler.cs


/ </summary>
sealed class GithubSshReverseProxyHandler : TcpReverseProxyHandler
{
    public GithubSshReverseProxyHandler(IDomainResolver domainResolver)
        : base(domainResolver, new("github.com", IReverseProxyConfig.SshPort))
    {

    }
}
#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\HttpServer\GithubSshReverseProxyHandler.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\HttpServer\TcpReverseProxyHandler.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.HttpServer/TcpReverseProxyHandler.cs


/ </summary>
abstract class TcpReverseProxyHandler : ConnectionHandler
{
    readonly IDomainResolver domainResolver;
    readonly DnsEndPoint endPoint;
    readonly TimeSpan connectTimeout = TimeSpan.FromSeconds(10d);

    public TcpReverseProxyHandler(IDomainResolver domainResolver, DnsEndPoint endPoint)
    {
        this.domainResolver = domainResolver;
        this.endPoint = endPoint;
    }

    
/ </summary>
    
/ <param name="context"></param>
    
/ <returns></returns>
    public override async Task OnConnectedAsync(ConnectionContext context)
    {
        var cancellationToken = context.ConnectionClosed;
        using var connection = await CreateConnectionAsync(cancellationToken);
        var task1 = connection.CopyToAsync(context.Transport.Output, cancellationToken);
        var task2 = context.Transport.Input.CopyToAsync(connection, cancellationToken);
        await Task.WhenAny(task1, task2);
    }

    
/ </summary>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    
/ <exception cref="AggregateException"></exception>
    private async Task<Stream> CreateConnectionAsync(CancellationToken cancellationToken)
    {
        var innerExceptions = new List<Exception>();
        await foreach (var address in domainResolver.ResolveAsync(endPoint, cancellationToken))
        {
            var socket = new Socket(address.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
            try
            {
                using var timeoutTokenSource = new CancellationTokenSource(connectTimeout);
                using var linkedTokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, timeoutTokenSource.Token);
                await socket.ConnectAsync(address, endPoint.Port, linkedTokenSource.Token);
                return new NetworkStream(socket, ownsSocket: false);
            }
            catch (Exception ex)
            {
                socket.Dispose();
                cancellationToken.ThrowIfCancellationRequested();
                innerExceptions.Add(ex);
            }
        }
        throw new AggregateException(
            $"Unable to connect to {endPoint.Host}:{endPoint.Port}.", innerExceptions);
    }
}
#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\HttpServer\TcpReverseProxyHandler.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\HttpServer\Certificates\CertService.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.HttpServer/CertService.cs


/ </summary>
sealed class CertService
{
    readonly IMemoryCache serverCertCache;
    readonly ILogger<CertService> logger;
    readonly IReverseProxyConfig reverseProxyConfig;
    private X509Certificate2? caCert;

    ReverseProxyServiceImpl ReverseProxyService => reverseProxyConfig.Service;

    
/ </summary>
    public string CaCerFilePath => ((ICertificateManager)ReverseProxyService.CertificateManager).CerFilePath;

    
/ </summary>
    public string CaPfxFilePath => ((ICertificateManager)ReverseProxyService.CertificateManager).PfxFilePath;

    public CertService(
        IMemoryCache serverCertCache,
        ILogger<CertService> logger,
        IReverseProxyConfig reverseProxyConfig)
    {
        this.serverCertCache = serverCertCache;
        this.logger = logger;
        this.reverseProxyConfig = reverseProxyConfig;
    }

    
/ </summary>
    
/ <param name="value">是否验证</param>
    
/ <returns></returns>
    public static bool GitConfigSslverify(bool value)
    {
        try
        {
            Process.Start(new ProcessStartInfo
            {
                FileName = "git",
                Arguments = $"config --global http.sslverify {value.ToLowerString()}",
                UseShellExecute = true,
                CreateNoWindow = true,
                WindowStyle = ProcessWindowStyle.Hidden,
            });
            return true;
        }
        catch (Exception)
        {
            return false;
        }
    }

    
/ </summary>
    
/ <param name="domain"></param> 
    
/ <returns></returns>
    public X509Certificate2? GetOrCreateServerCert(string? domain)
    {
        caCert ??= new X509Certificate2(fileName: CaPfxFilePath, password: default(string));

        var key = $"{nameof(CertService)}:{domain}";
        return serverCertCache.GetOrCreate(key, GetOrCreateCert);

        
/ </summary>
    
/ <param name="domain"></param>
    
/ <returns></returns>
    static IEnumerable<string> GetDomains()
    {
        yield return Environment.MachineName;
        yield return IPAddress.Loopback.ToString();
        yield return IPAddress.IPv6Loopback.ToString();
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\HttpServer\Middleware\FakeTlsConnectionFeature.cs
/github.com/dotnetcore/FastGithub/blob/58f79ddc19410c92b18e8d4de1c4b61376e97be7/FastGithub.HttpServer/TlsMiddlewares/FakeTlsConnectionFeature.cs


发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\HttpServer\Middleware\HttpLocalRequestMiddleware.cs
/ </summary>
sealed class HttpLocalRequestMiddleware
{
    readonly IReverseProxyConfig reverseProxyConfig;
    readonly CookieHttpClient cookieHttpClient;

    HttpClient HttpClient => cookieHttpClient.HttpClient;

    public HttpLocalRequestMiddleware(
        IReverseProxyConfig reverseProxyConfig,
        CookieHttpClient cookieHttpClient)
    {
        this.reverseProxyConfig = reverseProxyConfig;
        this.cookieHttpClient = cookieHttpClient;
    }

    
/ </summary>
    
/ <param name="context"></param>
    
/ <param name="next"></param>
    
/ <returns></returns>
    public async Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        if (HttpMethods.IsOptions(context.Request.Method) && context.Request.Headers.ContainsKey("Access-Control-Request-Private-Network"))
        {
            
/wicg.github.io/private-network-access/
            context.Response.Headers["Access-Control-Allow-Private-Network"] = "true";
        }

        if (context.Request.Host.Host.Equals(IReverseProxyService.Constants.LocalDomain, StringComparison.OrdinalIgnoreCase))
        {
            if (HttpMethods.IsOptions(context.Request.Method))
            {
                context.Response.Headers.AccessControlAllowOrigin = context.Request.Headers.Origin.Count == 0 ? "*" : context.Request.Headers.Origin;
                context.Response.Headers.AccessControlAllowHeaders = "*";
                context.Response.Headers.AccessControlAllowMethods = "*";
                context.Response.Headers.AccessControlAllowCredentials = "true";

                await context.Response.WriteAsync(string.Empty);
                return;
            }

            var type = context.Request.Headers["requestType"];
            switch (type)
            {
                case "status":
                    context.Response.StatusCode = StatusCodes.Status200OK;
                    await context.Response.WriteAsync("OK");
                    return;
                case "xhr":
                    await HandleHttpRequestAsync(context);
                    return;
                default: 
/默认处理脚本匹配
                    if (!int.TryParse(context.Request.Path.Value?.Trim('/'), out var lid) && lid <= 0)
                    {
                        await Handle404NotFoundAsync(context);
                        return;
                    }
                    
/ TODO: Scripts
                    if (reverseProxyConfig.TryGetScriptContent(lid, out string? content))
                    {
                        if (string.IsNullOrEmpty(content))
                        {
                            await Handle404NotFoundAsync(context);
                            return;
                        }
                        context.Response.Headers.ContentType = "text/javascript;charset=UTF-8";
                        await context.Response.WriteAsync(content);
                        return;
                    }
                    else
                    {
                        await Handle404NotFoundAsync(context);
                        return;
                    }
            }
        }

        await next(context);
    }

    
/ </summary>
    
/ <param name="context"></param>
    
/ <returns></returns>
    async Task HandleHttpRequestAsync(HttpContext context)
    {
        try
        {
            var url = context.Request.QueryString.Value;
            if (string.IsNullOrEmpty(url))
                return;
            url = HttpUtility.UrlDecode(url.Replace("?request=", ""));
            Uri requestUri;
            try
            {
                requestUri = new Uri(url);
            }
            catch
            {
                return;
            }

            var method = context.Request.Method;
            var methodObj = method switch
            {
                "GET" => HttpMethod.Get,
                "PUT" => HttpMethod.Put,
                "POST" => HttpMethod.Post,
                "DELETE" => HttpMethod.Delete,
                "HEAD" => HttpMethod.Head,
                "OPTIONS" => HttpMethod.Options,
                "TRACE" => HttpMethod.Trace,
                "PATCH" => HttpMethod.Patch,
                "CONNECT" => HttpMethod.Connect,
                _ => TryParse(method),
            };
            if (methodObj == null)
                return;

            static HttpMethod? TryParse(string method)
            {
                try
                {
                    return new HttpMethod(method.ToUpperInvariant());
                }
                catch
                {

                }
                return null;
            }

            context.Response.Headers.AccessControlAllowOrigin = context.Request.Headers.Origin.Count == 0 ? "*" : context.Request.Headers.Origin;
            context.Response.Headers.AccessControlAllowHeaders = "*";
            context.Response.Headers.AccessControlAllowMethods = "*";
            context.Response.Headers.AccessControlAllowCredentials = "true";

            
/ </summary>
    
/ <param name="context"></param>
    
/ <returns></returns>
    static Task Handle404NotFoundAsync(HttpContext context)
        => HandleStatusCodeAsync(context, StatusCodes.Status404NotFound);
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\HttpServer\Middleware\HttpProxyMiddleware.cs
/github.com/dotnetcore/FastGithub/blob/58f79ddc19410c92b18e8d4de1c4b61376e97be7/FastGithub.HttpServer/TcpMiddlewares/HttpProxyMiddleware.cs


/ </summary>
sealed class HttpProxyMiddleware
{
    readonly HttpParser<HttpRequestHandler> httpParser = new();

    
/ </summary>
    
/ <param name="next"></param>
    
/ <param name="context"></param>
    
/ <returns></returns>
    public async Task InvokeAsync(ConnectionDelegate next, ConnectionContext context)
    {
        var input = context.Transport.Input;
        var output = context.Transport.Output;
        var request = new HttpRequestHandler();

        while (context.ConnectionClosed.IsCancellationRequested == false)
        {
            var result = await input.ReadAsync();
            if (result.IsCanceled)
            {
                break;
            }

            try
            {
                if (ParseRequest(result, request, out var consumed))
                {
                    if (request.ProxyProtocol == ProxyProtocol.TunnelProxy)
                    {
                        input.AdvanceTo(consumed);
                        ReadOnlyMemory<byte> http200 = "HTTP/1.1 200 Connection Established\r\n\r\n"u8.ToArray();
                        await output.WriteAsync(http200, context.ConnectionClosed);
                    }
                    else
                    {
                        input.AdvanceTo(result.Buffer.Start);
                    }

                    context.Features.Set<IHttpProxyFeature>(request);
                    await next(context);

                    break;
                }
                else
                {
                    input.AdvanceTo(result.Buffer.Start, result.Buffer.End);
                }

                if (result.IsCompleted)
                {
                    break;
                }
            }
            catch (Exception)
            {
                ReadOnlyMemory<byte> http400 = "HTTP/1.1 400 Bad Request\r\n\r\n"u8.ToArray();
                await output.WriteAsync(http400, context.ConnectionClosed);
                break;
            }
        }
    }

    
/ </summary>
    
/ <param name="result"></param>
    
/ <param name="requestHandler"></param>
    
/ <param name="consumed"></param>
    
/ <returns></returns>
    private bool ParseRequest(ReadResult result, HttpRequestHandler request, out SequencePosition consumed)
    {
        var reader = new SequenceReader<byte>(result.Buffer);
        if (httpParser.ParseRequestLine(request, ref reader) &&
            httpParser.ParseHeaders(request, ref reader))
        {
            consumed = reader.Position;
            return true;
        }
        else
        {
            consumed = default;
            return false;
        }
    }

    
/ </summary>
    private sealed class HttpRequestHandler : IHttpRequestLineHandler, IHttpHeadersHandler, IHttpProxyFeature
    {
        private AspNetCoreHttpMethod method;

        public HostString ProxyHost { get; private set; }

        public ProxyProtocol ProxyProtocol
        {
            get
            {
                if (ProxyHost.HasValue == false)
                {
                    return ProxyProtocol.None;
                }
                if (method == AspNetCoreHttpMethod.Connect)
                {
                    return ProxyProtocol.TunnelProxy;
                }
                return ProxyProtocol.HttpProxy;
            }
        }

        void IHttpRequestLineHandler.OnStartLine(HttpVersionAndMethod versionAndMethod, TargetOffsetPathLength targetPath, Span<byte> startLine)
        {
            method = versionAndMethod.Method;
            var host = Encoding.UTF8.GetString(startLine.Slice(targetPath.Offset, targetPath.Length));
            if (versionAndMethod.Method == AspNetCoreHttpMethod.Connect)
            {
                ProxyHost = HostString.FromUriComponent(host);
            }
            else if (Uri.TryCreate(host, UriKind.Absolute, out var uri))
            {
                ProxyHost = HostString.FromUriComponent(uri);
            }
        }

        void IHttpHeadersHandler.OnHeader(ReadOnlySpan<byte> name, ReadOnlySpan<byte> value)
        {
        }

        void IHttpHeadersHandler.OnHeadersComplete(bool endStream)
        {
        }

        void IHttpHeadersHandler.OnStaticIndexedHeader(int index)
        {
        }

        void IHttpHeadersHandler.OnStaticIndexedHeader(int index, ReadOnlySpan<byte> value)
        {
        }
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\HttpServer\Middleware\HttpProxyPacMiddleware.cs
/ </summary>
sealed class HttpProxyPacMiddleware
{
    readonly IReverseProxyConfig reverseProxyConfig;

    public HttpProxyPacMiddleware(IReverseProxyConfig reverseProxyConfig)
    {
        this.reverseProxyConfig = reverseProxyConfig;
    }

    
/ </summary>
    
/ <param name="context"></param>
    
/ <param name="next"></param>
    
/ <returns></returns>
    public async Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        
/ Http 请求经过了 HttpProxy 中间件
        var proxyFeature = context.Features.Get<IHttpProxyFeature>();
        if (proxyFeature != null && proxyFeature.ProxyProtocol == ProxyProtocol.None)
        {
            var proxyPac = CreateProxyPac(context.Request.Host);
            context.Response.ContentType = "application/x-ns-proxy-autoconfig";
            context.Response.Headers.Add("Content-Disposition", $"attachment;filename=proxy.pac");
            await context.Response.WriteAsync(proxyPac);
        }
        else
        {
            await next(context);
        }
    }

    
/ </summary>
    
/ <param name="proxyHost"></param>
    
/ <returns></returns>
    string CreateProxyPac(HostString proxyHost)
    {
        var buidler = new StringBuilder();
        buidler.AppendLine("function FindProxyForURL(url, host){");
        buidler.AppendLine($"    var pac = 'PROXY {proxyHost}';");

        foreach (var domains in reverseProxyConfig.GetDomainPatterns())
            foreach (var domain in domains.ToString().Split(DomainPattern.GeneralSeparator))
                if (!string.IsNullOrWhiteSpace(domain))
                    buidler.AppendLine($"    if (shExpMatch(host, '{domain}')) return pac;");

        buidler.AppendLine("    return 'DIRECT';");
        buidler.AppendLine("}");
        return buidler.ToString();
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\HttpServer\Middleware\HttpReverseProxyMiddleware.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.HttpServer/HttpReverseProxyMiddleware.cs

using Microsoft.AspNetCore.Http;
using Yarp.ReverseProxy.Forwarder;


/ </summary>
sealed partial class HttpReverseProxyMiddleware
{
    static readonly IDomainConfig defaultDomainConfig = new DomainConfig() { TlsSni = true, };

    readonly IHttpForwarder httpForwarder;
    readonly IReverseProxyHttpClientFactory httpClientFactory;
    readonly IReverseProxyConfig reverseProxyConfig;
    readonly ILogger<HttpReverseProxyMiddleware> logger;

    public HttpReverseProxyMiddleware(
        IHttpForwarder httpForwarder,
        IReverseProxyHttpClientFactory httpClientFactory,
        IReverseProxyConfig reverseProxyConfig,
        ILogger<HttpReverseProxyMiddleware> logger)
    {
        this.httpForwarder = httpForwarder;
        this.httpClientFactory = httpClientFactory;
        this.reverseProxyConfig = reverseProxyConfig;
        this.logger = logger;
    }

    
/ </summary>
    
/ <param name="context"></param>
    
/ <param name="next"></param>
    
/ <returns></returns>
    public async Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        var url = context.Request.GetDisplayUrl();
        
/var url = context.Request.GetDisplayUrl().Remove(0, context.Request.Scheme.Length + 3);

        var isScriptInject = reverseProxyConfig.TryGetScriptConfig(url, out var scriptConfigs);

        var originalBody = context.Response.Body;
        MemoryStream? memoryStream = null;

        if (isScriptInject)
        {
            memoryStream = new MemoryStream();
            context.Response.Body = memoryStream;
        }

        if (TryGetDomainConfig(url.Remove(0, context.Request.Scheme.Length + 3), out var domainConfig) == false)
        {
            if (reverseProxyConfig.Service.TwoLevelAgentEnable)
            {
                var httpClient = httpClientFactory.CreateHttpClient("GlobalProxy", defaultDomainConfig);
                var destinationPrefix = GetDestinationPrefix(context.Request.Scheme, context.Request.Host, null);
                var forwarderRequestConfig = new ForwarderRequestConfig()
                {
                    Version = context.Request.Protocol switch
                    {
                        var protocol when protocol.StartsWith("HTTP/2") => System.Net.HttpVersion.Version20,
                        var protocol when protocol.StartsWith("HTTP/3") => System.Net.HttpVersion.Version30,
                        _ => System.Net.HttpVersion.Version11,
                    },
                };
                var error = await httpForwarder.SendAsync(context, destinationPrefix, httpClient, forwarderRequestConfig, HttpTransformer.Empty);
                if (error != ForwarderError.None)
                {
                    await HandleErrorAsync(context, error);
                }
            }
            else
            {
                await next(context);
            }
            return;
        }

        if (domainConfig == defaultDomainConfig &&
            !reverseProxyConfig.Service.OnlyEnableProxyScript)
        {
            
/" + context.Request.Host.Host + context.Request.RawUrl());
                return;
            }

            var destination = domainConfig.Destination;
            if (domainConfig.Destination?.AbsoluteUri.Contains("@") == true)
            {
                var newUrl = domainConfig.Destination.AbsoluteUri.Replace("@domain", context.Request.Host.Host);
                newUrl = newUrl.Replace("@uri", context.Request.RawUrl());
                destination = new Uri(newUrl);
            }

            var destinationPrefix = GetDestinationPrefix(context.Request.Scheme, context.Request.Host, destination);
            var httpClient = httpClientFactory.CreateHttpClient(context.Request.Host.Host, domainConfig);
            if (!string.IsNullOrEmpty(domainConfig.UserAgent))
            {
                context.Request.Headers.UserAgent = domainConfig.UserAgent.Replace("${origin}", context.Request.Headers.UserAgent, StringComparison.OrdinalIgnoreCase);
            }

            var forwarderRequestConfig = new ForwarderRequestConfig()
            {
                Version = context.Request.Protocol switch
                {
                    var protocol when protocol.StartsWith("HTTP/2") => System.Net.HttpVersion.Version20,
                    var protocol when protocol.StartsWith("HTTP/3") => System.Net.HttpVersion.Version30,
                    _ => System.Net.HttpVersion.Version11,
                },
            };

            if (domainConfig.IsServerSideProxy)
            {
                SetWattHeaders(context, reverseProxyConfig.Service.ServerSideProxyToken);
            }

            var error = await httpForwarder.SendAsync(context, destinationPrefix, httpClient, forwarderRequestConfig, HttpTransformer.Empty);

            if (error != ForwarderError.None)
            {
                await HandleErrorAsync(context, error);
            }
            else if (isScriptInject)
            {
                await HandleScriptInject(context, scriptConfigs, memoryStream!, originalBody!);
            }
        }
        else
        {
            context.Response.StatusCode = (int)domainConfig.Response.StatusCode;
            context.Response.ContentType = domainConfig.Response.ContentType;
            if (domainConfig.Response.ContentValue != null)
            {
                await context.Response.WriteAsync(domainConfig.Response.ContentValue);
            }
        }
    }

    
/ </summary>
    
/ <param name="url"></param>
    
/ <param name="domainConfig"></param>
    
/ <returns></returns>
    static IDomainConfig RecursionMatchDomainConfig(string url, IDomainConfig domainConfig)
    {
        if (domainConfig.Items.Any_Nullable())
        {
            var item = domainConfig.Items.FirstOrDefault(s => s.Key.IsMatch(url)).Value;
            if (item != null)
                return RecursionMatchDomainConfig(url, item);
        }
        return domainConfig;
    }

    bool TryGetDomainConfig(string uri, [MaybeNullWhen(false)] out IDomainConfig domainConfig)
    {
        domainConfig = null;

        if (!reverseProxyConfig.Service.OnlyEnableProxyScript && reverseProxyConfig.TryGetDomainConfig(uri, out domainConfig) == true)
        {
            return true;
        }

        var host = new UriBuilder(uri).Host;
        
/ </summary>
    
/ <param name="host"></param>
    
/ <returns></returns>
    static bool IsDomain(string host) => !IPAddress.TryParse(host, out _) && host.Contains('.');

    
/ </summary>
    
/ <param name="scheme"></param>
    
/ <param name="host"></param>
    
/ <param name="destination"></param>
    
/ <returns></returns>
    string GetDestinationPrefix(string scheme, HostString host, Uri? destination)
    {
        var defaultValue = $"{scheme}:
/{host}/";
        if (destination == null)
        {
            return defaultValue;
        }

        var baseUri = new Uri(defaultValue);
        var result = new Uri(baseUri, destination).ToString();
        logger.LogInformation("{defaultValue} => {result}", defaultValue, result);
        return result;
    }

    
/ </summary>
    
/ <param name="context"></param>
    
/ <param name="error"></param>
    
/ <returns></returns>
    static async Task HandleErrorAsync(HttpContext context, ForwarderError error)
    {
        await context.Response.WriteAsync($"{error}:{context.GetForwarderErrorFeature()?.Exception?.Message}");
    }

    
/ </summary>
    
/ <param name="context"></param>
    
/ <param name="scripts"></param>
    
/ <param name="body"></param>
    
/ <param name="originalBody"></param>
    
/ <returns></returns>
    async Task HandleScriptInject(HttpContext context, IEnumerable<IScriptConfig>? scripts, MemoryStream body, Stream originalBody)
    {
        async Task ResetBody()
        {
            body.Seek(0, SeekOrigin.Begin);
            context.Response.ContentLength = body.Length;
            await body.CopyToAsync(originalBody);
            context.Response.Body = originalBody;
        }

        if (!scripts.Any_Nullable() ||
            context.Request.Method != HttpMethods.Get ||
            context.Response.StatusCode != StatusCodes.Status200OK ||
            context.Response.ContentType == null ||
            !context.Response.ContentType.Contains("text/html", StringComparison.OrdinalIgnoreCase))
        {
            await ResetBody();
            return;
        }

        if (IReverseProxyService.Constants.Instance.IsOnlyWorkSteamBrowser && context.Request.UserAgent()?.Contains("Valve Steam") == false)
        {
            await ResetBody();
            return;
        }

        if (!string.IsNullOrEmpty(context.Response.Headers.ContentSecurityPolicy))
        {
            
/developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding
                var contentCompression = context.Response.Headers.ContentEncoding.ToString().ToLowerInvariant();
                using Stream bodyDecompress = GetStreamByContentCompression(body, contentCompression, CompressionMode.Decompress, true) ?? body;

                var buffer_ = await bodyDecompress.ToByteArrayAsync();

                
/github.com/dotnet/runtime/blob/v6.0.6/src/libraries/System.Net.Http/src/System/Net/Http/HttpContent.cs#L175
                Encoding? encoding = context.Response.ContentTextEncoding();
                if (encoding == null)
                {
                    if (!TryDetectEncoding(buffer_, out encoding))
                    {
                        encoding = Encoding.UTF8;
                    }
                }

                if (FindScriptInjectInsertPosition(buffer_, encoding, out var buffer, out var position))
                {
                    using var bodyWriter = new MemoryStream();
                    using Stream? bodyCompress = GetStreamByContentCompression(bodyWriter, contentCompression, CompressionMode.Compress, true);

                    if (bodyCompress != null)
                    {
                        await WriteAsync(bodyCompress);
                        await bodyCompress.DisposeAsync(); 
/#endif
                        await bodyCoreWriter.WriteAsync(html_start);
                        ReadOnlyMemory<byte> script_xml_start = "<script type=\"text/javascript\" src=\"https:
/local.steampp.net/"u8.ToArray();
                        ReadOnlyMemory<byte> script_xml_end = "\"></script>"u8.ToArray();
                        foreach (var script in scripts)
                        {
                            await bodyCoreWriter.WriteAsync(script_xml_start);
                            await bodyCoreWriter.WriteAsync(encoding.GetBytes(script.LocalId.ToString()));
                            await bodyCoreWriter.WriteAsync(script_xml_end);
                        }
                        var html_end = buffer[position..];
                        
/#endif
                        await bodyCoreWriter.WriteAsync(html_end);
                    }

                    isSetBody = true;
                    await SetBodyAsync(bodyWriter);
                }
            }
#if !DEBUG
            catch
#else
            catch (Exception e)
#endif
            {
#if DEBUG
                var rawUrl = context.Request.RawUrl();
                logger.LogError(e, "HandleScriptInject fail, rawUrl: {rawUrl}", rawUrl);
#endif
                await ResetBody();
            }
            finally
            {
                if (!isSetBody)
                {
                    await SetBodyAsync(body);
                }
                await body.DisposeAsync();
            }

            async Task SetBodyAsync(Stream stream)
            {
                context.Response.ContentLength = stream.Length;
                stream.Seek(0, SeekOrigin.Begin);
                await stream.CopyToAsync(originalBody);
                context.Response.Body = originalBody;
            }
        }
    }

    static Stream? GetStreamByContentCompression(Stream stream, string contentCompression, CompressionMode mode, bool leaveOpen) => contentCompression switch
    {
        "gzip" => new GZipStream(stream, mode, leaveOpen),
        "deflate" => new DeflateStream(stream, mode, leaveOpen),
        "br" => new BrotliStream(stream, mode, leaveOpen),
        _ => null,
    };

    static bool TryDetectEncoding(byte[] data, [NotNullWhen(true)] out Encoding? encoding/*, out int preambleLength*/)
    {
        
/github.com/dotnet/runtime/blob/v6.0.6/src/libraries/System.Net.Http/src/System/Net/Http/HttpContent.cs#L773

        const long offset = 0L;
        var dataLength = data.Length;

        if (dataLength >= 2)
        {
            int first2Bytes = data[offset + 0] << 8 | data[offset + 1];

            switch (first2Bytes)
            {
                case UTF8PreambleFirst2Bytes:
                    if (dataLength >= UTF8PreambleLength && data[offset + 2] == UTF8PreambleByte2)
                    {
                        encoding = Encoding.UTF8;
                        
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\HttpServer\Middleware\HttpReverseProxyMiddleware.cs
DEBUG
DEBUG
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\HttpServer\Middleware\HttpReverseProxyMiddleware.FindScriptInjectInsertPosition.cs
/ </summary>
    
/ <param name="buffer_">Response.Body ByteArray</param>
    
/ <param name="encoding">Response.Body Encoding</param>
    
/ <param name="buffer">Response.Body Byte[]</param>
    
/ <param name="insertPosition">Insert Script Xml Position</param>
    
/ <returns></returns>
    
/ <exception cref="ArgumentOutOfRangeException"></exception>
    internal static bool FindScriptInjectInsertPosition(byte[] buffer_, Encoding encoding, out ReadOnlyMemory<byte> buffer, out int insertPosition)
    {
        buffer = buffer_.AsMemory();

        
/ 匹配 </...> 60 47 ... 62
        var mark_start = "</"u8.ToArray();
        var mark_end = ">"u8.ToArray();
        if (mark_start.Length <= 0 || mark_end.Length <= 0) goto notfound;

        int index_name_end = 0;
        int match_mark_end_index = 0;
        int match_mark_start_index = 0;

        for (int i = buffer_.Length - 1; i >= 0; i--) 
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\HttpServer\Middleware\IHttpProxyFeature.cs
/github.com/dotnetcore/FastGithub/blob/ddf63b315fee62a51b3b0fbc6875960dd236f9d0/FastGithub.HttpServer/TcpMiddlewares/IHttpProxyFeature.cs


发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\HttpServer\Middleware\ProxyProtocol.cs
/github.com/dotnetcore/FastGithub/blob/ddf63b315fee62a51b3b0fbc6875960dd236f9d0/FastGithub.HttpServer/TcpMiddlewares/ProxyProtocol.cs


/ </summary>
    None,

    
/ </summary>
    HttpProxy,

    
/ </summary>
    TunnelProxy,
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\HttpServer\Middleware\RequestLoggingMiddleware.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.HttpServer/RequestLoggingMilldeware.cs


/ </summary>
sealed class RequestLoggingMiddleware
{
    readonly ILogger<RequestLoggingMiddleware> logger;

    public RequestLoggingMiddleware(ILogger<RequestLoggingMiddleware> logger)
    {
        this.logger = logger;
    }

    
/ </summary>
    
/ <param name="context"></param>
    
/ <param name="next"></param>
    
/ <returns></returns>
    public async Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        var feature = new RequestLoggingFeature();
        context.Features.Set<IRequestLoggingFeature>(feature);
        var stopwatch = Stopwatch.StartNew();

        try
        {
            await next(context);
        }
        finally
        {
            stopwatch.Stop();
        }

        if (feature.Enable == false)
        {
            return;
        }

        var request = context.Request;
        var response = context.Response;
        var exception = context.GetForwarderErrorFeature()?.Exception;
        if (exception == null)
        {
            logger.LogInformation($"{request.Method} {request.Scheme}:
/ </summary>
    
/ <param name="exception"></param>
    
/ <returns></returns>
    static bool IsError(Exception exception)
    {
        if (exception is OperationCanceledException)
        {
            return false;
        }

        if (HasInnerException<ConnectionAbortedException>(exception))
        {
            return false;
        }

        return true;
    }

    
/ </summary>
    
/ <typeparam name="TInnerException"></typeparam>
    
/ <param name="exception"></param>
    
/ <returns></returns>
    static bool HasInnerException<TInnerException>(Exception exception)
        where TInnerException : Exception
    {
        var inner = exception.InnerException;
        while (inner != null)
        {
            if (inner is TInnerException)
            {
                return true;
            }
            inner = inner.InnerException;
        }
        return false;
    }

    
/ </summary>
    
/ <param name="exception"></param>
    
/ <returns></returns>
    static string GetMessage(Exception exception)
    {
        var ex = exception;
        var builder = new StringBuilder();

        while (ex != null)
        {
            var type = ex.GetType();
            builder.Append(type.Namespace).Append('.').Append(type.Name).Append(": ").AppendLine(ex.Message);
            ex = ex.InnerException;
        }
        return builder.ToString();
    }

    sealed class RequestLoggingFeature : IRequestLoggingFeature
    {
        public bool Enable { get; set; } = true;
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\HttpServer\Middleware\TlsInvadeMiddleware.cs
/github.com/dotnetcore/FastGithub/blob/58f79ddc19410c92b18e8d4de1c4b61376e97be7/FastGithub.HttpServer/TlsMiddlewares/TlsInvadeMiddleware.cs


/ </summary>
static class TlsInvadeMiddleware
{
    
/ </summary>
    
/ <param name="next"></param>
    
/ <param name="context"></param>
    
/ <returns></returns>
    public static async Task InvokeAsync(ConnectionDelegate next, ConnectionContext context)
    {
        
/ </summary>
    
/ <param name="context"></param>
    
/ <returns></returns>
    static async Task<bool> IsTlsConnectionAsync(ConnectionContext context)
    {
        try
        {
            var result = await context.Transport.Input.ReadAtLeastAsync(2, context.ConnectionClosed);
            var state = IsTlsProtocol(result);
            context.Transport.Input.AdvanceTo(result.Buffer.Start);
            return state;
        }
        catch
        {
            return false;
        }

        static bool IsTlsProtocol(ReadResult result)
        {
            var reader = new SequenceReader<byte>(result.Buffer);
            return reader.TryRead(out var firstByte) &&
                reader.TryRead(out var nextByte) &&
                firstByte == 0x16 &&
                nextByte == 0x3;
        }
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\HttpServer\Middleware\TlsRestoreMiddleware.cs
/github.com/dotnetcore/FastGithub/blob/58f79ddc19410c92b18e8d4de1c4b61376e97be7/FastGithub.HttpServer/TlsMiddlewares/TlsRestoreMiddleware.cs


/ </summary>
static class TlsRestoreMiddleware
{
    
/ </summary>
    
/ <param name="next"></param>
    
/ <param name="context"></param>
    
/ <returns></returns>
    public static async Task InvokeAsync(ConnectionDelegate next, ConnectionContext context)
    {
        if (context.Features.Get<ITlsConnectionFeature>() == FakeTlsConnectionFeature.Instance)
        {
            
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\HttpServer\Middleware\TunnelMiddleware.cs
/github.com/dotnetcore/FastGithub/blob/58f79ddc19410c92b18e8d4de1c4b61376e97be7/FastGithub.HttpServer/TcpMiddlewares/TunnelMiddleware.cs


/ </summary>
sealed class TunnelMiddleware
{
    readonly IReverseProxyConfig reverseProxyConfig;
    readonly IDomainResolver domainResolver;
    readonly TimeSpan connectTimeout = TimeSpan.FromSeconds(10d);

    
/ </summary>
    
/ <param name="fastGithubConfig"></param>
    
/ <param name="domainResolver"></param> 
    public TunnelMiddleware(
        IReverseProxyConfig reverseProxyConfig,
        IDomainResolver domainResolver)
    {
        this.reverseProxyConfig = reverseProxyConfig;
        this.domainResolver = domainResolver;
    }

    
/ </summary>
    
/ <param name="next"></param>
    
/ <param name="context"></param>
    
/ <returns></returns>
    public async Task InvokeAsync(ConnectionDelegate next, ConnectionContext context)
    {
        var proxyFeature = context.Features.Get<IHttpProxyFeature>();
        if (proxyFeature == null || 
/ </summary>
    
/ <param name="host"></param>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    
/ <exception cref="AggregateException"></exception>
    async Task<Stream> CreateConnectionAsync(HostString host, CancellationToken cancellationToken)
    {
        var innerExceptions = new List<Exception>();
        await foreach (var endPoint in GetUpstreamEndPointsAsync(host, cancellationToken))
        {
            var socket = new Socket(SocketType.Stream, ProtocolType.Tcp);
            try
            {
                using var timeoutTokenSource = new CancellationTokenSource(connectTimeout);
                using var linkedTokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, timeoutTokenSource.Token);
                await socket.ConnectAsync(endPoint, linkedTokenSource.Token);
                return new NetworkStream(socket, ownsSocket: true);
            }
            catch (Exception ex)
            {
                socket.Dispose();
                cancellationToken.ThrowIfCancellationRequested();
                innerExceptions.Add(ex);
            }
        }
        throw new AggregateException($"Unable to connect to {host}", innerExceptions);
    }

    
/ </summary>
    
/ <param name="host"></param>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    async IAsyncEnumerable<EndPoint> GetUpstreamEndPointsAsync(HostString host, [EnumeratorCancellation] CancellationToken cancellationToken)
    {
        const int HTTPS_PORT = 443;
        var targetHost = host.Host;
        var targetPort = host.Port ?? HTTPS_PORT;

        if (IPAddress.TryParse(targetHost, out var address) == true)
        {
            yield return new IPEndPoint(address, targetPort);
        }
        else if (reverseProxyConfig.IsMatch(targetHost) == false)
        {
            yield return new DnsEndPoint(targetHost, targetPort);
        }
        else
        {
            var dnsEndPoint = new DnsEndPoint(targetHost, targetPort);
            await foreach (var item in domainResolver.ResolveAsync(dnsEndPoint, cancellationToken))
            {
                yield return new IPEndPoint(item, targetPort);
            }
        }
    }
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\Net\DnsAnalysisServiceImpl.cs
NET
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\Net\DnsDohAnalysisService.cs
/ </summary>
    
/ </summary>
    
/ <param name="dohAddresUri">DoH 地址</param>
    
/ <param name="hostNameOrAddress">解析的地址</param>
    
/ <param name="queryType">查询类型</param>
    
/ <param name="count">当前递归的次数</param>
    
/ <param name="domainHistory">返回的历史域名，避免死循环</param>
    
/ <param name="cancellationToken">取消标记</param>
    
/ <returns></returns>
    async Task<IPAddress[]> Query(
        Uri dohAddresUri,
        string hostNameOrAddress,
        DnsQueryType queryType = DnsQueryType.A,
        
/        iPAddresses = await Query(dohAddresUri, domain, queryType,/* ++count, domainHistory,*/ cancellationToken);
        
/ </summary>
    
/ <param name="hostNameOrAddress">要解析的主机名或 IP 地址</param>
    
/ <param name="isIPv6"></param>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    public async IAsyncEnumerable<IPAddress> DohAnalysisDomainIpAsync(string? dohAddres, string hostNameOrAddress, bool isIPv6, bool useCache = true, [EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        var queryType = isIPv6 ? DnsQueryType.AAAA : DnsQueryType.A;
        var dohAddresUri = GetDohAddres(dohAddres);

        (Uri dohAddresUri, string hostNameOrAddressWithQueryType) cacheKey = useCache ? GetCacheKey() : default;
        (Uri dohAddresUri, string hostNameOrAddressWithQueryType) GetCacheKey()
        {
            var hostNameOrAddressWithQueryType = string.Concat(hostNameOrAddress, ":", (short)queryType);
            var cacheKey = (dohAddresUri, hostNameOrAddressWithQueryType);
            return cacheKey;
        }

        if (useCache)
        {
            if (Cache.TryGetValue(cacheKey, out var dns_list))
            {
                if ((DateTimeOffset.Now - dns_list.CreationTime) <= TTL)
                {
                    foreach (var item in dns_list.IPAddresses)
                    {
                        yield return item;
                    }
                }
            }
        }

        var result = await Query(dohAddresUri, hostNameOrAddress, queryType, cancellationToken: cancellationToken);

        if (isIPv6 && !result.Any())
        {
            
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\PacketIntercept\DnsInterceptHostedService.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.PacketIntercept/DnsInterceptHostedService.cs

#if WINDOWS && !REMOVE_DNS_INTERCEPT


/ </summary>
sealed class DnsInterceptHostedService : InterceptHostedService
{
    public DnsInterceptHostedService(
        IDnsInterceptor dnsInterceptor,
        ILogger<DnsInterceptHostedService> logger,
        IReverseProxyConfig reverseProxyConfig) : base(dnsInterceptor, logger, reverseProxyConfig)
    {
    }
}

#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\PacketIntercept\DnsInterceptHostedService.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\PacketIntercept\DnsInterceptor.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.PacketIntercept/Dns/DnsInterceptor.cs

#if WINDOWS && !REMOVE_DNS_INTERCEPT

using WinDivertSharp;
using DNS.Protocol;
using DNS.Protocol.ResourceRecords;


/ <inheritdoc cref="IDnsInterceptor"/>
sealed partial class DnsInterceptor : IDnsInterceptor, IDisposable
{
    const string DNS_FILTER = "udp.DstPort == 53";

    readonly IReverseProxyConfig reverseProxyConfig;
    readonly ILogger<DnsInterceptor> logger;

    readonly TimeSpan ttl = TimeSpan.FromMinutes(5d);
    bool disposedValue;

    
/ </summary>
    [LibraryImport("dnsapi.dll", EntryPoint = "DnsFlushResolverCache", SetLastError = true)]
    static partial void DnsFlushResolverCache();

    static DnsInterceptor()
    {
        
/ </summary>
    
/ <param name="winDivertBuffer"></param>
    
/ <param name="winDivertAddress"></param>
    
/ <param name="packetLength"></param>
    unsafe void ModifyDnsPacket(WinDivertBuffer winDivertBuffer, ref WinDivertAddress winDivertAddress, ref uint packetLength)
    {
        var packet = WinDivert.WinDivertHelperParsePacket(winDivertBuffer, packetLength);
        var requestPayload = new Span<byte>(packet.PacketPayload, (int)packet.PacketPayloadLength).ToArray();

        if (!TryParseRequest(requestPayload, out var request) ||
            request.OperationCode != OperationCode.Query ||
            request.Questions.Count == 0)
        {
            return;
        }

        var question = request.Questions.First();
        if (question.Type != RecordType.A && question.Type != RecordType.AAAA)
        {
            return;
        }

        var domain = question.Name;
        if (!reverseProxyConfig.IsMatch(question.Name.ToString()))
        {
            return;
        }

        
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\PacketIntercept\DnsInterceptor.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\PacketIntercept\GitInterceptor.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.PacketIntercept/Tcp/GitInterceptor.cs

#if WINDOWS && !REMOVE_DNS_INTERCEPT

using static BD.WTTS.Models.Abstractions.IReverseProxyConfig;


/ </summary>
sealed class GitInterceptor : TcpInterceptor
{
    public GitInterceptor(ILogger<GitInterceptor> logger) : base(GitHubDesktopPort, GitPort, logger)
    {

    }
}

#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\PacketIntercept\GitInterceptor.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\PacketIntercept\HttpInterceptor.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.PacketIntercept/Tcp/HttpInterceptor.cs

#if WINDOWS && !REMOVE_DNS_INTERCEPT

using static BD.WTTS.Models.Abstractions.IReverseProxyConfig;


/ </summary>
sealed class HttpInterceptor : TcpInterceptor
{
    public HttpInterceptor(ILogger<HttpInterceptor> logger) : base(HttpPortDefault, HttpPort, logger)
    {

    }
}

#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\PacketIntercept\HttpInterceptor.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\PacketIntercept\HttpsInterceptor.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.PacketIntercept/Tcp/HttpsInterceptor.cs

#if WINDOWS && !REMOVE_DNS_INTERCEPT

using static BD.WTTS.Models.Abstractions.IReverseProxyConfig;


/ </summary>
sealed class HttpsInterceptor : TcpInterceptor
{
    public HttpsInterceptor(ILogger<HttpsInterceptor> logger) : base(HttpsPortDefault, HttpsPort, logger)
    {

    }
}

#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\PacketIntercept\HttpsInterceptor.cs
WINDOWS
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\PacketIntercept\InterceptHostedService.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\PacketIntercept\Interceptors.cs
/ </summary>
sealed class Interceptors : IInterceptor
{
    readonly IEnumerable<IInterceptor> interceptors;

    public Interceptors(IEnumerable<IInterceptor> interceptors)
    {
        this.interceptors = interceptors;
    }

    Task IInterceptor.InterceptAsync(CancellationToken cancellationToken)
    {
        var tasks = interceptors.Select(item => item.InterceptAsync(cancellationToken));
        return Task.WhenAll(tasks);
    }
}

#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\PacketIntercept\Interceptors.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\PacketIntercept\SshInterceptor.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.PacketIntercept/Tcp/SshInterceptor.cs

#if WINDOWS && !REMOVE_DNS_INTERCEPT

using static BD.WTTS.Models.Abstractions.IReverseProxyConfig;


/ </summary>
sealed class SshInterceptor : TcpInterceptor
{
    public SshInterceptor(ILogger<SshInterceptor> logger) : base(SshPortDefault, SshPort, logger)
    {

    }
}
#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\PacketIntercept\SshInterceptor.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\PacketIntercept\TcpInterceptHostedService.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.PacketIntercept/TcpInterceptHostedService.cs

#if WINDOWS && !REMOVE_DNS_INTERCEPT

using static BD.WTTS.Models.Abstractions.IReverseProxyConfig;


/ </summary>
sealed class TcpInterceptHostedService : InterceptHostedService
{
    public TcpInterceptHostedService(
        IEnumerable<ITcpInterceptor> tcpInterceptors,
        ILogger<TcpInterceptHostedService> logger,
        IReverseProxyConfig reverseProxyConfig) : base(new Interceptors(tcpInterceptors), logger, reverseProxyConfig)
    {
    }
}
#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\PacketIntercept\TcpInterceptHostedService.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\PacketIntercept\TcpInterceptor.cs
/github.com/dotnetcore/FastGithub/blob/2.1.4/FastGithub.PacketIntercept/Tcp/TcpInterceptor.cs

#if WINDOWS && !REMOVE_DNS_INTERCEPT

using WinDivertSharp;


/ <inheritdoc cref="ITcpInterceptor"/>
abstract class TcpInterceptor : ITcpInterceptor
{
    readonly string filter;
    readonly ushort oldServerPort;
    readonly ushort newServerPort;
    readonly ILogger logger;

    public TcpInterceptor(int oldServerPort, int newServerPort, ILogger logger)
    {
        filter = $"loopback and (tcp.DstPort == {oldServerPort} or tcp.SrcPort == {newServerPort})";
        this.oldServerPort = (ushort)oldServerPort;
        this.newServerPort = (ushort)newServerPort;
        this.logger = logger;
    }

    
/ </summary>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    
/ <exception cref="Win32Exception"></exception>
    public async Task InterceptAsync(CancellationToken cancellationToken)
    {
        if (oldServerPort == newServerPort)
        {
            return;
        }

        await Task.Yield();

        var handle = WinDivert.WinDivertOpen(filter, WinDivertLayer.Network, 0, WinDivertOpenFlags.None);
        if (handle == new IntPtr(unchecked((long)ulong.MaxValue)))
        {
            throw new Win32Exception();
        }

        if (Socket.OSSupportsIPv4)
        {
            logger.LogInformation($"{IPAddress.Loopback}:{oldServerPort} <=> {IPAddress.Loopback}:{newServerPort}");
        }
        if (Socket.OSSupportsIPv6)
        {
            logger.LogInformation($"{IPAddress.IPv6Loopback}:{oldServerPort} <=> {IPAddress.IPv6Loopback}:{newServerPort}");
        }
        cancellationToken.Register(hwnd => WinDivert.WinDivertClose((IntPtr)hwnd!), handle);

        var packetLength = 0U;
        using WinDivertBuffer winDivertBuffer = new();
        WinDivertAddress winDivertAddress = default;

        while (!cancellationToken.IsCancellationRequested)
        {
            winDivertAddress.Reset();
            if (WinDivert.WinDivertRecv(handle, winDivertBuffer, ref winDivertAddress, ref packetLength) == false)
            {
                throw new Win32Exception();
            }

            try
            {
                ModifyTcpPacket(winDivertBuffer, ref winDivertAddress, ref packetLength);
            }
            catch (Exception ex)
            {
                logger.LogWarning(ex.Message);
            }
            finally
            {
                WinDivert.WinDivertSend(handle, winDivertBuffer, packetLength, ref winDivertAddress);
            }
        }
    }

    
/ </summary>
    
/ <param name="winDivertBuffer"></param>
    
/ <param name="winDivertAddress"></param>
    
/ <param name="packetLength"></param>
    unsafe void ModifyTcpPacket(WinDivertBuffer winDivertBuffer, ref WinDivertAddress winDivertAddress, ref uint packetLength)
    {
        var packet = WinDivert.WinDivertHelperParsePacket(winDivertBuffer, packetLength);
        if (packet.IPv4Header != null && packet.IPv4Header->SrcAddr.Equals(IPAddress.Loopback) == false)
        {
            return;
        }
        if (packet.IPv6Header != null && packet.IPv6Header->SrcAddr.Equals(IPAddress.IPv6Loopback) == false)
        {
            return;
        }

        if (packet.TcpHeader->DstPort == oldServerPort)
        {
            packet.TcpHeader->DstPort = newServerPort;
        }
        else
        {
            packet.TcpHeader->SrcPort = oldServerPort;
        }
        winDivertAddress.Impostor = true;
        WinDivert.WinDivertHelperCalcChecksums(winDivertBuffer, packetLength, ref winDivertAddress, WinDivertChecksumHelperParam.All);
    }
}

#endif
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Accelerator.ReverseProxy\Services.Implementation\PacketIntercept\TcpInterceptor.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\Enums\BotStatus.cs
/ <see cref="Bot"/> 状态

/ </summary>
public enum BotStatus : byte
{
    
/ </summary>
    [Description("禁用")]
    Disabled = 0,

    
/ </summary>
    [Description("离线")]
    OffLine = 1,

    
/ </summary>
    [Description("在线")]
    Online = 2,

    
/ </summary>
    [Description("正在挂卡")]
    Farming = 3
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\Enums\EPathFolder.cs
/ <inheritdoc cref="SharedInfo.HomeDirectory"/>
    ASF,

    
/ <inheritdoc cref="SharedInfo.ConfigDirectory"/>
    Config,

    
/ <inheritdoc cref="SharedInfo.PluginsDirectory"/>
    Plugin,

    
/ <inheritdoc cref="SharedInfo.WebsiteDirectory"/>
    WWW,

    
/ <inheritdoc cref="SharedInfo.LogFileDirectory"/>
    Logs,
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\Extensions\ServiceCollectionExtensions.AddArchiSteamFarmService.cs
/ </summary>
    
/ <param name="services"></param>
    
/ <returns></returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IServiceCollection AddArchiSteamFarmService(this IServiceCollection services)
    {
        services.AddSingleton<IArchiSteamFarmWebApiService, ArchiSteamFarmWebApiServiceImpl>();
        services.AddSingleton<IArchiSteamFarmService, ArchiSteamFarmServiceImpl>();
        
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\Models\ArchiSteamFarmCommandHistory.cs
/ </summary>
public class ArchiSteamFarmCommandHistory
{
    private List<string> commandHistory = new List<string>();
    private int currentIndex = -1;
    private string currentCommand = string.Empty;

    #region Properties

    
/ </summary>
    public int Count
    {
        get { return commandHistory.Count; }
    }

    
/ </summary>
    
/ </value>
    public string CurrentCommand
    {
        get
        { return currentCommand; }

        set
        {
            if (!string.IsNullOrEmpty(value))
            {
                currentCommand = value;
            }
        }
    }

    
/ </summary>
    public List<string> CommandHistoryList
    {
        get { return commandHistory; }
    }

    
/ </summary>
    
/ </value>
    public int CurrentIndex
    {
        get { return currentIndex; }
        set { currentIndex = value; }
    }

    #endregion

    #region Command Control

    
/ </summary>
    
/ <param name="command">The command to add.</param>
    public void AddCommandToHistory(string command)
    {
        if (!string.IsNullOrEmpty(command)) { commandHistory.Add(command); }
    }

    
/ </summary>
    public void ClearHistory()
    {
        commandHistory.Clear();
        currentIndex = -1;
    }

    
/ </summary>
    
/ <returns></returns>
    private string GetCommand()
    {
        string selected = currentCommand;

        if (commandHistory.Count > 0)
        {
            if (currentIndex >= 0 && currentIndex < commandHistory.Count)
            {
                selected = commandHistory.ElementAt(currentIndex);
            }
        }

        return selected;
    }

    
/ </summary>
    
/ <param name="indexNumber">The index number.</param>
    
/ <returns></returns>
    public string GetCommand(int indexNumber)
    {
        if (indexNumber >= 0 && indexNumber < commandHistory.Count) { return commandHistory.ElementAt(indexNumber); }
        return string.Empty;
    }

    
/ </summary>
    
/ <returns>The previous command.</returns>
    public string GetPrevious()
    {
        currentIndex--;
        if (currentIndex < 0) { currentIndex = commandHistory.Count - 1; }
        return GetCommand();
    }

    
/ </summary>
    
/ <returns>The next command.</returns>
    public string GetNext()
    {
        currentIndex++;
        if (currentIndex >= commandHistory.Count) { currentIndex = 0; }
        return GetCommand();
    }

    
/ </summary>
    
/ <param name="indexNumber">The index number of the command to remove.</param>
    public void RemoveFromCommandHistory(int indexNumber)
    {
        if (indexNumber >= 0 && indexNumber < commandHistory.Count)
        {
            commandHistory.RemoveAt(indexNumber);
        }
        else
        {
            throw new ArgumentOutOfRangeException("The selected index number was outside of the bounds of the list");
        }
    }

    #endregion
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\Models\BotViewModel.cs
/github.com/JustArchiNET/ASF-ui/blob/9105e9becd86d610418532b73852ae22e19b3587/src/models/Bot.js#L6

    
/ 获取 <see cref="Bot"/> 状态
    
/ </summary>
    
/ <param name="bot"></param>
    
/ <returns></returns>
    public BotStatus GetStatus()
    {
        if (!Bot.KeepRunning) return BotStatus.Disabled;
        if (!Bot.IsConnectedAndLoggedOn) return BotStatus.OffLine;
        if (Bot.CardsFarmer.Paused || Bot.CardsFarmer.TimeRemaining == default) return BotStatus.Online;
        if ((Bot.CardsFarmer?.CurrentGamesFarming?.Count ?? 0) <= 0) return BotStatus.Online;
        return BotStatus.Farming;
    }

    
/ 获取 <see cref="BotStatus"/> 展示文本
    
/ </summary>
    
/ <param name="bot"></param>
    
/ <returns></returns>
    public string GetStatusText()
    {
        var statusText = BotStatus.GetDescription();
        
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\Plugins\Plugin.cs
/ 用于 <see cref="ArchiSteamFarm"/> 的 <see cref="HttpMessageHandler"/>
    
/ </summary>
    
/ <param name="args"></param>
    
/ <returns></returns>
    static HttpMessageHandler? CreateHttpHandler(CreateHttpHandlerArgs args)
    {
        var proxy = args.Item4;
        var useProxy = GeneralHttpClientFactory.UseWebProxy(proxy);
        var setMaxConnectionsPerServer = !(args.Item5 < 1);  
/github.com/dotnet/runtime/blob/v6.0.0/src/libraries/System.Net.Http/src/System/Net/Http/SocketsHttpHandler/SocketsHttpHandler.cs#L157
#if NETCOREAPP2_1_OR_GREATER
        {
            var handler = new SocketsHttpHandler()
            {
                AllowAutoRedirect = args.Item1,
                AutomaticDecompression = args.Item2,
                CookieContainer = args.Item3,
            };
            if (useProxy)
            {
                handler.Proxy = proxy;
                handler.UseProxy = true;
            }
            if (setMaxConnectionsPerServer)
            {
                handler.MaxConnectionsPerServer = args.Item5;
            }
            return handler;
        }
#elif ANDROID
        var handler = PlatformHttpMessageHandlerBuilder.CreateAndroidClientHandler(new()
        {
            AllowAutoRedirect = args.Item1,
            AutomaticDecompression = args.Item2,
            CookieContainer = args.Item3,
        });
        if (useProxy)
        {
            handler.Proxy = proxy;
            handler.UseProxy = true;
        }
        if (setMaxConnectionsPerServer)
        {
            handler.MaxConnectionsPerServer = args.Item5;
        }
        return handler;
#else
        return null!;
#endif
    }

    public override void OnAddAutoMapper(IMapperConfigurationExpression cfg)
    {

    }

    public override IEnumerable<(Action<IServiceCollection>? @delegate, bool isInvalid, string name)>? GetConfiguration(bool directoryExists)
    {
        yield return GetConfiguration<ASFSettings_>(directoryExists);
    }

    public override async ValueTask OnExit()
    {
        if (ArchiSteamFarmServiceImpl.ASFProcessId.HasValue)
        {
            try
            {
                var process = Process.GetProcessById(ArchiSteamFarmServiceImpl.ASFProcessId.Value);
                process.Kill();
                process.Dispose();
            }
            catch (ArgumentException)
            {
                
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\Plugins\Plugin.cs
NETCOREAPP
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\Properties\Resources.Designer.cs
/ </auto-generated>

/ </summary>
    
/ (以 /str 作为命令选项)，或重新生成 VS 项目。
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        
/ </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("BD.WTTS.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        
/ </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        
/ </summary>
        internal static byte[] asf {
            get {
                object obj = ResourceManager.GetObject("asf", resourceCulture);
                return ((byte[])(obj));
            }
        }
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\Services\IArchiSteamFarmService.cs
/ </summary>
public partial interface IArchiSteamFarmService
{
    static IArchiSteamFarmService Instance => Ioc.Get<IArchiSteamFarmService>();

    event Action<string>? OnConsoleWirteLine;

    TaskCompletionSource<string>? ReadLineTask { get; }

    bool IsReadPasswordLine { get; }

    Process? ASFProcess { get; }

    Version CurrentVersion { get; }

    
/ </summary>
    
/ <param name="data"></param>
    Task ShellMessageInput(string data);

    
/ </summary>
    
/ <param name="args"></param>
    Task<(bool IsSuccess, string IPCUrl)> StartAsync(string[]? args = null);

    Task StopAsync();

    
/ </summary>
    
/ <param name="command"></param>
    Task<string?> ExecuteCommandAsync(string command);

    
/ </summary>
    
/ <returns></returns>
    string GetIPCUrl();

    
/ </summary>
    
/ <returns></returns>
    Task<IReadOnlyDictionary<string, Bot>?> GetReadOnlyAllBots();

    Task<GlobalConfig?> GetGlobalConfig();

    Task<bool> SaveBot(string botName, BotConfig botConfig);

    Task<bool> SaveGlobalConfig(GlobalConfig config);

    async void CommandSubmit(string? command)
    {
        if (string.IsNullOrEmpty(command))
            return;

        if (ReadLineTask is null)
        {
            if (command[0] == '!')
            {
                command = command.Remove(0, 1);
            }
            await ExecuteCommandAsync(command);
        }
        else
        {
            ReadLineTask.TrySetResult(command);
        }
    }

    int CurrentIPCPortValue { get; }

    
/ </summary>
    
/ <returns></returns>
    Task SetEncryptionKeyAsync();

    Task<IApiRsp> BotResumeAsync(string botNames,
            CancellationToken cancellationToken = default);

    Task<IApiRsp> BotPauseAsync(string botNames,
            BotPauseRequest request,
            CancellationToken cancellationToken = default);

    Task<IApiRsp> BotStopAsync(string botNames,
            CancellationToken cancellationToken = default);

    Task<IApiRsp> BotStartAsync(string botNames,
            CancellationToken cancellationToken = default);

    Task<IApiRsp<IReadOnlyDictionary<string, GamesToRedeemInBackgroundResponse>>> BotGetUsedAndUnusedKeysAsync(string botNames,
            CancellationToken cancellationToken = default);

    Task<IApiRsp> BotRedeemKeyAsync(string botNames,
            BotGamesToRedeemInBackgroundRequest request,
            CancellationToken cancellationToken = default);

    Task<IApiRsp> BotResetRedeemedKeysRecordAsync(string botNames,
            CancellationToken cancellationToken = default);

    Task<IApiRsp> BotDeleteAsync(
            string botNames,
            CancellationToken cancellationToken = default);
}

#endif
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\Services\IArchiSteamFarmWebApiService.cs
/localhost:1242/swagger/index.html
    
/ </summary>
        
/ <param name="request"></param>
        
/ <param name="cancellationToken"></param>
        
/ <returns></returns>
        Task<IApiRsp> Encrypt(
            ASFEncryptRequest request,
            CancellationToken cancellationToken = default);

        
/ </summary>
        
/ <param name="cancellationToken"></param>
        
/ <returns></returns>
        Task<IApiRsp<ASFResponse>> Get(
            CancellationToken cancellationToken = default);

        
/ </summary>
        
/ <param name="request"></param>
        
/ <param name="cancellationToken"></param>
        
/ <returns></returns>
        Task<IApiRsp<string>> Hash(
            ASFHashRequest request,
            CancellationToken cancellationToken = default);

        
/ </summary>
        
/ <param name="request"></param>
        
/ <param name="cancellationToken"></param>
        
/ <returns></returns>
        Task<IApiRsp> Post(
            ASFRequest request,
            CancellationToken cancellationToken = default);

        
/ </summary>
        
/ <param name="cancellationToken"></param>
        
/ <returns></returns>
        Task<IApiRsp> Exit(
            CancellationToken cancellationToken = default);

        
/ </summary>
        
/ <param name="cancellationToken"></param>
        
/ <returns></returns>
        Task<IApiRsp> Restart(
            CancellationToken cancellationToken = default);

        
/ </summary>
        
/ <param name="request"></param>
        
/ <param name="cancellationToken"></param>
        
/ <returns></returns>
        Task<IApiRsp<string?>> Update(
            CancellationToken cancellationToken = default);
    }

    IBotClient Bot { get; }

    interface IBotClient
    {
        
/ </summary>
        Task<IApiRsp> BotDelete(
            string botNames,
            CancellationToken cancellationToken = default);

        
/ </summary>
        Task<IApiRsp<IReadOnlyDictionary<string, Bot>>> BotGet(
            string botNames,
            CancellationToken cancellationToken = default);

        
/ </summary>
        Task<IApiRsp> BotPost(
            string botNames,
            BotRequest request,
            CancellationToken cancellationToken = default);

        
/ </summary>
        Task<IApiRsp> GamesToRedeemInBackgroundDelete(
            string botNames,
            CancellationToken cancellationToken = default);

        
/ </summary>
        Task<IApiRsp<IReadOnlyDictionary<string, GamesToRedeemInBackgroundResponse>>> GamesToRedeemInBackgroundGet(
            string botNames,
            CancellationToken cancellationToken = default);

        
/ </summary>
        Task<IApiRsp> GamesToRedeemInBackgroundPost(
            string botNames,
            BotGamesToRedeemInBackgroundRequest request,
            CancellationToken cancellationToken = default);

        
/ </summary>
        Task<IApiRsp> InputPost(
            string botNames,
            BotInputRequest request,
            CancellationToken cancellationToken = default);

        
/ </summary>
        Task<IApiRsp> PausePost(
            string botNames,
            BotPauseRequest request,
            CancellationToken cancellationToken = default);

        
/ </summary>
        
/ </remarks>
        Task<IApiRsp> RedeemPost(
            string botNames,
            BotRedeemRequest request,
            CancellationToken cancellationToken = default);

        
/ </summary>
        Task<IApiRsp> RenamePost(
            string botNames,
            BotRenameRequest request,
            CancellationToken cancellationToken = default);

        
/ </summary>
        Task<IApiRsp> ResumePost(
            string botNames,
            CancellationToken cancellationToken = default);

        
/ </summary>
        Task<IApiRsp> StartPost(
            string botNames,
            CancellationToken cancellationToken = default);

        
/ </summary>
        Task<IApiRsp> StopPost(
            string botNames,
            CancellationToken cancellationToken = default);
    }

    ICommandClient Command { get; }

    interface ICommandClient
    {
        
/ </summary>
        
/     This API endpoint is supposed to be entirely replaced by ASF actions available under /Api/ASF/{action} and /Api/Bot/{bot}/{action}.
        
/ </remarks>
        Task<IApiRsp<string>> CommandPost(
            CommandRequest request,
            CancellationToken cancellationToken = default);
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\Services\Mvvm\ASFService.cs
/ </summary>
    public bool IsASFRunOrStoping { get; private set; }

    public Task InitASFAsync() => InitASFCoreAsync(true);

    public async Task InitASFCoreAsync(bool showToast)
    {
        if (IsASFRunOrStoping) return;

        if (showToast) Toast.Show(ToastIcon.Info, AppResources.ASF_Starting, ToastLength.Short);

        IsASFRunOrStoping = true;

        ConsoleLogText = string.Empty;
        (var isOk, var ipcURL) = await archiSteamFarmService.StartAsync();
        if (!isOk)
        {
            if (showToast) Toast.Show(ToastIcon.Error, AppResources.ASF_Stoped, ToastLength.Short);
            IsASFRunOrStoping = false;
            return;
        }

        RefreshBots();

        IPCUrl = ipcURL;

        MainThread2.BeginInvokeOnMainThread(() =>
        {
            this.RaisePropertyChanged(nameof(IsASFRuning));
        });

        IsASFRunOrStoping = false;

        if (showToast) Toast.Show(ToastIcon.Success, AppResources.ASF_Started, ToastLength.Short);
    }

    public Task StopASFAsync() => StopASFCoreAsync(true);

    public async Task StopASFCoreAsync(bool showToast)
    {
        if (IsASFRunOrStoping) return;

        if (showToast) Toast.Show(ToastIcon.Info, AppResources.ASF_Stoping, ToastLength.Short);

        IsASFRunOrStoping = true;

        await archiSteamFarmService.StopAsync();

        SteamBotsSourceList.Clear();

        MainThread2.BeginInvokeOnMainThread(() =>
        {
            this.RaisePropertyChanged(nameof(IsASFRuning));
        });

        IsASFRunOrStoping = false;

        if (showToast) Toast.Show(ToastIcon.Info, AppResources.ASF_Stoped, ToastLength.Short);
    }

    public async void RefreshBots()
    {
        var bots = await archiSteamFarmService.GetReadOnlyAllBots();
        if (bots.Any_Nullable())
        {
            SteamBotsSourceList.Clear();
            SteamBotsSourceList.AddOrUpdate(bots!.Values.Select(s => (BotViewModel)s));
        }
    }

    public async void RefreshConfig()
    {
        GlobalConfig = await archiSteamFarmService.GetGlobalConfig();
    }

    public void OpenFolder(string tag)
    {
        if (string.IsNullOrEmpty(ASFSettings.ArchiSteamFarmExePath.Value))
        {
            Toast.Show(ToastIcon.Error, BDStrings.ASF_SetExePathFirst);
            return;
        }

        string folderASFPathValue = string.Empty;
        if (!Enum.TryParse<EPathFolder>(tag, true, out var folderASFPath) ||
            !Path.Exists(folderASFPathValue = folderASFPath.GetFolderPath()))
        {
            Toast.Show(ToastIcon.Error, BDStrings.ASF_SelectASFExePath);
            return;
        }

        IPlatformService.Instance.OpenFolder(folderASFPathValue);
    }

    async void OpenBrowserCore(ActionItem tag)
    {
        var url = tag switch
        {
            ActionItem.Repo => "https:
/github.com/JustArchiNET/ArchiSteamFarm",
            ActionItem.Wiki => "https:
/github.com/JustArchiNET/ArchiSteamFarm/wiki/Home-zh-CN",
            ActionItem.ConfigGenerator => "https:
/justarchinet.github.io/ASF-WebConfigGenerator",
            _ => string.Empty,
        };

        if (url != string.Empty)
        {
            await Browser2.OpenAsync(url, BrowserLaunchMode.External);
            return;
        }

        url = tag switch
        {
            ActionItem.WebConfig => IPCUrl + "/asf-config",
            ActionItem.WebAddBot => IPCUrl + "/bot/new",
            _ => IPCUrl,
        };

        if (string.IsNullOrEmpty(IPCUrl) && !Uri.TryCreate(IPCUrl, UriKind.Absolute, out _))
        {
            string? ipc_error = null;
            if (!ASFService.Current.IsASFRuning)
            {
                ipc_error = BDStrings.ASF_RequirRunASF;
            }
            else if (!ASF.IsReady)
            {
                
/api.github.com/repos/JustArchiNET/ArchiSteamFarm/releases/latest", cancellationToken);
            using var element = await JsonDocument.ParseAsync(latestReleaseStream, cancellationToken: cancellationToken);
            if (element.RootElement.TryGetProperty("assets", out var assets) &&
                assets.EnumerateArray().FirstOrDefault(s => s.GetProperty("name").ValueEquals(assetName))
                .TryGetProperty("browser_download_url", out var downloadUrl))
            {
                var tag_name = element.RootElement.GetProperty("tag_name").GetString();
                var downloadSavingPath = Path.Combine(Plugin.Instance.AppDataDirectory, $"ASF-{tag_name}", assetName);
                var downloadSavingDir = Path.GetDirectoryName(downloadSavingPath)!;
                Directory.CreateDirectory(downloadSavingDir);

                var message = new HttpRequestMessage(HttpMethod.Get, downloadUrl.GetString());
                var result = await httpClient.SendAsync(message, HttpCompletionOption.ResponseHeadersRead, cancellationToken);
                using var contentStream = await result.Content.ReadAsStreamAsync(cancellationToken);

                byte batch = 0;
                long readThisBatch = 0;
                long batchIncreaseSize = result.Content.Headers.ContentLength.GetValueOrDefault() / 100;
                await using (FileStream fileStream = new(downloadSavingPath, FileMode.Create, FileAccess.Write, FileShare.None, 4096, true))
                {
                    ArrayPool<byte> bytePool = ArrayPool<byte>.Shared;
                    byte[] buffer = bytePool.Rent(4096);

                    try
                    {
                        while (contentStream.CanRead)
                        {
                            int read = await contentStream.ReadAsync(buffer.AsMemory(0, buffer.Length), cancellationToken);

                            if (read == 0)
                                break;

                            await fileStream.WriteAsync(buffer.AsMemory(0, read), cancellationToken);
                            if ((progress == null) || (batchIncreaseSize == 0) || (batch >= 99))
                            {
                                continue;
                            }

                            readThisBatch += read;

                            while ((readThisBatch >= batchIncreaseSize) && (batch < 99))
                            {
                                readThisBatch -= batchIncreaseSize;
                                progress.Report(++batch);
                            }
                        }
                    }
                    finally
                    {
                        bytePool.Return(buffer);
                    }
                }

                ZipFile.ExtractToDirectory(downloadSavingPath, downloadSavingDir);
                ASFSettings.ArchiSteamFarmExePath.Value = Path.Combine(downloadSavingDir, "ArchiSteamFarm.exe");
                progress?.Report(100);
                Toast.Show(ToastIcon.Success, "ASF 下载成功");
            }
        }
        catch (Exception ex)
        {
            Toast.LogAndShowT(ex, "ASF 文件下载异常");
        }
    }
}
#endif
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\Services.Implementation\ArchiSteamFarmServiceImpl.cs
/github.com/JustArchiNET/ArchiSteamFarm/releases/download/{versionInfo.FileVersion}/{fileName}";
                var savePath = Path.Combine(Plugin.Instance.AppDataDirectory, $"ASF-{versionInfo.FileVersion}", fileName);
                var saveDir = Path.GetDirectoryName(savePath)!;

                var destination_asfPath = Path.Combine(saveDir, Path.GetFileName(SharedInfo.ASFExecuteFilePath));
                if (!File.Exists(destination_asfPath))
                {
                    Directory.CreateDirectory(saveDir);
                    if (await DownloadASFRelease(downloadUrl, savePath))
                        ZipFile.ExtractToDirectory(savePath, saveDir);
                    else
                        Toast.Show(ToastIcon.Error, "比对文件下载失败");
                }

                if (CalculateFileHash(SharedInfo.ASFExecuteFilePath) == CalculateFileHash(destination_asfPath))
                    isConsistence = true;
            }
            catch (Exception)
            {
            }

        }
        return isConsistence;

        string CalculateFileHash(string filePath)
        {
            using (var hasher = SHA256.Create())
            using (var stream = new BufferedStream(File.OpenRead(filePath), 1200000))
            {
                byte[] hashBytes = hasher.ComputeHash(stream);
                return BitConverter.ToString(hashBytes).Replace("-", "");
            }
        }

        async Task<bool> DownloadASFRelease(string downloadUrl, string savePath)
        {
            try
            {
                HttpResponseMessage response = await _httpClient.GetAsync(downloadUrl);

                
/ </summary>
    
/ <returns></returns>
    private async Task ReadEncryptionKeyAsync()
    {
        if (!string.IsNullOrEmpty(EncryptionKey))
        {
            
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\Services.Implementation\ArchiSteamFarmWebApiServiceImpl.ApiControllers.cs
/ ApiControllers
    : IASFClient, IBotClient, ICommandClient
{
    public IASFClient ASF => this;

    #region ASFController

    public async Task<IApiRsp> Encrypt(
        ASFEncryptRequest request,
        CancellationToken cancellationToken = default)
    {
        var result = await SendAsync<ASFEncryptRequest, Void>(
            "Api/ASF/Encrypt",
            HttpMethod.Post,
            reqBody: request,
            cancellationToken: cancellationToken);
        return result!;
    }

    public async Task<IApiRsp<ASFResponse>> Get(
        CancellationToken cancellationToken = default)
    {
        var result = await SendAsync<Void, ASFResponse>(
            "Api/ASF",
            HttpMethod.Get,
            reqBody: default,
            cancellationToken: cancellationToken);
        return result!;
    }

    public async Task<IApiRsp<string>> Hash(
        ASFHashRequest request,
        CancellationToken cancellationToken = default)
    {
        var result = await SendAsync<ASFHashRequest, string>(
            "Api/ASF/Hash",
            HttpMethod.Post,
            reqBody: request,
            cancellationToken: cancellationToken);
        return result!;
    }

    public async Task<IApiRsp> Post(
        ASFRequest request,
        CancellationToken cancellationToken = default)
    {
        var result = await SendAsync<ASFRequest, Void>(
            "Api/ASF",
            HttpMethod.Post,
            reqBody: request,
            cancellationToken: cancellationToken);
        return result!;
    }

    public async Task<IApiRsp> Exit(
        CancellationToken cancellationToken = default)
    {
        var result = await SendAsync<Void, Void>(
            "Api/ASF/Exit",
            HttpMethod.Post,
            reqBody: default,
            cancellationToken: cancellationToken);
        return result!;
    }

    public async Task<IApiRsp> Restart(
        CancellationToken cancellationToken = default)
    {
        var result = await SendAsync<Void, Void>(
            "Api/ASF/Restart",
            HttpMethod.Post,
            reqBody: default,
            cancellationToken: cancellationToken);
        return result!;
    }

    public async Task<IApiRsp<string?>> Update(
        CancellationToken cancellationToken = default)
    {
        var result = await SendAsync<Void, string>(
            "Api/ASF/Update",
            HttpMethod.Post,
            reqBody: default,
            cancellationToken: cancellationToken);
        return result!;
    }

    #endregion

    public IBotClient Bot => this;

    #region BotController

    public async Task<IApiRsp> BotDelete(
        string botNames,
        CancellationToken cancellationToken = default)
    {
        var result = await SendAsync<Void, Void>(
            $"Api/Bot/{botNames}",
            HttpMethod.Delete,
            reqBody: default,
            cancellationToken: cancellationToken);
        return result!;
    }

    public async Task<IApiRsp<IReadOnlyDictionary<string, Bot>>> BotGet(
        string botNames,
        CancellationToken cancellationToken = default)
    {
        var result = await SendAsync<Void, IReadOnlyDictionary<string, Bot>>(
            $"Api/Bot/{botNames}",
            HttpMethod.Get,
            reqBody: default,
            cancellationToken: cancellationToken);
        return result!;
    }

    public async Task<IApiRsp> BotPost(
        string botNames,
        BotRequest request,
        CancellationToken cancellationToken = default)
    {
        var result = await SendAsync<BotRequest, Void>(
            $"Api/Bot/{botNames}",
            HttpMethod.Post,
            reqBody: request,
            cancellationToken: cancellationToken);
        return result!;
    }

    public async Task<IApiRsp> GamesToRedeemInBackgroundDelete(
        string botNames,
        CancellationToken cancellationToken = default)
    {
        var result = await SendAsync<Void, Void>(
            $"Api/Bot/{botNames}/GamesToRedeemInBackground",
            HttpMethod.Delete,
            reqBody: default,
            cancellationToken: cancellationToken);
        return result!;
    }

    public async Task<IApiRsp<IReadOnlyDictionary<string, GamesToRedeemInBackgroundResponse>>> GamesToRedeemInBackgroundGet(
        string botNames,
        CancellationToken cancellationToken = default)
    {
        var result = await SendAsync<Void, IReadOnlyDictionary<string, GamesToRedeemInBackgroundResponse>>(
            $"Api/Bot/{botNames}/GamesToRedeemInBackground",
            HttpMethod.Get,
            reqBody: default,
            cancellationToken: cancellationToken);
        return result!;
    }

    public async Task<IApiRsp> GamesToRedeemInBackgroundPost(
        string botNames,
        BotGamesToRedeemInBackgroundRequest request,
        CancellationToken cancellationToken = default)
    {
        var result = await SendAsync<BotGamesToRedeemInBackgroundRequest, Void>(
            $"Api/Bot/{botNames}/GamesToRedeemInBackground",
            HttpMethod.Post,
            reqBody: request,
            cancellationToken: cancellationToken);
        return result!;
    }

    public async Task<IApiRsp> InputPost(
        string botNames,
        BotInputRequest request,
        CancellationToken cancellationToken = default)
    {
        var result = await SendAsync<BotInputRequest, Void>(
            $"Api/Bot/{botNames}/Input",
            HttpMethod.Post,
            reqBody: request,
            cancellationToken: cancellationToken);
        return result!;
    }

    public async Task<IApiRsp> PausePost(
        string botNames,
        BotPauseRequest request,
        CancellationToken cancellationToken = default)
    {
        var result = await SendAsync<BotPauseRequest, Void>(
            $"Api/Bot/{botNames}/Pause",
            HttpMethod.Post,
            reqBody: request,
            cancellationToken: cancellationToken);
        return result!;
    }

    public async Task<IApiRsp> RedeemPost(
        string botNames,
        BotRedeemRequest request,
        CancellationToken cancellationToken = default)
    {
        var result = await SendAsync<BotRedeemRequest, Void>(
            $"Api/Bot/{botNames}/Redeem",
            HttpMethod.Post,
            reqBody: request,
            cancellationToken: cancellationToken);
        return result!;
    }

    public async Task<IApiRsp> RenamePost(
        string botNames,
        BotRenameRequest request,
        CancellationToken cancellationToken = default)
    {
        var result = await SendAsync<BotRenameRequest, Void>(
            $"Api/Bot/{botNames}/Rename",
            HttpMethod.Post,
            reqBody: request,
            cancellationToken: cancellationToken);
        return result!;
    }

    public async Task<IApiRsp> ResumePost(
        string botNames,
        CancellationToken cancellationToken = default)
    {
        var result = await SendAsync<Void, Void>(
            $"Api/Bot/{botNames}/Resume",
            HttpMethod.Post,
            reqBody: default,
            cancellationToken: cancellationToken);
        return result!;
    }

    public async Task<IApiRsp> StartPost(
        string botNames,
        CancellationToken cancellationToken = default)
    {
        var result = await SendAsync<Void, Void>(
            $"Api/Bot/{botNames}/Start",
            HttpMethod.Post,
            reqBody: default,
            cancellationToken: cancellationToken);
        return result!;
    }

    public async Task<IApiRsp> StopPost(
        string botNames,
        CancellationToken cancellationToken = default)
    {
        var result = await SendAsync<Void, Void>(
            $"Api/Bot/{botNames}/Stop",
            HttpMethod.Post,
            reqBody: default,
            cancellationToken: cancellationToken);
        return result!;
    }

    #endregion

    public ICommandClient Command => this;

    #region CommandController

    public async Task<IApiRsp<string>> CommandPost(
        CommandRequest request,
        CancellationToken cancellationToken = default)
    {
        var result = await SendAsync<CommandRequest, string>(
            $"Api/Command",
            HttpMethod.Post,
            reqBody: request,
            cancellationToken: cancellationToken);
        return result!;
    }

    #endregion
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\Services.Implementation\ArchiSteamFarmWebApiServiceImpl.JsonSerializer.cs
/github.com/BeyondDimension/ArchiSteamFarm/blob/v5.4.9.3/ArchiSteamFarm/IPC/Startup.cs#L350-L364
        
/github.com/dotnet/aspnetcore/blob/v7.0.11/src/Mvc/Mvc.NewtonsoftJson/src/JsonSerializerSettingsProvider.cs

        var settings = new JsonSerializerSettings();
        
/ Fix default contract resolver to use original names and not a camel case
        settings.ContractResolver = new DefaultContractResolver();

        var serializer = JsonSerializer.Create(settings);
        return serializer;
    }

    HttpContent Serialize(object? value, Type? objectType = null)
    {
        var stream = new MemoryStream();
        using var streamWriter = new StreamWriter(stream, new UTF8Encoding(false), leaveOpen: true);
        using var jsonWriter = new JsonTextWriter(streamWriter);
        serializer.Serialize(jsonWriter, value, objectType);
        jsonWriter.Flush();
        stream.Seek(0, SeekOrigin.Begin);
        var content = new StreamContent(stream);
        content.Headers.TryAddWithoutValidation("Content-Type", "application/json;charset=utf-8");
        return content;
    }

    async Task<object?> DeserializeAsync(
        HttpContent content,
        Type? objectType,
        CancellationToken cancellationToken = default)
    {
        using var stream = await content.ReadAsStreamAsync(cancellationToken);
        using var streamReader = new StreamReader(stream, Encoding.UTF8);
        using var jsonReader = new JsonTextReader(streamReader);
        var value = serializer.Deserialize(jsonReader, objectType);
        return value;
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\Services.Implementation\ArchiSteamFarmWebApiServiceImpl.SendAsync.cs
/ <inheritdoc/>
    public void SetIPCUrl(string ipcUrl) => BaseAddress = Uri.TryCreate(ipcUrl, UriKind.Absolute, out var uri) ? uri : BaseAddress;

    HttpClient LocalCreateClient()
    {
        var client = CreateClient($"{TAG}_{BaseAddress.AbsoluteUri}", HttpHandlerCategory.Default);
        if (client.BaseAddress == null || !client.BaseAddress.Equals(BaseAddress))
            client.BaseAddress = BaseAddress;
        return client;
    }

    async Task<IApiRsp<TResponseBody?>> SendAsync<TRequestBody, TResponseBody>(
        string requestUrl,
        HttpMethod method,
        TRequestBody? reqBody,
        bool isShowResponseErrorMessage = true,
        string? errorAppendText = null,
        CancellationToken cancellationToken = default)
        where TRequestBody : class
        where TResponseBody : class
    {
        var result = await SendCoreAsync();
        if (!result.IsSuccess && isShowResponseErrorMessage)
        {
            conn_helper.ShowResponseErrorMessage(requestUrl, result, errorAppendText);
        }
        return result;

        async Task<IApiRsp<TResponseBody?>> SendCoreAsync()
        {
            var client = LocalCreateClient();
            using var req = new HttpRequestMessage(method, requestUrl);
            var typeVoid = typeof(Void);
            var typeRequestBody = typeof(TRequestBody);
            var isVoidRequestBody = typeRequestBody == typeVoid;
            if (!isVoidRequestBody)
            {
                try
                {
                    var reqContent = Serialize(reqBody, typeRequestBody);
                    req.Content = reqContent;
                }
                catch (Exception ex)
                {
                    return ApiRspHelper.Code<TResponseBody?>(
                        ApiRspCode.ClientException,
                        "Serialize request fail",
                        default,
                        ex);
                }
            }

            using var rsp = await client.SendAsync(req, cancellationToken);
            try
            {
                var typeResponseBody = typeof(TResponseBody);
                var isVoidResponseBody = typeResponseBody == typeVoid;
                var typeResponseBodyDeserialize = isVoidResponseBody ? typeof(GenericResponse) : typeof(GenericResponse<TResponseBody?>);
                var result = await DeserializeAsync(rsp.Content,
                    typeResponseBodyDeserialize, cancellationToken);
                if (result is GenericResponse resultGR)
                {
                    var code = resultGR.Success ? ApiRspCode.OK : (ApiRspCode)rsp.StatusCode;
                    var msg = resultGR.Message;
                    var content = resultGR is GenericResponse<TResponseBody?> resultGRT ? resultGRT.Result : default;
                    return ApiRspHelper.Code<TResponseBody?>(
                        code,
                        msg,
                        content);
                }
                else
                {
                    return ApiRspHelper.Code<TResponseBody?>(ApiRspCode.NoResponseContent);
                }
            }
            catch (Exception ex)
            {
                return ApiRspHelper.Code<TResponseBody?>(
                    ApiRspCode.ClientException,
                    "Serialize response fail",
                    default,
                    ex);
            }
        }
    }

    class Void
    {
        
/github.com/dotnet/runtime/blob/v7.0.11/src/libraries/System.Private.CoreLib/src/System/Void.cs
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\Settings\ASFSettings.cs
/ </auto-generated>

/ </summary>
    [MPKey(0), MP2Key(0), JsonPropertyOrder(0)]
    public string? ArchiSteamFarmExePath { get; set; } = IASFSettings.DefaultArchiSteamFarmExePath;

    
/ </summary>
    [MPKey(1), MP2Key(1), JsonPropertyOrder(1)]
    public bool AutoRunArchiSteamFarm { get; set; } = IASFSettings.DefaultAutoRunArchiSteamFarm;

    
/ </summary>
    [MPKey(2), MP2Key(2), JsonPropertyOrder(2)]
    public bool CheckArchiSteamFarmExe { get; set; } = IASFSettings.DefaultCheckArchiSteamFarmExe;

    
/ </summary>
    [MPKey(3), MP2Key(3), JsonPropertyOrder(3)]
    public int ConsoleMaxLineDefault { get; set; } = IASFSettings.DefaultConsoleMaxLineDefault;

    
/ </summary>
    [MPKey(4), MP2Key(4), JsonPropertyOrder(4)]
    public int MinRangeConsoleMaxLine { get; set; } = IASFSettings.DefaultMinRangeConsoleMaxLine;

    
/ </summary>
    [MPKey(5), MP2Key(5), JsonPropertyOrder(5)]
    public int MaxRangeConsoleMaxLine { get; set; } = IASFSettings.DefaultMaxRangeConsoleMaxLine;

    
/ </summary>
    [MPKey(6), MP2Key(6), JsonPropertyOrder(6)]
    public int ConsoleMaxLine { get; set; } = IASFSettings.DefaultConsoleMaxLine;

    
/ </summary>
    [MPKey(7), MP2Key(7), JsonPropertyOrder(7)]
    public int ConsoleFontSizeDefault { get; set; } = IASFSettings.DefaultConsoleFontSizeDefault;

    
/ </summary>
    [MPKey(8), MP2Key(8), JsonPropertyOrder(8)]
    public int MinRangeConsoleFontSize { get; set; } = IASFSettings.DefaultMinRangeConsoleFontSize;

    
/ </summary>
    [MPKey(9), MP2Key(9), JsonPropertyOrder(9)]
    public int MaxRangeConsoleFontSize { get; set; } = IASFSettings.DefaultMaxRangeConsoleFontSize;

    
/ </summary>
    [MPKey(10), MP2Key(10), JsonPropertyOrder(10)]
    public int ConsoleFontSize { get; set; } = IASFSettings.DefaultConsoleFontSize;

    
/ </summary>
    [MPKey(11), MP2Key(11), JsonPropertyOrder(11)]
    public int IPCPortIdValue { get; set; } = IASFSettings.DefaultIPCPortIdValue;

    
/ IPC 端口号，默认值为 <see cref="DefaultIPCPortIdValue" />
    
/ </summary>
    [MPKey(12), MP2Key(12), JsonPropertyOrder(12)]
    public int IPCPortId { get; set; } = IASFSettings.DefaultIPCPortId;

    
/ IPC 端口号被占用时是否随机一个未使用的端口号，默认值 <see langword="true" />
    
/ </summary>
    [MPKey(13), MP2Key(13), JsonPropertyOrder(13)]
    public bool IPCPortOccupiedRandom { get; set; } = IASFSettings.DefaultIPCPortOccupiedRandom;

}

public static partial class ASFSettings
{
    
/ </summary>
    public static SettingsProperty<string, ASFSettings_> ArchiSteamFarmExePath { get; }
        = new(DefaultArchiSteamFarmExePath);

    
/ </summary>
    public static SettingsStructProperty<bool, ASFSettings_> AutoRunArchiSteamFarm { get; }
        = new(DefaultAutoRunArchiSteamFarm);

    
/ </summary>
    public static SettingsStructProperty<bool, ASFSettings_> CheckArchiSteamFarmExe { get; }
        = new(DefaultCheckArchiSteamFarmExe);

    
/ </summary>
    public static SettingsStructProperty<int, ASFSettings_> ConsoleMaxLineDefault { get; }
        = new(DefaultConsoleMaxLineDefault);

    
/ </summary>
    public static SettingsStructProperty<int, ASFSettings_> MinRangeConsoleMaxLine { get; }
        = new(DefaultMinRangeConsoleMaxLine);

    
/ </summary>
    public static SettingsStructProperty<int, ASFSettings_> MaxRangeConsoleMaxLine { get; }
        = new(DefaultMaxRangeConsoleMaxLine);

    
/ </summary>
    public static SettingsStructProperty<int, ASFSettings_> ConsoleMaxLine { get; }
        = new(DefaultConsoleMaxLine);

    
/ </summary>
    public static SettingsStructProperty<int, ASFSettings_> ConsoleFontSizeDefault { get; }
        = new(DefaultConsoleFontSizeDefault);

    
/ </summary>
    public static SettingsStructProperty<int, ASFSettings_> MinRangeConsoleFontSize { get; }
        = new(DefaultMinRangeConsoleFontSize);

    
/ </summary>
    public static SettingsStructProperty<int, ASFSettings_> MaxRangeConsoleFontSize { get; }
        = new(DefaultMaxRangeConsoleFontSize);

    
/ </summary>
    public static SettingsStructProperty<int, ASFSettings_> ConsoleFontSize { get; }
        = new(DefaultConsoleFontSize);

    
/ </summary>
    public static SettingsStructProperty<int, ASFSettings_> IPCPortIdValue { get; }
        = new(DefaultIPCPortIdValue);

    
/ IPC 端口号，默认值为 <see cref="DefaultIPCPortIdValue" />
    
/ </summary>
    public static SettingsStructProperty<int, ASFSettings_> IPCPortId { get; }
        = new(DefaultIPCPortId);

    
/ IPC 端口号被占用时是否随机一个未使用的端口号，默认值 <see langword="true" />
    
/ </summary>
    public static SettingsStructProperty<bool, ASFSettings_> IPCPortOccupiedRandom { get; }
        = new(DefaultIPCPortOccupiedRandom);

}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\Settings\Abstractions\IASFSettings.cs
/ </auto-generated>

/ </summary>
    string? ArchiSteamFarmExePath { get; set; }

    
/ </summary>
    bool AutoRunArchiSteamFarm { get; set; }

    
/ </summary>
    bool CheckArchiSteamFarmExe { get; set; }

    
/ </summary>
    int ConsoleMaxLineDefault { get; set; }

    
/ </summary>
    int MinRangeConsoleMaxLine { get; set; }

    
/ </summary>
    int MaxRangeConsoleMaxLine { get; set; }

    
/ </summary>
    int ConsoleMaxLine { get; set; }

    
/ </summary>
    int ConsoleFontSizeDefault { get; set; }

    
/ </summary>
    int MinRangeConsoleFontSize { get; set; }

    
/ </summary>
    int MaxRangeConsoleFontSize { get; set; }

    
/ </summary>
    int ConsoleFontSize { get; set; }

    
/ </summary>
    int IPCPortIdValue { get; set; }

    
/ IPC 端口号，默认值为 <see cref="DefaultIPCPortIdValue" />
    
/ </summary>
    int IPCPortId { get; set; }

    
/ IPC 端口号被占用时是否随机一个未使用的端口号，默认值 <see langword="true" />
    
/ </summary>
    bool IPCPortOccupiedRandom { get; set; }

    
/ </summary>
    static readonly string DefaultArchiSteamFarmExePath = string.Empty;

    
/ </summary>
    static readonly bool DefaultAutoRunArchiSteamFarm = false;

    
/ </summary>
    static readonly bool DefaultCheckArchiSteamFarmExe = false;

    
/ </summary>
    const int DefaultConsoleMaxLineDefault = 200;

    
/ </summary>
    const int DefaultMinRangeConsoleMaxLine = DefaultConsoleMaxLineDefault;

    
/ </summary>
    const int DefaultMaxRangeConsoleMaxLine = 5000;

    
/ </summary>
    static readonly int DefaultConsoleMaxLine = DefaultConsoleMaxLineDefault;

    
/ </summary>
    const int DefaultConsoleFontSizeDefault = 14;

    
/ </summary>
    const int DefaultMinRangeConsoleFontSize = 8;

    
/ </summary>
    const int DefaultMaxRangeConsoleFontSize = 24;

    
/ </summary>
    static readonly int DefaultConsoleFontSize = DefaultConsoleFontSizeDefault;

    
/ </summary>
    const int DefaultIPCPortIdValue = 6242;

    
/ IPC 端口号，默认值为 <see cref="DefaultIPCPortIdValue" />的默认值
    
/ </summary>
    static readonly int DefaultIPCPortId = DefaultIPCPortIdValue;

    
/ IPC 端口号被占用时是否随机一个未使用的端口号，默认值 <see langword="true" />的默认值
    
/ </summary>
    static readonly bool DefaultIPCPortOccupiedRandom = true;

}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\UI\ViewModels\ArchiSteamFarmPlusPageViewModel.props.cs
/ </summary>
    public ICommand SelectASFExePath { get; }

    
/ </summary>
    public ICommand RunOrStop { get; }

    
/ </summary>
    public ICommand OpenWebUIConsole { get; }

    
/ </summary>
    public ICommand OpenASFBrowser { get; }

    private bool _IsRedeemKeyDialogOpen;

    public bool IsRedeemKeyDialogOpen
    {
        get => _IsRedeemKeyDialogOpen;
        set => this.RaiseAndSetIfChanged(ref _IsRedeemKeyDialogOpen, value);
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\UI\ViewModels\ASFSettingsPageViewModel.cs
/ 选择 <see cref="GlobalConfig"/> 全局配置文件
    
/ </summary>
    
/ <returns></returns>
    public async Task SelectGlobalFiles_Click()
    {
        if (!ASFService.Current.IsASFRuning)
        {
            Toast.Show(ToastIcon.Info, BDStrings.ASF_RequirRunASF, ToastLength.Short);
            return;
        }

        FilePickerFileType? fileTypes;
        if (IApplication.IsDesktop())
        {
            fileTypes = new ValueTuple<string, string[]>[]
            {
                    ("Json Files", new[] { FileEx.JSON, }),
                
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\UI\ViewModels\ASFSettingsPageViewModel.props.cs
/ </summary>
    public ICommand SelectGlobalFiles { get; }

    
/ </summary>
    public ICommand SetEncryptionKey { get; }

    
/ </summary>
    public ICommand OpenASFFolder { get; }

    
/ </summary>
    public ICommand RefreshGlobalConfig { get; }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\UI\ViewModels\BotPageViewModel.cs
/("All Files", new[] { "*", }),
            };
        }
        else if (OperatingSystem2.IsAndroid())
        {
            fileTypes = new[] { MediaTypeNames.JSON };
        }
        else
        {
            fileTypes = null;
        }
        await FilePicker2.PickMultipleAsync(ASFService.Current.ImportBotFiles, fileTypes);
    }

    public async void PauseOrResumeBotFarming_Click(Bot bot)
    {
        IApiRsp apiRsp = null;
        if (bot.CardsFarmer.Paused)
        {
            apiRsp = await asfService.BotResumeAsync(bot.BotName);
        }
        else
        {
            var request = new BotPauseRequest() { Permanent = true };
            apiRsp = await asfService.BotPauseAsync(bot.BotName, request);
        }

        if (apiRsp.IsSuccess)
            Toast.Show(ToastIcon.Success, apiRsp.Message);
        else
            Toast.Show(ToastIcon.Error, string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, apiRsp.Message));

        ASFService.Current.RefreshBots();
    }

    public async void EnableOrDisableBot_Click(Bot bot)
    {
        IApiRsp apiRsp;
        if (bot.KeepRunning)
            apiRsp = await asfService.BotStopAsync(bot.BotName);
        else
            apiRsp = await asfService.BotStartAsync(bot.BotName);

        if (!apiRsp.IsSuccess)
            Toast.Show(ToastIcon.Error, string.Format(CultureInfo.CurrentCulture, Strings.WarningFailedWithError, apiRsp.Message));
    }

    public async Task<(IReadOnlyDictionary<string, string>? UnusedKeys, IReadOnlyDictionary<string, string>? UsedKeys)> GetUsedAndUnusedKeys_Click(Bot bot)
    {
        var r = await asfService.BotGetUsedAndUnusedKeysAsync(bot.BotName);
        if (r.IsSuccess && r.Content.TryGetValue(bot.BotName, out var response))
            return (response.UnusedKeys, response.UsedKeys);
        return default;
    }

    public async void RedeemKeyBot_Click(Bot bot, IOrderedDictionary keys)
    {
        var request = new BotGamesToRedeemInBackgroundRequest() { GamesToRedeemInBackground = (OrderedDictionary)keys };
        await asfService.BotRedeemKeyAsync(bot.BotName, request);
    }

    public async Task<bool> ResetBotRedeemedKeysRecord_Click(Bot bot)
    {
        var r = await asfService.BotResetRedeemedKeysRecordAsync(bot.BotName);
        return r.IsSuccess;
    }

    public async void GoToBotSettings_Click(Bot bot)
    {
        await Browser2.OpenAsync(ASFService.Current.IPCUrl + "/bot/" + bot.BotName + "/config", BrowserLaunchMode.External);
    }

    public void EditBotFile_Click(Bot bot)
    {
        var filePath = Path.Combine(SharedInfo.HomeDirectory, SharedInfo.ConfigDirectory, $"{bot.BotName}{SharedInfo.JsonConfigExtension}");
        IPlatformService.Instance.OpenFileByTextReader(filePath);
    }

    public async void DeleteBot_Click(Bot bot)
    {
        var s = await MessageBox.ShowAsync(BDStrings.ASF_DeleteBotTip, button: MessageBox.Button.OKCancel);
        if (s == MessageBox.Result.OK)
        {
            var result = await asfService.BotDeleteAsync(bot.BotName);
            if (result.IsSuccess)
            {
                ASFService.Current.SteamBotsSourceList.Remove(bot);
                Toast.Show(ToastIcon.Success, BDStrings.ASF_DeleteBotSuccess);
            }
        }
    }

    public async void ShowAddBotWindow()
    {
        await IWindowManager.Instance.ShowAsync(AppEndPoint.ASF_AddBot, resizeMode: ResizeMode.CanResize);
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\UI\ViewModels\BotPageViewModel.props.cs
/ </summary>
    private readonly ReadOnlyObservableCollection<BotViewModel> _SteamBots;

    
/ </summary>
    public ReadOnlyObservableCollection<BotViewModel> SteamBots => _SteamBots;

    
/ </summary>
    public ICommand AddBot { get; }

    
/ </summary>
    public ICommand RefreshBots { get; }

    
/ </summary>
    public ICommand SelectBotFiles { get; }

    
/ </summary>
    public ICommand PauseOrResumeBotFarming { get; }

    
/ </summary>
    public ICommand EnableOrDisableBot { get; }

    
/ </summary>
    public ICommand GoToBotSettings { get; }

    
/ </summary>
    public ICommand DeleteBot { get; }

    
/ </summary>
    public ICommand EditBotFile { get; }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\UI\Views\Controls\ConsoleShell.axaml.cs
/ Defines the <see cref="InputIndicator"/> property.
    
/ </summary>
    public static readonly StyledProperty<string> InputIndicatorProperty =
        AvaloniaProperty.Register<ConsoleShell, string>(nameof(InputIndicator), string.Empty);

    
/ Defines the <see cref="IsMask"/> property.
    
/ </summary>
    public static readonly StyledProperty<bool> IsMaskProperty =
        AvaloniaProperty.Register<ConsoleShell, bool>(nameof(IsMask), false);

    
/ Defines the <see cref="LogText"/> property.
    
/ </summary>
    public static readonly StyledProperty<string> LogTextProperty =
        AvaloniaProperty.Register<ConsoleShell, string>(nameof(LogText), string.Empty);

    
/ Defines the <see cref="MaxLine"/> property.
    
/ </summary>
    public static readonly StyledProperty<int> MaxLineProperty =
        AvaloniaProperty.Register<ConsoleShell, int>(nameof(MaxLine), 300);

    
/ </summary>
    public static readonly StyledProperty<IEnumerable?> AutoCompleteBoxItemsProperty =
        ItemsControl.ItemsSourceProperty.AddOwner<ConsoleShell>();

    
/ </summary>
    public static readonly StyledProperty<IDataTemplate> AutoCompleteBoxItemTemplateProperty =
        AvaloniaProperty.Register<ConsoleShell, IDataTemplate>(nameof(AutoCompleteBoxItemTemplate));

    private IEnumerable _autoCompleteBoxItems = new AvaloniaList<object>();

    
/ </summary>
    public IEnumerable AutoCompleteBoxItems
    {
        get
        {
            return _autoCompleteBoxItems;
        }

        set
        {
            SetValue(AutoCompleteBoxItemsProperty, value);
        }
    }

    
/ </summary>
    public IDataTemplate AutoCompleteBoxItemTemplate
    {
        get
        {
            return GetValue(AutoCompleteBoxItemTemplateProperty);
        }
        set => SetValue(AutoCompleteBoxItemTemplateProperty, value);
    }

    
/ </summary>
    public string InputIndicator
    {
        get => GetValue(InputIndicatorProperty);
        set => SetValue(InputIndicatorProperty, value);
    }

    
/ </summary>
    public bool IsMask
    {
        get => GetValue(IsMaskProperty);
        set => SetValue(IsMaskProperty, value);
    }

    
/ </summary>
    public string LogText
    {
        get => GetValue(LogTextProperty);
        set => SetValue(LogTextProperty, value);
    }

    
/ </summary>
    public int MaxLine
    {
        get => GetValue(MaxLineProperty);
        set => SetValue(MaxLineProperty, value);
    }

    private CommandEventArgs? _commandSubmitArgs;

    
/ </summary>
    public event EventHandler<CommandEventArgs>? CommandSubmit;

    
/ </summary>
    public ConsoleShell()
    {
        InitializeComponent();

        commandHistory = new();
        
/    logTextbox.MaxLength = (int)(logTextbox.Width / (logTextbox.FontSize + logTextbox.LetterSpacing)) * logTextbox.MaxLines;
                logTextbox.Text = LogText;
                commandTextbox.Focus();
                logTextbox.ScrollToLine(logTextbox.Document.LineCount);
                
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\_\ArchiSteamFarm\IPC\Requests\ASFEncryptRequest.cs
/    / \    _ __  ___ | |__  (_)/ ___| | |_  ___   __ _  _ __ ___  |  ___|__ _  _ __  _ __ ___

/   / _ \  | '__|/ __|| '_ \ | |\___ \ | __|/ _ \ / _` || '_ ` _ \ | |_  / _` || '__|| '_ ` _ \

/  / ___ \ | |  | (__ | | | || | ___) || |_|  __/| (_| || | | | | ||  _|| (_| || |   | | | | | |

/ /_/   \_\|_|   \___||_| |_||_||____/  \__|\___| \__,_||_| |_| |_||_|   \__,_||_|   |_| |_| |_|

/www.apache.org/licenses/LICENSE-2.0

/ </summary>
    [JsonProperty(Required = Required.Always)]
    [Required]
    public ArchiCryptoHelper.ECryptoMethod CryptoMethod { get; private set; }

    
/     String to encrypt with provided <see cref="CryptoMethod" />.
    
/ </summary>
    [JsonProperty(Required = Required.Always)]
    [Required]
    public string StringToEncrypt { get; set; } = "";

    [JsonConstructor]
    public ASFEncryptRequest() { }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\_\ArchiSteamFarm\IPC\Requests\ASFHashRequest.cs
/    / \    _ __  ___ | |__  (_)/ ___| | |_  ___   __ _  _ __ ___  |  ___|__ _  _ __  _ __ ___

/   / _ \  | '__|/ __|| '_ \ | |\___ \ | __|/ _ \ / _` || '_ ` _ \ | |_  / _` || '__|| '_ ` _ \

/  / ___ \ | |  | (__ | | | || | ___) || |_|  __/| (_| || | | | | ||  _|| (_| || |   | | | | | |

/ /_/   \_\|_|   \___||_| |_||_||____/  \__|\___| \__,_||_| |_| |_||_|   \__,_||_|   |_| |_| |_|

/www.apache.org/licenses/LICENSE-2.0

/ </summary>
    [JsonProperty(Required = Required.Always)]
    [Required]
    public ArchiCryptoHelper.EHashingMethod HashingMethod { get; private set; }

    
/     String to hash with provided <see cref="HashingMethod" />.
    
/ </summary>
    [JsonProperty(Required = Required.Always)]
    [Required]
    public string StringToHash { get; set; } = "";

    [JsonConstructor]
    public ASFHashRequest() { }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\_\ArchiSteamFarm\IPC\Requests\ASFRequest.cs
/    / \    _ __  ___ | |__  (_)/ ___| | |_  ___   __ _  _ __ ___  |  ___|__ _  _ __  _ __ ___

/   / _ \  | '__|/ __|| '_ \ | |\___ \ | __|/ _ \ / _` || '_ ` _ \ | |_  / _` || '__|| '_ ` _ \

/  / ___ \ | |  | (__ | | | || | ___) || |_|  __/| (_| || | | | | ||  _|| (_| || |   | | | | | |

/ /_/   \_\|_|   \___||_| |_||_||____/  \__|\___| \__,_||_| |_| |_||_|   \__,_||_|   |_| |_| |_|

/www.apache.org/licenses/LICENSE-2.0

/ </summary>
    [JsonProperty(Required = Required.Always)]
    [Required]
    public GlobalConfig GlobalConfig { get; set; } = new();

    [JsonConstructor]
    public ASFRequest() { }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\_\ArchiSteamFarm\IPC\Requests\BotGamesToRedeemInBackgroundRequest.cs
/    / \    _ __  ___ | |__  (_)/ ___| | |_  ___   __ _  _ __ ___  |  ___|__ _  _ __  _ __ ___

/   / _ \  | '__|/ __|| '_ \ | |\___ \ | __|/ _ \ / _` || '_ ` _ \ | |_  / _` || '__|| '_ ` _ \

/  / ___ \ | |  | (__ | | | || | ___) || |_|  __/| (_| || | | | | ||  _|| (_| || |   | | | | | |

/ /_/   \_\|_|   \___||_| |_||_||____/  \__|\___| \__,_||_| |_| |_||_|   \__,_||_|   |_| |_| |_|

/www.apache.org/licenses/LICENSE-2.0

/ </summary>
    
/ </remarks>
    [JsonProperty(Required = Required.Always)]
    [Required]
    public OrderedDictionary GamesToRedeemInBackground { get; set; } = new();

    [JsonConstructor]
    public BotGamesToRedeemInBackgroundRequest() { }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\_\ArchiSteamFarm\IPC\Requests\BotInputRequest.cs
/    / \    _ __  ___ | |__  (_)/ ___| | |_  ___   __ _  _ __ ___  |  ___|__ _  _ __  _ __ ___

/   / _ \  | '__|/ __|| '_ \ | |\___ \ | __|/ _ \ / _` || '_ ` _ \ | |_  / _` || '__|| '_ ` _ \

/  / ___ \ | |  | (__ | | | || | ___) || |_|  __/| (_| || | | | | ||  _|| (_| || |   | | | | | |

/ /_/   \_\|_|   \___||_| |_||_||____/  \__|\___| \__,_||_| |_| |_||_|   \__,_||_|   |_| |_| |_|

/www.apache.org/licenses/LICENSE-2.0

/ </summary>
    [JsonProperty(Required = Required.Always)]
    public ASF.EUserInputType Type { get; set; }

    
/     Specifies the value for given input type (declared in <see cref="Type" />)
    
/ </summary>
    [JsonProperty(Required = Required.Always)]
    public string Value { get; private set; } = "";

    [JsonConstructor]
    public BotInputRequest() { }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\_\ArchiSteamFarm\IPC\Requests\BotPauseRequest.cs
/    / \    _ __  ___ | |__  (_)/ ___| | |_  ___   __ _  _ __ ___  |  ___|__ _  _ __  _ __ ___

/   / _ \  | '__|/ __|| '_ \ | |\___ \ | __|/ _ \ / _` || '_ ` _ \ | |_  / _` || '__|| '_ ` _ \

/  / ___ \ | |  | (__ | | | || | ___) || |_|  __/| (_| || | | | | ||  _|| (_| || |   | | | | | |

/ /_/   \_\|_|   \___||_| |_||_||____/  \__|\___| \__,_||_| |_| |_||_|   \__,_||_|   |_| |_| |_|

/www.apache.org/licenses/LICENSE-2.0

/ </summary>
    [JsonProperty(Required = Required.DisallowNull)]
    public bool Permanent { get; set; }

    
/ </summary>
    [JsonProperty(Required = Required.DisallowNull)]
    public ushort ResumeInSeconds { get; private set; } = 0;

    [JsonConstructor]
    public BotPauseRequest() { }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\_\ArchiSteamFarm\IPC\Requests\BotRedeemRequest.cs
/    / \    _ __  ___ | |__  (_)/ ___| | |_  ___   __ _  _ __ ___  |  ___|__ _  _ __  _ __ ___

/   / _ \  | '__|/ __|| '_ \ | |\___ \ | __|/ _ \ / _` || '_ ` _ \ | |_  / _` || '__|| '_ ` _ \

/  / ___ \ | |  | (__ | | | || | ___) || |_|  __/| (_| || | | | | ||  _|| (_| || |   | | | | | |

/ /_/   \_\|_|   \___||_| |_||_||____/  \__|\___| \__,_||_| |_| |_||_|   \__,_||_|   |_| |_| |_|

/www.apache.org/licenses/LICENSE-2.0

/ </summary>
    [JsonProperty(Required = Required.Always)]
    [Required]
    public ImmutableHashSet<string> KeysToRedeem { get; set; } = ImmutableHashSet<string>.Empty;

    [JsonConstructor]
    public BotRedeemRequest() { }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\_\ArchiSteamFarm\IPC\Requests\BotRenameRequest.cs
/    / \    _ __  ___ | |__  (_)/ ___| | |_  ___   __ _  _ __ ___  |  ___|__ _  _ __  _ __ ___

/   / _ \  | '__|/ __|| '_ \ | |\___ \ | __|/ _ \ / _` || '_ ` _ \ | |_  / _` || '__|| '_ ` _ \

/  / ___ \ | |  | (__ | | | || | ___) || |_|  __/| (_| || | | | | ||  _|| (_| || |   | | | | | |

/ /_/   \_\|_|   \___||_| |_||_||____/  \__|\___| \__,_||_| |_| |_||_|   \__,_||_|   |_| |_| |_|

/www.apache.org/licenses/LICENSE-2.0

/ </summary>
    [JsonProperty(Required = Required.Always)]
    [Required]
    public string NewName { get; set; } = "";

    [JsonConstructor]
    public BotRenameRequest() { }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\_\ArchiSteamFarm\IPC\Requests\BotRequest.cs
/    / \    _ __  ___ | |__  (_)/ ___| | |_  ___   __ _  _ __ ___  |  ___|__ _  _ __  _ __ ___

/   / _ \  | '__|/ __|| '_ \ | |\___ \ | __|/ _ \ / _` || '_ ` _ \ | |_  / _` || '__|| '_ ` _ \

/  / ___ \ | |  | (__ | | | || | ___) || |_|  __/| (_| || | | | | ||  _|| (_| || |   | | | | | |

/ /_/   \_\|_|   \___||_| |_||_||____/  \__|\___| \__,_||_| |_| |_||_|   \__,_||_|   |_| |_| |_|

/www.apache.org/licenses/LICENSE-2.0

/ </summary>
    [JsonProperty(Required = Required.Always)]
    [Required]
    public BotConfig BotConfig { get; set; } = new();

    [JsonConstructor]
    public BotRequest() { }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\_\ArchiSteamFarm\IPC\Requests\CommandRequest.cs
/    / \    _ __  ___ | |__  (_)/ ___| | |_  ___   __ _  _ __ ___  |  ___|__ _  _ __  _ __ ___

/   / _ \  | '__|/ __|| '_ \ | |\___ \ | __|/ _ \ / _` || '_ ` _ \ | |_  / _` || '__|| '_ ` _ \

/  / ___ \ | |  | (__ | | | || | ___) || |_|  __/| (_| || | | | | ||  _|| (_| || |   | | | | | |

/ /_/   \_\|_|   \___||_| |_||_||____/  \__|\___| \__,_||_| |_| |_||_|   \__,_||_|   |_| |_| |_|

/www.apache.org/licenses/LICENSE-2.0

/ </summary>
    [JsonProperty(Required = Required.Always)]
    [Required]
    public string Command { get; private set; } = "";

    internal CommandRequest(string command)
    {
        if (string.IsNullOrEmpty(command))
        {
            throw new ArgumentNullException(nameof(command));
        }

        Command = command;
    }

    [JsonConstructor]
    public CommandRequest() { }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\_\ArchiSteamFarm\IPC\Requests\TwoFactorAuthenticationConfirmationsRequest.cs
/    / \    _ __  ___ | |__  (_)/ ___| | |_  ___   __ _  _ __ ___  |  ___|__ _  _ __  _ __ ___

/   / _ \  | '__|/ __|| '_ \ | |\___ \ | __|/ _ \ / _` || '_ ` _ \ | |_  / _` || '__|| '_ ` _ \

/  / ___ \ | |  | (__ | | | || | ___) || |_|  __/| (_| || | | | | ||  _|| (_| || |   | | | | | |

/ /_/   \_\|_|   \___||_| |_||_||____/  \__|\___| \__,_||_| |_| |_||_|   \__,_||_|   |_| |_| |_|

/www.apache.org/licenses/LICENSE-2.0

/ </summary>
    [JsonProperty(Required = Required.Always)]
    public bool Accept { get; private set; }

    
/ </summary>
    [JsonProperty(Required = Required.DisallowNull)]
    public ImmutableHashSet<ulong> AcceptedCreatorIDs { get; private set; } = ImmutableHashSet<ulong>.Empty;

    
/ </summary>
    [JsonProperty]
    public Confirmation.EConfirmationType? AcceptedType { get; private set; }

    
/     A helper property which works the same as <see cref="AcceptedCreatorIDs" /> but with values written as strings - for javascript compatibility purposes. Use either this one, or <see cref="AcceptedCreatorIDs" />, not both.
    
/ </summary>
    [JsonProperty($"{SharedInfo.UlongCompatibilityStringPrefix}{nameof(AcceptedCreatorIDs)}", Required = Required.DisallowNull)]
    public ImmutableHashSet<string> SAcceptedCreatorIDs
    {
        get => AcceptedCreatorIDs.Select(static creatorID => creatorID.ToString(CultureInfo.InvariantCulture)).ToImmutableHashSet();
        set
        {
            ArgumentNullException.ThrowIfNull(value);

            HashSet<ulong> acceptedCreatorIDs = new();

            foreach (string creatorIDText in value)
            {
                if (!ulong.TryParse(creatorIDText, out ulong creatorID) || (creatorID == 0))
                {
                    ASF.ArchiLogger.LogGenericError(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(SAcceptedCreatorIDs)));

                    return;
                }

                acceptedCreatorIDs.Add(creatorID);
            }

            AcceptedCreatorIDs = acceptedCreatorIDs.ToImmutableHashSet();
        }
    }

    
/     Specifies whether we should wait for the confirmations to arrive, in case they're not available immediately. This option makes sense only if <see cref="AcceptedCreatorIDs" /> is specified as well, and in this case ASF will add a few more tries if needed to ensure that all specified IDs are handled. Useful if confirmations are generated with a delay on Steam network side, which happens fairly often.
    
/ </summary>
    [JsonProperty(Required = Required.DisallowNull)]
    public bool WaitIfNeeded { get; private set; }

    [JsonConstructor]
    public TwoFactorAuthenticationConfirmationsRequest() { }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\_\ArchiSteamFarm\IPC\Requests\UpdateRequest.cs
/    / \    _ __  ___ | |__  (_)/ ___| | |_  ___   __ _  _ __ ___  |  ___|__ _  _ __  _ __ ___

/   / _ \  | '__|/ __|| '_ \ | |\___ \ | __|/ _ \ / _` || '_ ` _ \ | |_  / _` || '__|| '_ ` _ \

/  / ___ \ | |  | (__ | | | || | ___) || |_|  __/| (_| || | | | | ||  _|| (_| || |   | | | | | |

/ /_/   \_\|_|   \___||_| |_||_||____/  \__|\___| \__,_||_| |_| |_||_|   \__,_||_|   |_| |_| |_|

/www.apache.org/licenses/LICENSE-2.0

/ </summary>
    [JsonProperty(Required = Required.DisallowNull)]
    public GlobalConfig.EUpdateChannel? Channel { get; set; }

    [JsonConstructor]
    public UpdateRequest() { }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\_\ArchiSteamFarm\IPC\Responses\ASFResponse.cs
/    / \    _ __  ___ | |__  (_)/ ___| | |_  ___   __ _  _ __ ___  |  ___|__ _  _ __  _ __ ___

/   / _ \  | '__|/ __|| '_ \ | |\___ \ | __|/ _ \ / _` || '_ ` _ \ | |_  / _` || '__|| '_ ` _ \

/  / ___ \ | |  | (__ | | | || | ___) || |_|  __/| (_| || | | | | ||  _|| (_| || |   | | | | | |

/ /_/   \_\|_|   \___||_| |_||_||____/  \__|\___| \__,_||_| |_| |_||_|   \__,_||_|   |_| |_| |_|

/www.apache.org/licenses/LICENSE-2.0

/ </summary>
    [JsonProperty(Required = Required.Always)]
    [Required]
    public string BuildVariant { get; private set; } = "";

    
/ </summary>
    [JsonProperty(Required = Required.Always)]
    [Required]
    public bool CanUpdate { get; private set; }

    
/ </summary>
    [JsonProperty(Required = Required.Always)]
    [Required]
    public GlobalConfig? GlobalConfig { get; private set; }

    
/ </summary>
    [JsonProperty(Required = Required.Always)]
    [Required]
    public uint MemoryUsage { get; private set; }

    
/ </summary>
    [JsonProperty(Required = Required.Always)]
    [Required]
    public DateTime ProcessStartTime { get; private set; }

    
/ </summary>
    [JsonProperty(Required = Required.Always)]
    [Required]
    public bool Service { get; private set; }

    
/ </summary>
    [JsonProperty(Required = Required.Always)]
    [Required]
    public Version? Version { get; private set; }

    [JsonConstructor]
    public ASFResponse()
    {

    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\_\ArchiSteamFarm\IPC\Responses\GamesToRedeemInBackgroundResponse.cs
/    / \    _ __  ___ | |__  (_)/ ___| | |_  ___   __ _  _ __ ___  |  ___|__ _  _ __  _ __ ___

/   / _ \  | '__|/ __|| '_ \ | |\___ \ | __|/ _ \ / _` || '_ ` _ \ | |_  / _` || '__|| '_ ` _ \

/  / ___ \ | |  | (__ | | | || | ___) || |_|  __/| (_| || | | | | ||  _|| (_| || |   | | | | | |

/ /_/   \_\|_|   \___||_| |_||_||____/  \__|\___| \__,_||_| |_| |_||_|   \__,_||_|   |_| |_| |_|

/www.apache.org/licenses/LICENSE-2.0

/ </summary>
    [JsonProperty]
    public Dictionary<string, string>? UnusedKeys { get; private set; }

    
/ </summary>
    [JsonProperty]
    public Dictionary<string, string>? UsedKeys { get; private set; }

    [JsonConstructor]
    public GamesToRedeemInBackgroundResponse()
    {

    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\_\ArchiSteamFarm\IPC\Responses\GenericResponse.cs
/    / \    _ __  ___ | |__  (_)/ ___| | |_  ___   __ _  _ __ ___  |  ___|__ _  _ __  _ __ ___

/   / _ \  | '__|/ __|| '_ \ | |\___ \ | __|/ _ \ / _` || '_ ` _ \ | |_  / _` || '__|| '_ ` _ \

/  / ___ \ | |  | (__ | | | || | ___) || |_|  __/| (_| || | | | | ||  _|| (_| || |   | | | | | |

/ /_/   \_\|_|   \___||_| |_||_||____/  \__|\___| \__,_||_| |_| |_||_|   \__,_||_|   |_| |_| |_|

/www.apache.org/licenses/LICENSE-2.0

/ </summary>
    
/ </remarks>
    [JsonProperty]
    public T? Result { get; private set; }

    public GenericResponse(T? result) : base(result is not null) => Result = result;

    public GenericResponse(bool success, string? message) : base(success, message) { }

    public GenericResponse(bool success, T? result) : base(success) => Result = result;

    public GenericResponse(bool success, string? message, T? result) : base(success, message) => Result = result;

    [JsonConstructor]
    private GenericResponse() { }
}

public class GenericResponse
{
    
/ </summary>
    
/ </remarks>
    [JsonProperty]
    public string? Message { get; private set; }

    
/ </summary>
    [JsonProperty(Required = Required.Always)]
    [Required]
    public bool Success { get; private set; }

    public GenericResponse(bool success, string? message = null)
    {
        Success = success;

        
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\_\ArchiSteamFarm\IPC\Responses\GitHubReleaseResponse.cs
/    / \    _ __  ___ | |__  (_)/ ___| | |_  ___   __ _  _ __ ___  |  ___|__ _  _ __  _ __ ___

/   / _ \  | '__|/ __|| '_ \ | |\___ \ | __|/ _ \ / _` || '_ ` _ \ | |_  / _` || '__|| '_ ` _ \

/  / ___ \ | |  | (__ | | | || | ___) || |_|  __/| (_| || | | | | ||  _|| (_| || |   | | | | | |

/ /_/   \_\|_|   \___||_| |_||_||____/  \__|\___| \__,_||_| |_| |_||_|   \__,_||_|   |_| |_| |_|

/www.apache.org/licenses/LICENSE-2.0

/ </summary>
    [JsonProperty(Required = Required.Always)]
    [Required]
    public string ChangelogHTML { get; private set; } = "";

    
/ </summary>
    [JsonProperty(Required = Required.Always)]
    [Required]
    public DateTime ReleasedAt { get; private set; }

    
/ </summary>
    [JsonProperty(Required = Required.Always)]
    [Required]
    public bool Stable { get; private set; }

    
/ </summary>
    [JsonProperty(Required = Required.Always)]
    [Required]
    public string Version { get; private set; } = "";

    [JsonConstructor]
    public GitHubReleaseResponse()
    {

    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\_\ArchiSteamFarm\IPC\Responses\LogResponse.cs
/    / \    _ __  ___ | |__  (_)/ ___| | |_  ___   __ _  _ __ ___  |  ___|__ _  _ __  _ __ ___

/   / _ \  | '__|/ __|| '_ \ | |\___ \ | __|/ _ \ / _` || '_ ` _ \ | |_  / _` || '__|| '_ ` _ \

/  / ___ \ | |  | (__ | | | || | ___) || |_|  __/| (_| || | | | | ||  _|| (_| || |   | | | | | |

/ /_/   \_\|_|   \___||_| |_||_||____/  \__|\___| \__,_||_| |_| |_||_|   \__,_||_|   |_| |_| |_|

/www.apache.org/licenses/LICENSE-2.0

/ </summary>
    [JsonProperty(Required = Required.Always)]
    [Required]
    public IReadOnlyList<string>? Content { get; private set; }

    
/ </summary>
    [JsonProperty(Required = Required.Always)]
    [Required]
    public int TotalLines { get; private set; }

    [JsonConstructor]
    public LogResponse()
    {

    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\_\ArchiSteamFarm\IPC\Responses\StatusCodeResponse.cs
/    / \    _ __  ___ | |__  (_)/ ___| | |_  ___   __ _  _ __ ___  |  ___|__ _  _ __  _ __ ___

/   / _ \  | '__|/ __|| '_ \ | |\___ \ | __|/ _ \ / _` || '_ ` _ \ | |_  / _` || '__|| '_ ` _ \

/  / ___ \ | |  | (__ | | | || | ___) || |_|  __/| (_| || | | | | ||  _|| (_| || |   | | | | | |

/ /_/   \_\|_|   \___||_| |_||_||____/  \__|\___| \__,_||_| |_| |_||_|   \__,_||_|   |_| |_| |_|

/www.apache.org/licenses/LICENSE-2.0

/ </summary>
    [JsonProperty(Required = Required.Always)]
    [Required]
    public bool Permanent { get; private set; }

    
/ </summary>
    [JsonProperty(Required = Required.Always)]
    [Required]
    public HttpStatusCode StatusCode { get; private set; }

    [JsonConstructor]
    public StatusCodeResponse()
    {

    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\_\ArchiSteamFarm\IPC\Responses\TypeProperties.cs
/    / \    _ __  ___ | |__  (_)/ ___| | |_  ___   __ _  _ __ ___  |  ___|__ _  _ __  _ __ ___

/   / _ \  | '__|/ __|| '_ \ | |\___ \ | __|/ _ \ / _` || '_ ` _ \ | |_  / _` || '__|| '_ ` _ \

/  / ___ \ | |  | (__ | | | || | ___) || |_|  __/| (_| || | | | | ||  _|| (_| || |   | | | | | |

/ /_/   \_\|_|   \___||_| |_||_||____/  \__|\___| \__,_||_| |_| |_||_|   \__,_||_|   |_| |_| |_|

/www.apache.org/licenses/LICENSE-2.0

/ </summary>
    
/ </remarks>
    [JsonProperty]
    public string? BaseType { get; private set; }

    
/ </summary>
    
/     This can be used for determining main enum type if <see cref="BaseType" /> is <see cref="Enum" />.
    
/ </remarks>
    [JsonProperty]
    public HashSet<string>? CustomAttributes { get; private set; }

    
/ </summary>
    
/     This can be used for determining underlying enum type if <see cref="BaseType" /> is <see cref="Enum" />.
    
/ </remarks>
    [JsonProperty]
    public string? UnderlyingType { get; private set; }

    [JsonConstructor]
    public TypeProperties()
    {

    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\_\ArchiSteamFarm\IPC\Responses\TypeResponse.cs
/    / \    _ __  ___ | |__  (_)/ ___| | |_  ___   __ _  _ __ ___  |  ___|__ _  _ __  _ __ ___

/   / _ \  | '__|/ __|| '_ \ | |\___ \ | __|/ _ \ / _` || '_ ` _ \ | |_  / _` || '__|| '_ ` _ \

/  / ___ \ | |  | (__ | | | || | ___) || |_|  __/| (_| || | | | | ||  _|| (_| || |   | | | | | |

/ /_/   \_\|_|   \___||_| |_||_||____/  \__|\___| \__,_||_| |_| |_||_|   \__,_||_|   |_| |_| |_|

/www.apache.org/licenses/LICENSE-2.0

/ </summary>
    
/     The actual structure of this field depends on the type that was requested. You can determine that type based on <see cref="Properties" /> metadata.
    
/ </remarks>
    [JsonProperty(Required = Required.Always)]
    [Required]
    public Dictionary<string, string>? Body { get; private set; }

    
/ </summary>
    [JsonProperty(Required = Required.Always)]
    [Required]
    public TypeProperties? Properties { get; private set; }

    [JsonConstructor]
    public TypeResponse()
    {

    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\_\ArchiSteamFarm\Localization\Strings.Designer.cs
/ </auto-generated>

/ </summary>
    
/ (以 /str 作为命令选项)，或重新生成 VS 项目。
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    public class Strings {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Strings() {
        }
        
        
/ </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("BD.WTTS._.ArchiSteamFarm.Localization.Strings", typeof(Strings).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        
/ </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        
/ </summary>
        public static string AcceptingTrade {
            get {
                return ResourceManager.GetString("AcceptingTrade", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ActivelyMatchingItems {
            get {
                return ResourceManager.GetString("ActivelyMatchingItems", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string AutomaticFileMigration {
            get {
                return ResourceManager.GetString("AutomaticFileMigration", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string AutoUpdateCheckInfo {
            get {
                return ResourceManager.GetString("AutoUpdateCheckInfo", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotAcceptedDonationTrade {
            get {
                return ResourceManager.GetString("BotAcceptedDonationTrade", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotAcceptingGift {
            get {
                return ResourceManager.GetString("BotAcceptingGift", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotAccountFree {
            get {
                return ResourceManager.GetString("BotAccountFree", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotAccountLimited {
            get {
                return ResourceManager.GetString("BotAccountLimited", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotAccountLocked {
            get {
                return ResourceManager.GetString("BotAccountLocked", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotAccountOccupied {
            get {
                return ResourceManager.GetString("BotAccountOccupied", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotAddLicense {
            get {
                return ResourceManager.GetString("BotAddLicense", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotAddLicenseWithItems {
            get {
                return ResourceManager.GetString("BotAddLicenseWithItems", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotAlreadyRunning {
            get {
                return ResourceManager.GetString("BotAlreadyRunning", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotAlreadyStopped {
            get {
                return ResourceManager.GetString("BotAlreadyStopped", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotAuthenticatorConverting {
            get {
                return ResourceManager.GetString("BotAuthenticatorConverting", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotAuthenticatorImportFinished {
            get {
                return ResourceManager.GetString("BotAuthenticatorImportFinished", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotAuthenticatorToken {
            get {
                return ResourceManager.GetString("BotAuthenticatorToken", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotAutomaticIdlingNowPaused {
            get {
                return ResourceManager.GetString("BotAutomaticIdlingNowPaused", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotAutomaticIdlingNowResumed {
            get {
                return ResourceManager.GetString("BotAutomaticIdlingNowResumed", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotAutomaticIdlingPausedAlready {
            get {
                return ResourceManager.GetString("BotAutomaticIdlingPausedAlready", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotAutomaticIdlingResumedAlready {
            get {
                return ResourceManager.GetString("BotAutomaticIdlingResumedAlready", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotConnected {
            get {
                return ResourceManager.GetString("BotConnected", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotConnecting {
            get {
                return ResourceManager.GetString("BotConnecting", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotConnectionLost {
            get {
                return ResourceManager.GetString("BotConnectionLost", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotDisconnected {
            get {
                return ResourceManager.GetString("BotDisconnected", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotDisconnecting {
            get {
                return ResourceManager.GetString("BotDisconnecting", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotExtraIdlingCooldown {
            get {
                return ResourceManager.GetString("BotExtraIdlingCooldown", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotGamesToRedeemInBackgroundCount {
            get {
                return ResourceManager.GetString("BotGamesToRedeemInBackgroundCount", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotGeneratingSteamParentalCode {
            get {
                return ResourceManager.GetString("BotGeneratingSteamParentalCode", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotHandledConfirmations {
            get {
                return ResourceManager.GetString("BotHandledConfirmations", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotHasNoWallet {
            get {
                return ResourceManager.GetString("BotHasNoWallet", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotHeartBeatFailed {
            get {
                return ResourceManager.GetString("BotHeartBeatFailed", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotIdlingSelectedGames {
            get {
                return ResourceManager.GetString("BotIdlingSelectedGames", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotInstanceNotStartingBecauseDisabled {
            get {
                return ResourceManager.GetString("BotInstanceNotStartingBecauseDisabled", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotInvalidAuthenticatorDuringLogin {
            get {
                return ResourceManager.GetString("BotInvalidAuthenticatorDuringLogin", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotInvalidPasswordDuringLogin {
            get {
                return ResourceManager.GetString("BotInvalidPasswordDuringLogin", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotLevel {
            get {
                return ResourceManager.GetString("BotLevel", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotLoggedOff {
            get {
                return ResourceManager.GetString("BotLoggedOff", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotLoggedOn {
            get {
                return ResourceManager.GetString("BotLoggedOn", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotLoggingIn {
            get {
                return ResourceManager.GetString("BotLoggingIn", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotLogonSessionReplaced {
            get {
                return ResourceManager.GetString("BotLogonSessionReplaced", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotLootingFailed {
            get {
                return ResourceManager.GetString("BotLootingFailed", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotLootingMasterNotDefined {
            get {
                return ResourceManager.GetString("BotLootingMasterNotDefined", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotLootingSuccess {
            get {
                return ResourceManager.GetString("BotLootingSuccess", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotNoASFAuthenticator {
            get {
                return ResourceManager.GetString("BotNoASFAuthenticator", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotNotConnected {
            get {
                return ResourceManager.GetString("BotNotConnected", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotNotFound {
            get {
                return ResourceManager.GetString("BotNotFound", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotNotOwnedYet {
            get {
                return ResourceManager.GetString("BotNotOwnedYet", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotOwnedAlready {
            get {
                return ResourceManager.GetString("BotOwnedAlready", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotOwnedAlreadyWithName {
            get {
                return ResourceManager.GetString("BotOwnedAlreadyWithName", resourceCulture);
            }
        }
        
        
/   查找类似 {0}/{1} bots already own game {2}. 的本地化字符串。
        
/ </summary>
        public static string BotOwnsOverviewPerGame {
            get {
                return ResourceManager.GetString("BotOwnsOverviewPerGame", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotPointsBalance {
            get {
                return ResourceManager.GetString("BotPointsBalance", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotRateLimitExceeded {
            get {
                return ResourceManager.GetString("BotRateLimitExceeded", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotReconnecting {
            get {
                return ResourceManager.GetString("BotReconnecting", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotRedeem {
            get {
                return ResourceManager.GetString("BotRedeem", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotRedeemWithItems {
            get {
                return ResourceManager.GetString("BotRedeemWithItems", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotRefreshingPackagesData {
            get {
                return ResourceManager.GetString("BotRefreshingPackagesData", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotRemovedExpiredLoginKey {
            get {
                return ResourceManager.GetString("BotRemovedExpiredLoginKey", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotSendingTradeToYourself {
            get {
                return ResourceManager.GetString("BotSendingTradeToYourself", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotStats {
            get {
                return ResourceManager.GetString("BotStats", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotStatusConnecting {
            get {
                return ResourceManager.GetString("BotStatusConnecting", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotStatusIdling {
            get {
                return ResourceManager.GetString("BotStatusIdling", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotStatusIdlingList {
            get {
                return ResourceManager.GetString("BotStatusIdlingList", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotStatusLimited {
            get {
                return ResourceManager.GetString("BotStatusLimited", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotStatusLocked {
            get {
                return ResourceManager.GetString("BotStatusLocked", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotStatusNotIdling {
            get {
                return ResourceManager.GetString("BotStatusNotIdling", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotStatusNotRunning {
            get {
                return ResourceManager.GetString("BotStatusNotRunning", resourceCulture);
            }
        }
        
        
/   查找类似 There are {0}/{1} bots running, with total of {2} games ({3} cards) left to farm. 的本地化字符串。
        
/ </summary>
        public static string BotStatusOverview {
            get {
                return ResourceManager.GetString("BotStatusOverview", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotStatusPaused {
            get {
                return ResourceManager.GetString("BotStatusPaused", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotStatusPlayingNotAvailable {
            get {
                return ResourceManager.GetString("BotStatusPlayingNotAvailable", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotSteamDirectoryInitializationFailed {
            get {
                return ResourceManager.GetString("BotSteamDirectoryInitializationFailed", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotStopping {
            get {
                return ResourceManager.GetString("BotStopping", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotTradeOfferResult {
            get {
                return ResourceManager.GetString("BotTradeOfferResult", resourceCulture);
            }
        }
        
        
/   查找类似 Unable to login to Steam: {0}/{1} 的本地化字符串。
        
/ </summary>
        public static string BotUnableToLogin {
            get {
                return ResourceManager.GetString("BotUnableToLogin", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotVersion {
            get {
                return ResourceManager.GetString("BotVersion", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string BotWalletBalance {
            get {
                return ResourceManager.GetString("BotWalletBalance", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CheckingFirstBadgePage {
            get {
                return ResourceManager.GetString("CheckingFirstBadgePage", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string CheckingOtherBadgePages {
            get {
                return ResourceManager.GetString("CheckingOtherBadgePages", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ChecksumMissing {
            get {
                return ResourceManager.GetString("ChecksumMissing", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ChecksumWrong {
            get {
                return ResourceManager.GetString("ChecksumWrong", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ChosenFarmingAlgorithm {
            get {
                return ResourceManager.GetString("ChosenFarmingAlgorithm", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ClearingDiscoveryQueue {
            get {
                return ResourceManager.GetString("ClearingDiscoveryQueue", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Content {
            get {
                return ResourceManager.GetString("Content", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Done {
            get {
                return ResourceManager.GetString("Done", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string DoneActivelyMatchingItems {
            get {
                return ResourceManager.GetString("DoneActivelyMatchingItems", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string DoneClearingDiscoveryQueue {
            get {
                return ResourceManager.GetString("DoneClearingDiscoveryQueue", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string EnterCommand {
            get {
                return ResourceManager.GetString("EnterCommand", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ErrorAborted {
            get {
                return ResourceManager.GetString("ErrorAborted", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ErrorAccessDenied {
            get {
                return ResourceManager.GetString("ErrorAccessDenied", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ErrorBotConfigInvalid {
            get {
                return ResourceManager.GetString("ErrorBotConfigInvalid", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ErrorConfigDirectoryNotFound {
            get {
                return ResourceManager.GetString("ErrorConfigDirectoryNotFound", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ErrorConfigPropertyInvalid {
            get {
                return ResourceManager.GetString("ErrorConfigPropertyInvalid", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ErrorDatabaseInvalid {
            get {
                return ResourceManager.GetString("ErrorDatabaseInvalid", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ErrorEarlyFatalExceptionInfo {
            get {
                return ResourceManager.GetString("ErrorEarlyFatalExceptionInfo", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ErrorEarlyFatalExceptionPrint {
            get {
                return ResourceManager.GetString("ErrorEarlyFatalExceptionPrint", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ErrorExitingWithNonZeroErrorCode {
            get {
                return ResourceManager.GetString("ErrorExitingWithNonZeroErrorCode", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ErrorFailingRequest {
            get {
                return ResourceManager.GetString("ErrorFailingRequest", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ErrorFunctionOnlyInHeadlessMode {
            get {
                return ResourceManager.GetString("ErrorFunctionOnlyInHeadlessMode", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ErrorGlobalConfigNotLoaded {
            get {
                return ResourceManager.GetString("ErrorGlobalConfigNotLoaded", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ErrorGlobalConfigRemoved {
            get {
                return ResourceManager.GetString("ErrorGlobalConfigRemoved", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ErrorInvalidCurrentCulture {
            get {
                return ResourceManager.GetString("ErrorInvalidCurrentCulture", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ErrorIPNotBanned {
            get {
                return ResourceManager.GetString("ErrorIPNotBanned", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ErrorIsEmpty {
            get {
                return ResourceManager.GetString("ErrorIsEmpty", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ErrorIsInvalid {
            get {
                return ResourceManager.GetString("ErrorIsInvalid", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ErrorNoBotsDefined {
            get {
                return ResourceManager.GetString("ErrorNoBotsDefined", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ErrorObjectIsNull {
            get {
                return ResourceManager.GetString("ErrorObjectIsNull", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ErrorParsingObject {
            get {
                return ResourceManager.GetString("ErrorParsingObject", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ErrorRequestFailedTooManyTimes {
            get {
                return ResourceManager.GetString("ErrorRequestFailedTooManyTimes", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ErrorSingleInstanceRequired {
            get {
                return ResourceManager.GetString("ErrorSingleInstanceRequired", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ErrorUpdateCheckFailed {
            get {
                return ResourceManager.GetString("ErrorUpdateCheckFailed", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ErrorUpdateNoAssetForThisVersion {
            get {
                return ResourceManager.GetString("ErrorUpdateNoAssetForThisVersion", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ErrorUpdateNoAssets {
            get {
                return ResourceManager.GetString("ErrorUpdateNoAssets", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string ErrorUserInputRunningInHeadlessMode {
            get {
                return ResourceManager.GetString("ErrorUserInputRunningInHeadlessMode", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Executing {
            get {
                return ResourceManager.GetString("Executing", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Exiting {
            get {
                return ResourceManager.GetString("Exiting", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string FetchingChecksumFromRemoteServer {
            get {
                return ResourceManager.GetString("FetchingChecksumFromRemoteServer", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GamesToIdle {
            get {
                return ResourceManager.GetString("GamesToIdle", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string GlobalConfigChanged {
            get {
                return ResourceManager.GetString("GlobalConfigChanged", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string IdlingFinished {
            get {
                return ResourceManager.GetString("IdlingFinished", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string IdlingFinishedForGame {
            get {
                return ResourceManager.GetString("IdlingFinishedForGame", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string IdlingFinishedForGames {
            get {
                return ResourceManager.GetString("IdlingFinishedForGames", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string IdlingGameNotPossible {
            get {
                return ResourceManager.GetString("IdlingGameNotPossible", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string IdlingStatusForGame {
            get {
                return ResourceManager.GetString("IdlingStatusForGame", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string IdlingStopped {
            get {
                return ResourceManager.GetString("IdlingStopped", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string IgnoredPermanentPauseEnabled {
            get {
                return ResourceManager.GetString("IgnoredPermanentPauseEnabled", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string IgnoringTrade {
            get {
                return ResourceManager.GetString("IgnoringTrade", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Initializing {
            get {
                return ResourceManager.GetString("Initializing", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string InteractiveConsoleEnabled {
            get {
                return ResourceManager.GetString("InteractiveConsoleEnabled", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string IPCConfigChanged {
            get {
                return ResourceManager.GetString("IPCConfigChanged", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string IPCReady {
            get {
                return ResourceManager.GetString("IPCReady", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string IPCStarting {
            get {
                return ResourceManager.GetString("IPCStarting", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string LoggingIn {
            get {
                return ResourceManager.GetString("LoggingIn", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string NoBotsAreRunning {
            get {
                return ResourceManager.GetString("NoBotsAreRunning", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string NothingFound {
            get {
                return ResourceManager.GetString("NothingFound", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string NothingToIdle {
            get {
                return ResourceManager.GetString("NothingToIdle", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string NowIdling {
            get {
                return ResourceManager.GetString("NowIdling", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string NowIdlingList {
            get {
                return ResourceManager.GetString("NowIdlingList", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string PatchingFiles {
            get {
                return ResourceManager.GetString("PatchingFiles", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string PlayingNotAvailable {
            get {
                return ResourceManager.GetString("PlayingNotAvailable", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string PleaseWait {
            get {
                return ResourceManager.GetString("PleaseWait", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string PluginLoaded {
            get {
                return ResourceManager.GetString("PluginLoaded", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string PluginLoading {
            get {
                return ResourceManager.GetString("PluginLoading", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string PluginsWarning {
            get {
                return ResourceManager.GetString("PluginsWarning", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string RefreshingOurSession {
            get {
                return ResourceManager.GetString("RefreshingOurSession", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string RejectingTrade {
            get {
                return ResourceManager.GetString("RejectingTrade", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Restarting {
            get {
                return ResourceManager.GetString("Restarting", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Result {
            get {
                return ResourceManager.GetString("Result", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Starting {
            get {
                return ResourceManager.GetString("Starting", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string StillIdling {
            get {
                return ResourceManager.GetString("StillIdling", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string StillIdlingList {
            get {
                return ResourceManager.GetString("StillIdlingList", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string StoppedIdling {
            get {
                return ResourceManager.GetString("StoppedIdling", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string StoppedIdlingList {
            get {
                return ResourceManager.GetString("StoppedIdlingList", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Success {
            get {
                return ResourceManager.GetString("Success", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string TargetBotNotConnected {
            get {
                return ResourceManager.GetString("TargetBotNotConnected", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string TranslationIncomplete {
            get {
                return ResourceManager.GetString("TranslationIncomplete", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UnknownCommand {
            get {
                return ResourceManager.GetString("UnknownCommand", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UnlockingParentalAccount {
            get {
                return ResourceManager.GetString("UnlockingParentalAccount", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UnusedKeys {
            get {
                return ResourceManager.GetString("UnusedKeys", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UpdateCheckingNewVersion {
            get {
                return ResourceManager.GetString("UpdateCheckingNewVersion", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UpdateCleanup {
            get {
                return ResourceManager.GetString("UpdateCleanup", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UpdateDownloadingNewVersion {
            get {
                return ResourceManager.GetString("UpdateDownloadingNewVersion", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UpdateFinished {
            get {
                return ResourceManager.GetString("UpdateFinished", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UpdateNewVersionAvailable {
            get {
                return ResourceManager.GetString("UpdateNewVersionAvailable", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UpdateVersionInfo {
            get {
                return ResourceManager.GetString("UpdateVersionInfo", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UserInputCryptkey {
            get {
                return ResourceManager.GetString("UserInputCryptkey", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UserInputDeviceConfirmation {
            get {
                return ResourceManager.GetString("UserInputDeviceConfirmation", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UserInputSteam2FA {
            get {
                return ResourceManager.GetString("UserInputSteam2FA", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UserInputSteamGuard {
            get {
                return ResourceManager.GetString("UserInputSteamGuard", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UserInputSteamLogin {
            get {
                return ResourceManager.GetString("UserInputSteamLogin", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UserInputSteamParentalCode {
            get {
                return ResourceManager.GetString("UserInputSteamParentalCode", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string UserInputSteamPassword {
            get {
                return ResourceManager.GetString("UserInputSteamPassword", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string VerifyingChecksumWithRemoteServer {
            get {
                return ResourceManager.GetString("VerifyingChecksumWithRemoteServer", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string WarningCouldNotCheckBadges {
            get {
                return ResourceManager.GetString("WarningCouldNotCheckBadges", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string WarningCouldNotCheckCardsStatus {
            get {
                return ResourceManager.GetString("WarningCouldNotCheckCardsStatus", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string WarningDefaultCryptKeyUsedForEncryption {
            get {
                return ResourceManager.GetString("WarningDefaultCryptKeyUsedForEncryption", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string WarningDefaultCryptKeyUsedForHashing {
            get {
                return ResourceManager.GetString("WarningDefaultCryptKeyUsedForHashing", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string WarningDeprecated {
            get {
                return ResourceManager.GetString("WarningDeprecated", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string WarningExcessiveBotsCount {
            get {
                return ResourceManager.GetString("WarningExcessiveBotsCount", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string WarningFailed {
            get {
                return ResourceManager.GetString("WarningFailed", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string WarningFailedWithError {
            get {
                return ResourceManager.GetString("WarningFailedWithError", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string WarningIdlingGameMismatch {
            get {
                return ResourceManager.GetString("WarningIdlingGameMismatch", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string WarningNoLicense {
            get {
                return ResourceManager.GetString("WarningNoLicense", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string WarningPreReleaseVersion {
            get {
                return ResourceManager.GetString("WarningPreReleaseVersion", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string WarningPrivacyPolicy {
            get {
                return ResourceManager.GetString("WarningPrivacyPolicy", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string WarningRunningAsRoot {
            get {
                return ResourceManager.GetString("WarningRunningAsRoot", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string WarningRunningInUnsupportedEnvironment {
            get {
                return ResourceManager.GetString("WarningRunningInUnsupportedEnvironment", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string WarningTooShortCryptKey {
            get {
                return ResourceManager.GetString("WarningTooShortCryptKey", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string WarningUnknownCommandLineArgument {
            get {
                return ResourceManager.GetString("WarningUnknownCommandLineArgument", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string WarningUnknownValuePleaseReport {
            get {
                return ResourceManager.GetString("WarningUnknownValuePleaseReport", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string WarningUnsupportedEnvironment {
            get {
                return ResourceManager.GetString("WarningUnsupportedEnvironment", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string WarningWeakCryptKey {
            get {
                return ResourceManager.GetString("WarningWeakCryptKey", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string WarningWeakIPCPassword {
            get {
                return ResourceManager.GetString("WarningWeakIPCPassword", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string WarningWeakSteamPassword {
            get {
                return ResourceManager.GetString("WarningWeakSteamPassword", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string WarningWorkaroundTriggered {
            get {
                return ResourceManager.GetString("WarningWorkaroundTriggered", resourceCulture);
            }
        }
        
        
/ </summary>
        public static string Welcome {
            get {
                return ResourceManager.GetString("Welcome", resourceCulture);
            }
        }
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\_\ArchiSteamFarm\Steam\Cards\Game.cs
/    / \    _ __  ___ | |__  (_)/ ___| | |_  ___   __ _  _ __ ___  |  ___|__ _  _ __  _ __ ___

/   / _ \  | '__|/ __|| '_ \ | |\___ \ | __|/ _ \ / _` || '_ ` _ \ | |_  / _` || '__|| '_ ` _ \

/  / ___ \ | |  | (__ | | | || | ___) || |_|  __/| (_| || | | | | ||  _|| (_| || |   | | | | | |

/ /_/   \_\|_|   \___||_| |_||_||____/  \__|\___| \__,_||_| |_| |_||_|   \__,_||_|   |_| |_| |_|

/www.apache.org/licenses/LICENSE-2.0

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\_\ArchiSteamFarm\Steam\Data\Confirmation.cs
/    / \    _ __  ___ | |__  (_)/ ___| | |_  ___   __ _  _ __ ___  |  ___|__ _  _ __  _ __ ___

/   / _ \  | '__|/ __|| '_ \ | |\___ \ | __|/ _ \ / _` || '_ ` _ \ | |_  / _` || '__|| '_ ` _ \

/  / ___ \ | |  | (__ | | | || | ___) || |_|  __/| (_| || | | | | ||  _|| (_| || |   | | | | | |

/ /_/   \_\|_|   \___||_| |_||_||____/  \__|\___| \__,_||_| |_| |_||_|   \__,_||_|   |_| |_| |_|

/www.apache.org/licenses/LICENSE-2.0

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\_\ArchiSteamFarm\Steam\Storage\BotConfig.cs
/    / \    _ __  ___ | |__  (_)/ ___| | |_  ___   __ _  _ __ ___  |  ___|__ _  _ __  _ __ ___

/   / _ \  | '__|/ __|| '_ \ | |\___ \ | __|/ _ \ / _` || '_ ` _ \ | |_  / _` || '__|| '_ ` _ \

/  / ___ \ | |  | (__ | | | || | ___) || |_|  __/| (_| || | | | | ||  _|| (_| || |   | | | | | |

/ /_/   \_\|_|   \___||_| |_||_||____/  \__|\___| \__,_||_| |_| |_||_|   \__,_||_|   |_| |_| |_|

/www.apache.org/licenses/LICENSE-2.0

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\_\ArchiSteamFarm\Storage\GlobalConfig.cs
/    / \    _ __  ___ | |__  (_)/ ___| | |_  ___   __ _  _ __ ___  |  ___|__ _  _ __  _ __ ___

/   / _ \  | '__|/ __|| '_ \ | |\___ \ | __|/ _ \ / _` || '_ ` _ \ | |_  / _` || '__|| '_ ` _ \

/  / ___ \ | |  | (__ | | | || | ___) || |_|  __/| (_| || | | | | ||  _|| (_| || |   | | | | | |

/ /_/   \_\|_|   \___||_| |_||_||____/  \__|\___| \__,_||_| |_| |_||_|   \__,_||_|   |_| |_| |_|

/www.apache.org/licenses/LICENSE-2.0

/ ReSharper disable once CheckNamespace
namespace ArchiSteamFarm.Storage;

[SuppressMessage("ReSharper", "ClassCannotBeInstantiated")]
public sealed class GlobalConfig
{
    [PublicAPI]
    public const bool DefaultAutoRestart = true;

    [PublicAPI]
    public const string? DefaultCommandPrefix = "!";

    [PublicAPI]
    public const byte DefaultConfirmationsLimiterDelay = 10;

    [PublicAPI]
    public const byte DefaultConnectionTimeout = 90;

    [PublicAPI]
    public const string? DefaultCurrentCulture = null;

    [PublicAPI]
    public const bool DefaultDebug = false;

    [PublicAPI]
    public const byte DefaultFarmingDelay = 15;

    [PublicAPI]
    public const bool DefaultFilterBadBots = true;

    [PublicAPI]
    public const byte DefaultGiftsLimiterDelay = 1;

    [PublicAPI]
    public const bool DefaultHeadless = false;

    [PublicAPI]
    public const byte DefaultIdleFarmingPeriod = 8;

    [PublicAPI]
    public const byte DefaultInventoryLimiterDelay = 4;

    [PublicAPI]
    public const bool DefaultIPC = true;

    [PublicAPI]
    public const string? DefaultIPCPassword = null;

    [PublicAPI]
    public const ArchiCryptoHelper.EHashingMethod DefaultIPCPasswordFormat = ArchiCryptoHelper.EHashingMethod.PlainText;

    [PublicAPI]
    public const byte DefaultLoginLimiterDelay = 10;

    [PublicAPI]
    public const byte DefaultMaxFarmingTime = 10;

    [PublicAPI]
    public const byte DefaultMaxTradeHoldDuration = 15;

    [PublicAPI]
    public const byte DefaultMinFarmingDelayAfterBlock = 60;

    [PublicAPI]
    public const EOptimizationMode DefaultOptimizationMode = EOptimizationMode.MaxPerformance;

    [PublicAPI]
    public const string? DefaultSteamMessagePrefix = "/me ";

    [PublicAPI]
    public const ulong DefaultSteamOwnerID = 0;

    [PublicAPI]
    public const ProtocolTypes DefaultSteamProtocols = ProtocolTypes.All;

    [PublicAPI]
    public const EUpdateChannel DefaultUpdateChannel = EUpdateChannel.Stable;

    [PublicAPI]
    public const byte DefaultUpdatePeriod = 24;

    [PublicAPI]
    public const ushort DefaultWebLimiterDelay = 300;

    [PublicAPI]
    public const string? DefaultWebProxyPassword = null;

    [PublicAPI]
    public const string? DefaultWebProxyText = null;

    [PublicAPI]
    public const string? DefaultWebProxyUsername = null;

    [PublicAPI]
    public static readonly ImmutableHashSet<uint> DefaultBlacklist = ImmutableHashSet<uint>.Empty;

    [PublicAPI]
    public static readonly Guid? DefaultLicenseID;

    private static readonly ImmutableHashSet<string> ForbiddenIPCPasswordPhrases = ImmutableHashSet.Create(StringComparer.InvariantCultureIgnoreCase, "ipc", "api", "gui", "asf-ui", "asf-gui");

    [JsonIgnore]
    [PublicAPI]
    public WebProxy? WebProxy
    {
        get
        {
            if (BackingWebProxy != null)
            {
                return BackingWebProxy;
            }

            if (string.IsNullOrEmpty(WebProxyText))
            {
                return null;
            }

            Uri uri;

            try
            {
                uri = new Uri(WebProxyText!);
            }
            catch (UriFormatException e)
            {
                ASF.ArchiLogger.LogGenericException(e);

                return null;
            }

            WebProxy proxy = new()
            {
                Address = uri,
                BypassProxyOnLocal = true,
            };

            if (!string.IsNullOrEmpty(WebProxyUsername) || !string.IsNullOrEmpty(WebProxyPassword))
            {
                NetworkCredential credentials = new();

                if (!string.IsNullOrEmpty(WebProxyUsername))
                {
                    credentials.UserName = WebProxyUsername;
                }

                if (!string.IsNullOrEmpty(WebProxyPassword))
                {
                    credentials.Password = WebProxyPassword;
                }

                proxy.Credentials = credentials;
            }

            BackingWebProxy = proxy;

            return proxy;
        }
    }

    [JsonProperty(Required = Required.DisallowNull)]
    public bool AutoRestart { get; private set; } = DefaultAutoRestart;

    [JsonProperty(Required = Required.DisallowNull)]
    [SwaggerItemsMinMax(MinimumUint = 1, MaximumUint = uint.MaxValue)]
    public ImmutableHashSet<uint> Blacklist { get; private set; } = DefaultBlacklist;

    [JsonProperty]
    public string? CommandPrefix { get; private set; } = DefaultCommandPrefix;

    [JsonProperty(Required = Required.DisallowNull)]
    [Range(byte.MinValue, byte.MaxValue)]
    public byte ConfirmationsLimiterDelay { get; private set; } = DefaultConfirmationsLimiterDelay;

    [JsonProperty(Required = Required.DisallowNull)]
    [Range(1, byte.MaxValue)]
    public byte ConnectionTimeout { get; private set; } = DefaultConnectionTimeout;

    [JsonProperty]
    public string? CurrentCulture { get; private set; } = DefaultCurrentCulture;

    [JsonProperty(Required = Required.DisallowNull)]
    public bool Debug { get; private set; } = DefaultDebug;

    [JsonProperty(Required = Required.DisallowNull)]
    [Range(1, byte.MaxValue)]
    public byte FarmingDelay { get; private set; } = DefaultFarmingDelay;

    [JsonProperty(Required = Required.DisallowNull)]
    public bool FilterBadBots { get; private set; } = DefaultFilterBadBots;

    [JsonProperty(Required = Required.DisallowNull)]
    [Range(byte.MinValue, byte.MaxValue)]
    public byte GiftsLimiterDelay { get; private set; } = DefaultGiftsLimiterDelay;

    [JsonProperty(Required = Required.DisallowNull)]
    public bool Headless { get; private set; } = DefaultHeadless;

    [JsonProperty(Required = Required.DisallowNull)]
    [Range(byte.MinValue, byte.MaxValue)]
    public byte IdleFarmingPeriod { get; private set; } = DefaultIdleFarmingPeriod;

    [JsonProperty(Required = Required.DisallowNull)]
    [Range(byte.MinValue, byte.MaxValue)]
    public byte InventoryLimiterDelay { get; private set; } = DefaultInventoryLimiterDelay;

    [JsonProperty(Required = Required.DisallowNull)]
    public bool IPC { get; private set; } = DefaultIPC;

    [JsonProperty]
    public string? IPCPassword
    {
        get => BackingIPCPassword;

        internal set
        {
            IsIPCPasswordSet = true;
            BackingIPCPassword = value;
        }
    }

    [JsonProperty(Required = Required.DisallowNull)]
    public ArchiCryptoHelper.EHashingMethod IPCPasswordFormat { get; private set; } = DefaultIPCPasswordFormat;

    [JsonProperty]
    public Guid? LicenseID { get; private set; } = DefaultLicenseID;

    [JsonProperty(Required = Required.DisallowNull)]
    [Range(byte.MinValue, byte.MaxValue)]
    public byte LoginLimiterDelay { get; private set; } = DefaultLoginLimiterDelay;

    [JsonProperty(Required = Required.DisallowNull)]
    [Range(1, byte.MaxValue)]
    public byte MaxFarmingTime { get; private set; } = DefaultMaxFarmingTime;

    [JsonProperty(Required = Required.DisallowNull)]
    [Range(byte.MinValue, byte.MaxValue)]
    public byte MaxTradeHoldDuration { get; private set; } = DefaultMaxTradeHoldDuration;

    [JsonProperty(Required = Required.DisallowNull)]
    [Range(byte.MinValue, byte.MaxValue)]
    public byte MinFarmingDelayAfterBlock { get; private set; } = DefaultMinFarmingDelayAfterBlock;

    [JsonProperty(Required = Required.DisallowNull)]
    public EOptimizationMode OptimizationMode { get; private set; } = DefaultOptimizationMode;

    [JsonProperty]
    [MaxLength(SteamChatMessage.MaxMessagePrefixBytes / SteamChatMessage.ReservedEscapeMessageBytes)]
    [UnconditionalSuppressMessage("AssemblyLoadTrimming", "IL2026:RequiresUnreferencedCode", Justification = "This is optional, supportive attribute, we don't care if it gets trimmed or not")]
    public string? SteamMessagePrefix { get; private set; } = DefaultSteamMessagePrefix;

    [JsonProperty(Required = Required.DisallowNull)]
    [SwaggerSteamIdentifier]
    [SwaggerValidValues(ValidIntValues = new[] { 0 })]
    public ulong SteamOwnerID { get; private set; } = DefaultSteamOwnerID;

    [JsonProperty(Required = Required.DisallowNull)]
    public ProtocolTypes SteamProtocols { get; private set; } = DefaultSteamProtocols;

    [JsonProperty(Required = Required.DisallowNull)]
    public EUpdateChannel UpdateChannel { get; private set; } = DefaultUpdateChannel;

    [JsonProperty(Required = Required.DisallowNull)]
    [Range(byte.MinValue, byte.MaxValue)]
    public byte UpdatePeriod { get; private set; } = DefaultUpdatePeriod;

    [JsonProperty(Required = Required.DisallowNull)]
    [Range(ushort.MinValue, ushort.MaxValue)]
    public ushort WebLimiterDelay { get; private set; } = DefaultWebLimiterDelay;

    [JsonProperty(nameof(WebProxy))]
    public string? WebProxyText { get; private set; } = DefaultWebProxyText;

    [JsonProperty]
    public string? WebProxyUsername { get; private set; } = DefaultWebProxyUsername;

    [JsonExtensionData]
    internal Dictionary<string, JToken>? AdditionalProperties
    {
        get;
        [UsedImplicitly]
        set;
    }

    internal bool IsIPCPasswordSet { get; private set; }

    internal bool IsWebProxyPasswordSet { get; private set; }

    internal bool Saving { get; set; }

    [JsonProperty]
    internal string? WebProxyPassword
    {
        get => BackingWebProxyPassword;

        set
        {
            IsWebProxyPasswordSet = true;
            BackingWebProxyPassword = value;
        }
    }

    private string? BackingIPCPassword = DefaultIPCPassword;
    private WebProxy? BackingWebProxy;
    private string? BackingWebProxyPassword = DefaultWebProxyPassword;

    [JsonProperty($"{SharedInfo.UlongCompatibilityStringPrefix}{nameof(SteamOwnerID)}", Required = Required.DisallowNull)]
    private string SSteamOwnerID
    {
        get => SteamOwnerID.ToString(CultureInfo.InvariantCulture);

        set
        {
            if (string.IsNullOrEmpty(value) || !ulong.TryParse(value, out ulong result))
            {
                ASF.ArchiLogger.LogGenericError(string.Format(CultureInfo.CurrentCulture, Strings.ErrorIsInvalid, nameof(SSteamOwnerID)));

                return;
            }

            SteamOwnerID = result;
        }
    }

    [JsonConstructor]
    internal GlobalConfig() { }

    [UsedImplicitly]
    public bool ShouldSerializeAutoRestart() => !Saving || (AutoRestart != DefaultAutoRestart);

    [UsedImplicitly]
    public bool ShouldSerializeBlacklist() => !Saving || ((Blacklist != DefaultBlacklist) && !Blacklist.SetEquals(DefaultBlacklist));

    [UsedImplicitly]
    public bool ShouldSerializeCommandPrefix() => !Saving || (CommandPrefix != DefaultCommandPrefix);

    [UsedImplicitly]
    public bool ShouldSerializeConfirmationsLimiterDelay() => !Saving || (ConfirmationsLimiterDelay != DefaultConfirmationsLimiterDelay);

    [UsedImplicitly]
    public bool ShouldSerializeConnectionTimeout() => !Saving || (ConnectionTimeout != DefaultConnectionTimeout);

    [UsedImplicitly]
    public bool ShouldSerializeCurrentCulture() => !Saving || (CurrentCulture != DefaultCurrentCulture);

    [UsedImplicitly]
    public bool ShouldSerializeDebug() => !Saving || (Debug != DefaultDebug);

    [UsedImplicitly]
    public bool ShouldSerializeFarmingDelay() => !Saving || (FarmingDelay != DefaultFarmingDelay);

    [UsedImplicitly]
    public bool ShouldSerializeFilterBadBots() => !Saving || (FilterBadBots != DefaultFilterBadBots);

    [UsedImplicitly]
    public bool ShouldSerializeGiftsLimiterDelay() => !Saving || (GiftsLimiterDelay != DefaultGiftsLimiterDelay);

    [UsedImplicitly]
    public bool ShouldSerializeHeadless() => !Saving || (Headless != DefaultHeadless);

    [UsedImplicitly]
    public bool ShouldSerializeIdleFarmingPeriod() => !Saving || (IdleFarmingPeriod != DefaultIdleFarmingPeriod);

    [UsedImplicitly]
    public bool ShouldSerializeInventoryLimiterDelay() => !Saving || (InventoryLimiterDelay != DefaultInventoryLimiterDelay);

    [UsedImplicitly]
    public bool ShouldSerializeIPC() => !Saving || (IPC != DefaultIPC);

    [UsedImplicitly]
    public bool ShouldSerializeIPCPassword() => Saving && IsIPCPasswordSet && (IPCPassword != DefaultIPCPassword);

    [UsedImplicitly]
    public bool ShouldSerializeIPCPasswordFormat() => !Saving || (IPCPasswordFormat != DefaultIPCPasswordFormat);

    [UsedImplicitly]
    public bool ShouldSerializeLicenseID() => !Saving || ((LicenseID != DefaultLicenseID) && (LicenseID != Guid.Empty));

    [UsedImplicitly]
    public bool ShouldSerializeLoginLimiterDelay() => !Saving || (LoginLimiterDelay != DefaultLoginLimiterDelay);

    [UsedImplicitly]
    public bool ShouldSerializeMaxFarmingTime() => !Saving || (MaxFarmingTime != DefaultMaxFarmingTime);

    [UsedImplicitly]
    public bool ShouldSerializeMaxTradeHoldDuration() => !Saving || (MaxTradeHoldDuration != DefaultMaxTradeHoldDuration);

    [UsedImplicitly]
    public bool ShouldSerializeMinFarmingDelayAfterBlock() => !Saving || (MinFarmingDelayAfterBlock != DefaultMinFarmingDelayAfterBlock);

    [UsedImplicitly]
    public bool ShouldSerializeOptimizationMode() => !Saving || (OptimizationMode != DefaultOptimizationMode);

    [UsedImplicitly]
    public bool ShouldSerializeSSteamOwnerID() => !Saving;

    [UsedImplicitly]
    public bool ShouldSerializeSteamMessagePrefix() => !Saving || (SteamMessagePrefix != DefaultSteamMessagePrefix);

    [UsedImplicitly]
    public bool ShouldSerializeSteamOwnerID() => !Saving || (SteamOwnerID != DefaultSteamOwnerID);

    [UsedImplicitly]
    public bool ShouldSerializeSteamProtocols() => !Saving || (SteamProtocols != DefaultSteamProtocols);

    [UsedImplicitly]
    public bool ShouldSerializeUpdateChannel() => !Saving || (UpdateChannel != DefaultUpdateChannel);

    [UsedImplicitly]
    public bool ShouldSerializeUpdatePeriod() => !Saving || (UpdatePeriod != DefaultUpdatePeriod);

    [UsedImplicitly]
    public bool ShouldSerializeWebLimiterDelay() => !Saving || (WebLimiterDelay != DefaultWebLimiterDelay);

    [UsedImplicitly]
    public bool ShouldSerializeWebProxyPassword() => Saving && IsWebProxyPasswordSet && (WebProxyPassword != DefaultWebProxyPassword);

    [UsedImplicitly]
    public bool ShouldSerializeWebProxyText() => !Saving || (WebProxyText != DefaultWebProxyText);

    [UsedImplicitly]
    public bool ShouldSerializeWebProxyUsername() => !Saving || (WebProxyUsername != DefaultWebProxyUsername);

    [PublicAPI]
    public enum EOptimizationMode : byte
    {
        MaxPerformance,
        MinMemoryUsage,
    }

    [PublicAPI]
    public enum EUpdateChannel : byte
    {
        None,
        Stable,
        Experimental,
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\_\JetBrains.Annotations\UsedImplicitlyAttribute.cs
/ with <see cref="MeansImplicitUseAttribute"/> or <see cref="UsedImplicitlyAttribute"/>.

/ </summary>
[Flags]
enum ImplicitUseKindFlags
{
    Default = Access | Assign | InstantiatedWithFixedConstructorSignature,

    
/ <summary>Only entity marked with attribute considered used.</summary>
    Access = 1,

    
/ <summary>Indicates implicit assignment to a member.</summary>
    Assign = 2,

    
/ </summary>
    InstantiatedWithFixedConstructorSignature = 4,

    
/ <summary>Indicates implicit instantiation of a type.</summary>
    InstantiatedNoFixedConstructorSignature = 8,
}


/ with <see cref="MeansImplicitUseAttribute"/> or <see cref="UsedImplicitlyAttribute"/>.

/ </summary>
[Flags]
enum ImplicitUseTargetFlags
{
    Default = Itself,

    Itself = 1,

    
/ <summary>Members of the type marked with the attribute are considered used.</summary>
    Members = 2,

    
/ <summary> Inherited entities are considered used. </summary>
    WithInheritors = 4,

    
/ <summary>Entity marked with the attribute and all its members considered used.</summary>
    WithMembers = Itself | Members,
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\_\Mvc.NewtonsoftJson\AnnotatedProblemDetails.cs
/github.com/dotnet/aspnetcore/blob/v7.0.11/src/Mvc/Mvc.NewtonsoftJson/src/AnnotatedProblemDetails.cs

using Newtonsoft.Json;


/ </remarks>
    public AnnotatedProblemDetails() { }

    public AnnotatedProblemDetails(ProblemDetails problemDetails)
    {
        Detail = problemDetails.Detail;
        Instance = problemDetails.Instance;
        Status = problemDetails.Status;
        Title = problemDetails.Title;
        Type = problemDetails.Type;

        foreach (var kvp in problemDetails.Extensions)
        {
            Extensions[kvp.Key] = kvp.Value;
        }
    }

    [JsonProperty(PropertyName = "type", NullValueHandling = NullValueHandling.Ignore)]
    public string? Type { get; set; }

    [JsonProperty(PropertyName = "title", NullValueHandling = NullValueHandling.Ignore)]
    public string? Title { get; set; }

    [JsonProperty(PropertyName = "status", NullValueHandling = NullValueHandling.Ignore)]
    public int? Status { get; set; }

    [JsonProperty(PropertyName = "detail", NullValueHandling = NullValueHandling.Ignore)]
    public string? Detail { get; set; }

    [JsonProperty(PropertyName = "instance", NullValueHandling = NullValueHandling.Ignore)]
    public string? Instance { get; set; }

    [JsonExtensionData]
    public IDictionary<string, object?> Extensions { get; } = new Dictionary<string, object?>(StringComparer.Ordinal);

    public void CopyTo(ProblemDetails problemDetails)
    {
        problemDetails.Type = Type;
        problemDetails.Title = Title;
        problemDetails.Status = Status;
        problemDetails.Instance = Instance;
        problemDetails.Detail = Detail;

        foreach (var kvp in Extensions)
        {
            problemDetails.Extensions[kvp.Key] = kvp.Value;
        }
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\_\Mvc.NewtonsoftJson\JsonSerializerSettingsProvider.cs
/github.com/dotnet/aspnetcore/blob/v7.0.11/src/Mvc/Mvc.NewtonsoftJson/src/JsonSerializerSettingsProvider.cs

using Newtonsoft.Json;


/ Helper class which provides <see cref="JsonSerializerSettings"/>.

/ </summary>
static class JsonSerializerSettingsProvider
{
    private const int DefaultMaxDepth = 32;
    private static readonly ProblemDetailsConverter ProblemDetailsConverter = new();
    private static readonly ValidationProblemDetailsConverter ValidationProblemDetailsConverter = new();

    
/ Creates default <see cref="JsonSerializerSettings"/>.
    
/ </summary>
    
/ <returns>Default <see cref="JsonSerializerSettings"/>.</returns>
    public static JsonSerializerSettings CreateSerializerSettings()
    {
        return new JsonSerializerSettings
        {
            
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\_\Mvc.NewtonsoftJson\ProblemDetailsConverter.cs
/ A RFC 7807 compliant <see cref="JsonConverter"/> for <see cref="ProblemDetails"/>.

/ </summary>
sealed class ProblemDetailsConverter : JsonConverter
{
    
/ <inheritdoc />
    public override bool CanConvert(Type objectType)
    {
        return objectType == typeof(ProblemDetails);
    }

    
/ <inheritdoc />
    public override object? ReadJson(JsonReader reader, Type objectType, object? existingValue, JsonSerializer serializer)
    {
        var annotatedProblemDetails = serializer.Deserialize<AnnotatedProblemDetails>(reader);
        if (annotatedProblemDetails == null)
        {
            return null;
        }

        var problemDetails = (ProblemDetails?)existingValue ?? new ProblemDetails();
        annotatedProblemDetails.CopyTo(problemDetails);

        return problemDetails;
    }

    
/ <inheritdoc />
    public override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer)
    {
        if (value == null)
        {
            writer.WriteNull();
            return;
        }

        var problemDetails = (ProblemDetails)value;
        var annotatedProblemDetails = new AnnotatedProblemDetails(problemDetails);

        serializer.Serialize(writer, annotatedProblemDetails);
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.ArchiSteamFarmPlus\_\Mvc.NewtonsoftJson\ValidationProblemDetailsConverter.cs
/github.com/dotnet/aspnetcore/blob/v7.0.11/src/Mvc/Mvc.NewtonsoftJson/src/ValidationProblemDetailsConverter.cs

using Newtonsoft.Json;


/ A RFC 7807 compliant <see cref="JsonConverter"/> for <see cref="ValidationProblemDetails"/>.

/ </summary>
sealed class ValidationProblemDetailsConverter : JsonConverter
{
    
/ <inheritdoc />
    public override bool CanConvert(Type objectType)
    {
        return objectType == typeof(ValidationProblemDetails);
    }

    
/ <inheritdoc />
    public override object? ReadJson(JsonReader reader, Type objectType, object? existingValue, JsonSerializer serializer)
    {
        var annotatedProblemDetails = serializer.Deserialize<AnnotatedValidationProblemDetails>(reader);
        if (annotatedProblemDetails == null)
        {
            return null;
        }

        var problemDetails = (ValidationProblemDetails?)existingValue ?? new ValidationProblemDetails();
        annotatedProblemDetails.CopyTo(problemDetails);

        return problemDetails;
    }

    
/ <inheritdoc />
    public override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer)
    {
        if (value == null)
        {
            writer.WriteNull();
            return;
        }

        var problemDetails = (ValidationProblemDetails)value;
        var annotatedProblemDetails = new AnnotatedValidationProblemDetails(problemDetails);

        serializer.Serialize(writer, annotatedProblemDetails);
    }

    private sealed class AnnotatedValidationProblemDetails : AnnotatedProblemDetails
    {
        
/ </remarks>
        public AnnotatedValidationProblemDetails() { }

        public AnnotatedValidationProblemDetails(ValidationProblemDetails problemDetails)
            : base(problemDetails)
        {
            foreach (var kvp in problemDetails.Errors)
            {
                Errors[kvp.Key] = kvp.Value;
            }
        }

        [JsonProperty(PropertyName = "errors")]
        public IDictionary<string, string[]> Errors { get; } = new Dictionary<string, string[]>(StringComparer.Ordinal);

        public void CopyTo(ValidationProblemDetails problemDetails)
        {
            base.CopyTo(problemDetails);

            foreach (var kvp in Errors)
            {
                problemDetails.Errors[kvp.Key] = kvp.Value;
            }
        }
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Authenticator\Entities\AccountPlatformAuthenticator.cs
/ </summary>
[SQLiteTable(TableName)]
[DebuggerDisplay("{DebuggerDisplay,nq}")]
[MPObj(keyAsPropertyName: true), MP2Obj]
public sealed partial class AccountPlatformAuthenticator : IEntity<ushort>, IOrder, IOrderAuthenticator
{
    public const string TableName = "E4401864";
    public const string ColumnName_ServerId = "C9835F84";
    public const string ColumnName_Id = "1DEF5924";
    public const string ColumnName_Index = "41B24805";

    string DebuggerDisplay => $"{Name}, {Id}";

    [Column(ColumnName_Id)]
    [PrimaryKey]
    [AutoIncrement]
    [MPIgnore, MP2Ignore]
    public ushort Id { get; set; }

    [Column("41B24805")]
    [SQLiteNotNull]
    public int Index { get; set; }

    
/ </summary>
    [Column("D4117D89")]
    public byte[]? Name { get; set; }

    
/ </summary>
    [Column("60FAF486")]
    [SQLiteNotNull]
    public byte[]? Value { get; set; }

    
/ </summary>
    [Column("44FF3988")]
    public bool IsNotLocal { get; set; }

    
/ </summary>
    [Column("4AF8A895")]
    public bool IsNeedSecondaryPassword { get; set; }

    [Column("7D808E24")]
    [SQLiteNotNull]
    public DateTimeOffset Created { get; set; }

    [Column("38A7E919")]
    [SQLiteNotNull]
    public DateTimeOffset LastUpdate { get; set; }

    
/ </summary>
    [Column(ColumnName_ServerId)]
    [MPIgnore]
    public Guid? ServerId { get; set; }

    long IOrder.Order
    {
        get => Index;
        set => Index = (int)value;
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Authenticator\Helpers\AuthenticatorHelper.cs
/ </summary>
    
/ <param name="fileName">保存文件名</param>
    
/ <param name="isLocal">导出是否携带本机加密</param>
    
/ <param name="items">需要导出的令牌集合</param>
    
/ <param name="password">导出是否携带二级密码</param>
    
/ <returns>返回文件保存结果,为Null则失败</returns>
    public static async Task<SaveFileResult?> ExportAsync(string fileName, bool isLocal,
        IEnumerable<IAuthenticatorDTO> items, string? password = null)
    {
        SaveFileResult? exportFile = null;
        if (CommonEssentials.IsSupportedSaveFileDialog)
        {
            AvaloniaFilePickerFileTypeFilter fileTypes = new AvaloniaFilePickerFileTypeFilter.Item[] {
                new("MsgPack Files") {
                    Patterns = new[] { $"*{FileEx.MPO}", },
                    
/ </summary>
    
/ <param name="convert">集合元素ConvertToAuthenticator的委托</param>
    
/ <param name="items">令牌所在的集合</param>
    
/ <param name="index">被操作令牌所在集合的Index</param>
    
/ <param name="upOrDown">true为上移false为下移</param>
    
/ <param name="answer">操作云令牌所需的安全问题答案</param>
    
/ <typeparam name="T"></typeparam>
    public static async Task<int> MoveAuthenticatorIndex<T>(Func<T, IAuthenticatorDTO> convert, IReadOnlyList<T> items,
        int index, bool upOrDown, string? answer = null)
    {
        var newIndex = upOrDown ? index - 1 : index + 1;
        return await ChangeAuthenticatorIndex(convert, items, index, newIndex, answer);
    }

    
/ </summary>
    
/ <param name="convert">集合元素ConvertToAuthenticator的委托</param>
    
/ <param name="items">令牌所在的集合</param>
    
/ <param name="oldIndex">被操作令牌所在集合的Index</param>
    
/ <param name="newIndex">被操作令牌需要调整到所在集合的Index</param>
    
/ <param name="answer">操作云令牌所需的安全问题答案</param>
    
/ <typeparam name="T"></typeparam>
    
/ <returns></returns>
    public static async Task<int> ChangeAuthenticatorIndex<T>(Func<T, IAuthenticatorDTO> convert, IReadOnlyList<T> items,
        int oldIndex, int newIndex, string? answer = null)
    {
        var item = items[oldIndex];
        var item2Index = newIndex;
        if (item2Index <= -1 || item2Index >= items.Count || oldIndex == newIndex) return 0;
        var item2 = items[item2Index];
        var itemC = convert(item);
        var itemC2 = convert(item2);
        var orderIndex = itemC.Index;
        var orderIndex2 = itemC2.Index;
        itemC.Index = orderIndex2;
        itemC2.Index = orderIndex;
        var result = (await Task.WhenAll(UpdateAuthenticatorIndex(itemC, answer), UpdateAuthenticatorIndex(itemC2, answer)))
            .Sum();
        if (result < 2)
        {
            itemC.Index = orderIndex;
            itemC2.Index = orderIndex2;
            result = (await Task.WhenAll(UpdateAuthenticatorIndex(itemC, answer),
                    UpdateAuthenticatorIndex(itemC2, answer)))
                .Sum();
        }
        return result;
    }

    static async Task<int> UpdateAuthenticatorIndex(IAuthenticatorDTO authenticatorDto,
        string? answer = null)
    {
        if (authenticatorDto.ServerId == null) return await repository.UpdateIndexByItemAsync(authenticatorDto);
        if (string.IsNullOrEmpty(answer)) return 0;
        var response = await IMicroServiceClient.Instance.AuthenticatorClient.SyncAuthenticatorsToCloud(new()
        {
            Difference = new[]
            {
                new UserAuthenticatorPushItem()
                {
                    Id = authenticatorDto.ServerId,
                    Order = authenticatorDto.Index,
                    Name = authenticatorDto.Name,
                },
            },
            Answer = answer,
        });
        response.Content.ThrowIsNull();
        if (response.IsSuccess && response.Content.Result) return await repository.UpdateIndexByItemAsync(authenticatorDto);
        Toast.Show(ToastIcon.Warning, AppResources.Error_UpdateCloudData);
        return 0;
    }

    
/ </summary>
    
/ <returns>成功返回正确答案，失败返回null</returns>
    
/ <exception cref="Exception">后端异常信息</exception>
    public static async Task<string?> VerifyIndependentPassword()
    {
        string? question = null;
        string? answer = null;
        var passwordQuestionResponse =
            await IMicroServiceClient.Instance.AuthenticatorClient.GetIndependentPasswordQuestion();
        if (passwordQuestionResponse.Content == null && passwordQuestionResponse.Code != ApiRspCode.Unauthorized)
        {
            var textViewModel = new TextBoxWindowViewModel();
            if (!await IWindowManager.Instance.ShowTaskDialogAsync(textViewModel, AppResources.Title_SetSecurityIssues,
                    subHeader: AppResources.SubHeader_FirstSyncSetAuth, isCancelButton: true)) return null;
            question = textViewModel.Value;
            textViewModel = new TextBoxWindowViewModel();
            if (!await IWindowManager.Instance.ShowTaskDialogAsync(textViewModel, AppResources.Title_SetSecurityIssues, subHeader: AppResources.SubHeader_PleaseEnterTheAnswerAgain,
                    isCancelButton: true)) return null;
            answer = textViewModel.Value;
            if (string.IsNullOrEmpty(question) || string.IsNullOrEmpty(answer)) return null;
            var setPassword =
                await IMicroServiceClient.Instance.AuthenticatorClient.SetIndependentPassword(new()
                {
                    PwdQuestion = question,
                    Answer = answer,
                });
            if (!setPassword.IsSuccess)
            {
                Toast.Show(ToastIcon.Error, AppResources.Error_SetSecurityIssuesFailed);
                return null;
            }
        }

        question ??= passwordQuestionResponse.Content;
        var answerTextViewModel = new TextBoxWindowViewModel();
        if (string.IsNullOrEmpty(answer) && await IWindowManager.Instance.ShowTaskDialogAsync(answerTextViewModel,
             AppResources.Title_PleaseEnterTheAnswer, subHeader: AppResources.SubHeader_SecurityIssues_.Format(question), isCancelButton: true))
        {
            answer = answerTextViewModel.Value;

            if (string.IsNullOrEmpty(answer))
            {
                Toast.Show(ToastIcon.Error, AppResources.Error_PleaseEnterAnswer);
                return await VerifyIndependentPassword();
            }

            var verifyResponse =
                await IMicroServiceClient.Instance.AuthenticatorClient
                    .VerifyIndependentPassword(new() { Answer = answer, });
            if (!verifyResponse.Content)
            {
                Toast.Show(ToastIcon.Error, AppResources.Error_AnswerIncorrect);
                return await VerifyIndependentPassword();
            }
        }

        return answer;
    }

    public static IAuthenticatorDTO ConvertToAuthenticatorDto(
        UserAuthenticatorResponse authenticatorResponse)
    {
        var exportDto = MemoryPackSerializer.Deserialize<AuthenticatorExportDTO>(authenticatorResponse.Token);
        exportDto.ThrowIsNull();
        var valueDto = ConvertToAuthenticatorValueDto(exportDto);
        AuthenticatorDTO dto = new AuthenticatorDTO()
        {
            ServerId = authenticatorResponse.Id,
            Value = valueDto,
            Name = exportDto.Name,
            Index = (int)authenticatorResponse.Order,
            
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Authenticator\Helpers\AuthenticatorRegexHelper.cs
/.*")]
    internal static partial Regex SecretCodeHttpRegex();

    [GeneratedRegex(@"data:image/([^;]+);base64,(.*)", RegexOptions.IgnoreCase)]
    internal static partial Regex SecretCodeDataImageRegex();

    [GeneratedRegex(@"otpauth:
/([^/]+)/([^?]+)\?(.*)", RegexOptions.IgnoreCase)]
    internal static partial Regex SecretCodeOptAuthRegex();

    [GeneratedRegex(@"[^0-9a-z]", RegexOptions.IgnoreCase)]
    internal static partial Regex SecretHexCodeAuthRegex();
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Authenticator\Plugins\Plugin.cs
/BD.WTTS.Client.Plugins.Authenticator/UI/Assets/authenticator.ico";

    public override IEnumerable<MenuTabItemViewModel>? GetMenuTabItems()
    {
        yield return new MenuTabItemViewModel(this, nameof(Strings.LocalAuth))
        {
            
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Authenticator\Properties\Resources.Designer.cs
/ </auto-generated>

/ </summary>
    
/ (以 /str 作为命令选项)，或重新生成 VS 项目。
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        
/ </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("BD.WTTS.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        
/ </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        
/ </summary>
        internal static byte[] authenticator {
            get {
                object obj = ResourceManager.GetObject("authenticator", resourceCulture);
                return ((byte[])(obj));
            }
        }
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Authenticator\Repositories\Abstractions\IAccountPlatformAuthenticatorRepository.cs
/ </summary>
    const int MaxValue = 1000;

    
/ </summary>
    
/ <param name="secondaryPassword"></param>
    
/ <returns></returns>
    [Obsolete("use GetAllSourceAsync()")]
    Task<List<IAuthenticatorDTO>> GetAllAsync(string? secondaryPassword = null);

    
/ </summary>
    
/ <returns></returns>
    Task<AccountPlatformAuthenticator[]> GetAllSourceAsync();

    
/ </summary>
    
/ <returns></returns>
    Task<AccountPlatformAuthenticator?> GetFirstOrDefaultSourceAsync();

    
/ </summary>
    
/ <param name="sources"></param>
    
/ <returns></returns>
    bool HasLocal(IEnumerable<AccountPlatformAuthenticator> sources)
        => sources.Any() && sources.Any(x => !x.IsNotLocal);

    
/ <inheritdoc cref="HasLocal(IEnumerable{AccountPlatformAuthenticator})"/>
    bool HasLocal(params AccountPlatformAuthenticator[] sources)
    {
        IEnumerable<AccountPlatformAuthenticator> sources_ = sources;
        return HasLocal(sources_);
    }

    
/ <inheritdoc cref="HasLocal(IEnumerable{AccountPlatformAuthenticator})"/>
    Task<bool> HasLocalAsync();

    
/ </summary>
    
/ <param name="sources"></param>
    
/ <returns></returns>
    bool HasSecondaryPassword(IEnumerable<AccountPlatformAuthenticator> sources)
        => sources.Any() && sources.Any(x => x.IsNeedSecondaryPassword);

    
/ <inheritdoc cref="HasSecondaryPassword(IEnumerable{AccountPlatformAuthenticator})"/>
    bool HasSecondaryPassword(params AccountPlatformAuthenticator[] sources)
    {
        IEnumerable<AccountPlatformAuthenticator> sources_ = sources;
        return HasSecondaryPassword(sources_);
    }

    
/ <inheritdoc cref="HasSecondaryPassword(IEnumerable{AccountPlatformAuthenticator})"/>
    Task<bool> HasSecondaryPasswordAsync();

    
/ </summary>
    
/ <param name="sources"></param>
    
/ <param name="secondaryPassword"></param>
    
/ <returns></returns>
    Task<List<IAuthenticatorDTO>> ConvertToListAsync(IEnumerable<AccountPlatformAuthenticator> sources, string? secondaryPassword = null);

    
/ 插入或更新一条到本地，插入前需要判断当前值是否超过了 <see cref="MaxValue"/>
    
/ </summary>
    
/ <param name="item"></param>
    
/ <param name="isLocal"></param>
    
/ <param name="secondaryPassword"></param>
    
/ <returns></returns>
    Task<(bool isSuccess, bool isUpdate)> InsertOrUpdateAsync(IAuthenticatorDTO item, bool isLocal, string? secondaryPassword = null);

    
/ <inheritdoc cref="InsertOrUpdateAsync(IAuthenticatorDTO, bool, string?)"/>
    async Task InsertOrUpdateAsync(IEnumerable<IAuthenticatorDTO> items, bool isLocal, string? secondaryPassword = null)
    {
        foreach (var item in items)
        {
            await InsertOrUpdateAsync(item, isLocal, secondaryPassword);
        }
    }

    
/ </summary>
    
/ <param name="sourceList"></param>
    
/ <param name="item"></param>
    
/ <param name="isLocal"></param>
    
/ <param name="secondaryPassword"></param>
    
/ <returns></returns>
    Task<bool> Exists(IEnumerable<AccountPlatformAuthenticator> sourceList, IAuthenticatorDTO item,
        bool isLocal, string? secondaryPassword = null);

    
/ </summary>
    
/ <param name="id"></param>
    
/ <returns></returns>
    Task DeleteAsync(ushort id);

    
/ </summary>
    
/ <param name="serverId"></param>
    
/ <returns></returns>
    Task DeleteAsync(Guid serverId);

    
/ </summary>
    
/ <param name="id"></param>
    
/ <param name="cancellationToken"></param>
    
/ <returns></returns>
    ValueTask<AccountPlatformAuthenticator?> FindAsync(ushort id, CancellationToken cancellationToken = default);

    
/ </summary>
    
/ <param name="source"></param>
    
/ <param name="name"></param>
    
/ <param name="isLocal"></param>
    
/ <returns></returns>
    Task RenameAsync(AccountPlatformAuthenticator source, string name, bool isLocal);

    
/ </summary>
    
/ <param name="id"></param>
    
/ <param name="name"></param>
    
/ <param name="isLocal"></param>
    
/ <returns></returns>
    Task RenameAsync(ushort id, string name, bool isLocal);

    
/ </summary>
    
/ <param name="id"></param>
    
/ <param name="serverId"></param>
    
/ <returns></returns>
    Task SetServerIdAsync(ushort id, Guid serverId);

    
/ <inheritdoc cref="SetServerIdAsync(ushort, Guid)"/>
    Task SetServerIdAsync(AccountPlatformAuthenticator source, Guid serverId);

    
/ </summary>
    
/ <param name="isLocal"></param>
    
/ <param name="secondaryPassword"></param>
    
/ <param name="items">可传递当前在视图模型上的数据，也可以传递 <see langword="null"/> 重新从数据库中查询</param>
    
/ <returns></returns>
    Task SwitchEncryptionModeAsync(bool isLocal, string? secondaryPassword, IEnumerable<IAuthenticatorDTO>? items = null);

    
/ </summary>
    
/ <param name="isLocal"></param>
    
/ <param name="secondaryPassword"></param>
    
/ <param name="items"></param>
    
/ <returns></returns>
    Task<byte[]> ExportAsync(bool isLocal, string? secondaryPassword, IEnumerable<IAuthenticatorDTO> items);

    
/ <inheritdoc cref="ExportAsync(bool, string?, IEnumerable{IAuthenticatorDTO})"/>
    Task<byte[]> ExportAsync(bool isLocal, string? secondaryPassword, params IAuthenticatorDTO[] items)
    {
        IEnumerable<IAuthenticatorDTO> sources_ = items;
        return ExportAsync(isLocal, secondaryPassword, sources_);
    }

    
/ <inheritdoc cref="ExportAsync(bool, string?, IEnumerable{IAuthenticatorDTO})"/>
    Task ExportAsync(Stream stream, bool isLocal, string? secondaryPassword, IEnumerable<IAuthenticatorDTO> items);

    
/ <inheritdoc cref="ExportAsync(bool, string?, IEnumerable{IAuthenticatorDTO})"/>
    Task ExportAsync(Stream stream, bool isLocal, string? secondaryPassword, params IAuthenticatorDTO[] items)
    {
        IEnumerable<IAuthenticatorDTO> sources_ = items;
        return ExportAsync(stream, isLocal, secondaryPassword, sources_);
    }

    
/ 导入一组数据，返回对应的DTO模型组，之后可调用 <see cref="InsertOrUpdateAsync(IEnumerable{IAuthenticatorDTO}, bool, string?)"/> 插入数据库
    
/ </summary>
    
/ <param name="secondaryPassword"></param>
    
/ <param name="content"></param>
    
/ <returns></returns>
    Task<(ImportResultCode resultCode, IReadOnlyList<IAuthenticatorDTO> result, int sourcesCount)> ImportAsync(string? secondaryPassword, byte[] content);

    
/ </summary>
    
/ <typeparam name="T"></typeparam>
    
/ <param name="convert"></param>
    
/ <param name="items"></param>
    
/ <param name="index"></param>
    
/ <param name="upOrDown"></param>
    
/ <returns></returns>
    Task<int> MoveOrderByIndexAsync<T>(Func<T, IAuthenticatorDTO> convert, IReadOnlyList<T> items, int index, bool upOrDown);

    
/ <inheritdoc cref="MoveOrderByIndexAsync{T}(Func{T, IAuthenticatorDTO}, IReadOnlyList{T}, int, bool)"/>
    async Task<int> MoveOrderByItemAsync<T>(Func<T, IAuthenticatorDTO> convert, IReadOnlyList<T> items, T item, bool upOrDown)
    {
        var index = items.IndexOf(item);
        if (index > -1)
        {
            return await MoveOrderByIndexAsync<T>(convert, items, index, upOrDown);
        }
        return 0;
    }

    
/ </summary>
    
/ <param name="item"></param>
    
/ <returns>受影响的行数</returns>
    Task<int> UpdateIndexByItemAsync(IAuthenticatorDTO item);

    public enum ImportResultCode
    {
        
/ </summary>
        Success = 200,

        
/ </summary>
        PartSuccess,

        
/ </summary>
        IncorrectFormat = 400,

        
/ <inheritdoc cref="DResultCode.EmbeddedAesFail"/>
        EmbeddedAesFail = DResultCode.EmbeddedAesFail,

        
/ <inheritdoc cref="DResultCode.LocalFail"/>
        LocalFail = DResultCode.LocalFail,

        
/ <inheritdoc cref="DResultCode.SecondaryPasswordFail"/>
        SecondaryPasswordFail = DResultCode.SecondaryPasswordFail,

        
/ <inheritdoc cref="DResultCode.IncorrectValueFail"/>
        IncorrectValueFail = DResultCode.IncorrectValueFail,

        
/ <inheritdoc cref="DResultCode.UTF8GetStringFail"/>
        UTF8GetStringFail = DResultCode.UTF8GetStringFail,
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Authenticator\UI\ViewModels\AddSteamAccountPhoneNumberPageViewModel.cs
/ </summary>
public class AddSteamAccountPhoneNumberPageViewModel : WindowViewModel
{
    #region 步骤 Index 定义

    const int TAB_INDEX_BINDING = 0;

    const int TAB_INDEX_CONFIRMATION_Email = 1;

    const int TAB_INDEX_CONFIRMATION_SMS = 2;

    #endregion 步骤 Index 定义

    
/ </summary>
    [Reactive]
    public string? PhoneNumberText { get; set; }

    
/ </summary>
    [Reactive]
    public string? CodeText { get; set; }

    
/ </summary>
    [Reactive]
    public int SelectIndex { get; set; }

    
/ </summary>
    [Reactive]
    public bool IsLoading { get; set; }

    private readonly SteamAuthenticator.EnrollState _enrollState;
    private readonly SteamAuthenticator _steamAuthenticator;

    public AddSteamAccountPhoneNumberPageViewModel(
        SteamAuthenticator.EnrollState enrollState,
        SteamAuthenticator steamAuthenticator
        )
    {
        SelectIndex = TAB_INDEX_BINDING;

        _steamAuthenticator = steamAuthenticator;
        _enrollState = enrollState;
    }

    
/ </summary>
    
/ <returns></returns>
    public async Task StartBindingAsync()
    {
        if (IsLoading)
        {
            Toast.Show(ToastIcon.Warning, AppResources.Warning_DoNotOperateFrequently);
            return;
        }

        if (string.IsNullOrEmpty(PhoneNumberText))
        {
            Toast.Show(ToastIcon.Warning, AppResources.Warning_PleaseEnterTel);
            return;
        }

        IsLoading = true;

        try
        {
            string? msg = await _steamAuthenticator.AddPhoneNumberAsync(_enrollState, PhoneNumberText);

            Toast.Show(ToastIcon.Info, msg ?? string.Empty);

            if (_enrollState.RequiresEmailConfirmPhone)
            {
                SelectIndex = TAB_INDEX_CONFIRMATION_Email;
            }
            else
            {
                SelectIndex = TAB_INDEX_CONFIRMATION_SMS;
            }
        }
        finally
        {
            IsLoading = false;
        }

    }

    
/ </summary>
    
/ <returns></returns>
    public async Task ConfirmBindingEmailAsync()
    {
        if (IsLoading)
        {
            Toast.Show(ToastIcon.Warning, AppResources.Warning_DoNotOperateFrequently);
            return;
        }

        if (string.IsNullOrEmpty(PhoneNumberText))
        {
            Toast.Show(ToastIcon.Warning, AppResources.Warning_PleaseEnterTel);
            return;
        }

        IsLoading = true;

        try
        {
            var reslut = await _steamAuthenticator.AddPhoneNumberAsync(_enrollState, PhoneNumberText!);

            if (_enrollState.RequiresEmailConfirmPhone == false && reslut == null)
            {
                SelectIndex = TAB_INDEX_CONFIRMATION_SMS;
            }
        }
        finally
        {
            IsLoading = false;
        }
    }

    
/ </summary>
    
/ <returns></returns>
    public async Task VerifyAccountPhoneWithCodeAsync()
    {
        if (string.IsNullOrEmpty(PhoneNumberText))
        {
            Toast.Show(ToastIcon.Warning, AppResources.Warning_PleaseEnterTel);
            return;
        }

        if (string.IsNullOrEmpty(CodeText))
        {
            Toast.Show(ToastIcon.Warning, AppResources.Error_PleaseEnterTelCode);
            return;
        }

        var verified = await _steamAuthenticator
            .VerifyPhoneNumberAsync(PhoneNumberText!, CodeText!, _enrollState.AccessToken!);

        if (verified)
        {
            Close?.Invoke(verified);
        }
    }
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.Authenticator\UI\ViewModels\AuthenticatorGeneralImportPageViewModel.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Authenticator\UI\ViewModels\AuthenticatorGeneralImportPageViewModel.props.cs
/ </summary>
    [Reactive]
    public int Period { get; set; } = 30;

    
/ </summary>
    [Reactive]
    public int CodeDigits { get; set; } = 6;
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Authenticator\UI\ViewModels\AuthenticatorImportPageViewModel.cs
/totp/ or otpauth:
/hotp/");
                }

                
/ skip past initial /
                int p = label.IndexOf(":", StringComparison.Ordinal);
                if (p != -1)
                {
                    issuer = label.Substring(0, p);
                    label = label[(p + 1)..];
                }

                
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Authenticator\UI\ViewModels\JoinSteamAuthenticatorPageViewModel.cs
/ </summary>
public sealed partial class JoinSteamAuthenticatorPageViewModel : ViewModelBase
{
    #region 步骤索引常量

    const int STEPINDEX_LOGIN = 0;

    const int STEPINDEX_VERIFY = 1;

    const int STEPINDEX_DONE = 2;

    #endregion 步骤索引常量

    #region 页面属性

    
/ </summary>
    [Reactive]
    public string? Code { get; set; }

    
/ </summary>
    [Reactive]
    public string? UserNameText { get; set; }

    
/ </summary>
    [Reactive]
    public string? PasswordText { get; set; }

    
/ </summary>
    [Reactive]
    public string? VerifyCodeText { get; set; }

    
/ </summary>
    [Reactive]
    public string? RevocationCodeText { get; set; }

    
/ </summary>
    [Reactive]
    public int SelectIndex { get; set; } = STEPINDEX_LOGIN;

    
/ </summary>
    [Reactive]
    public bool Loading { get; set; } = false;

    
/ </summary>
    [Reactive]
    public bool RequireVerifyCode { get; set; } = false;

    #endregion 页面属性

    #region 私有变量

    
/ </summary>
    private static readonly ISteamAccountService _steamAccountService = Ioc.Get<ISteamAccountService>();

    
/ </summary>
    private SteamAuthenticator? _currentSteamAuthenticator;

    private SteamLoginState? _currentSteamLoginState;

    #endregion 私有变量

    #region 联合 Steam令牌 页面流程

    
/ </summary>
    
/ <returns></returns>
    public async Task LoginAsync()
    {
        if (Loading)
            return;

        Loading = true;

        try
        {
            if (string.IsNullOrEmpty(UserNameText) || string.IsNullOrEmpty(PasswordText))
            {
                Toast.Show(ToastIcon.Error, AppResources.Error_PleaseEnterUsernamePassword);
                return;
            }

            
/ 根据登录信息 获取/初始化 TwoFA Steam Authenticator 信息
            var (initialized, errMsg) = await InitTwoFASteamAuthenticatorAsync(loginState);

            if (!initialized)
            {
                Toast.Show(ToastIcon.Error, errMsg);
                return;
            }

            RevocationCodeText = _currentSteamAuthenticator!.RecoveryCode;
            
/ </summary>
    
/ <returns></returns>
    public async Task VerifyCodeAsync()
    {
        if (Loading)
            return;

        Loading = true;
        try
        {
            if (string.IsNullOrWhiteSpace(Code))
            {
                Toast.Show(ToastIcon.Error, AppResources.LocalAuth_JoinSteamAuthenticator_SteamGuardCodeEmptyError);
                return;
            }

            var equals = await CompareCodeAsync();

            if (!equals)
            {
                Toast.Show(ToastIcon.Warning,
                    $@"{AppResources.LocalAuth_JoinSteamAuthenticator_VerifySteamGuardCodeError}: {Code} != {_currentSteamAuthenticator?.CurrentCode}");
                return;
            }

            RevocationCodeText = _currentSteamAuthenticator!.RecoveryCode;
            SelectIndex = STEPINDEX_DONE;
        }
        finally
        {
            Loading = false;
        }
    }

    
/ </summary>
    
/ <returns></returns>
    public async Task SaveAsync()
    {
        if (Loading)
            return;

        Loading = true;

        try
        {
            if (_currentSteamAuthenticator == null)
            {
                Toast.Show(ToastIcon.Error, AppResources.LocalAuth_JoinSteamAuthenticator_InitLocalAuthenticatorError);
                SelectIndex = STEPINDEX_LOGIN;
                return;
            }

            if (string.IsNullOrEmpty(Code))
            {
                Toast.Show(ToastIcon.Error, AppResources.LocalAuth_JoinSteamAuthenticator_SteamGuardCodeEmptyError);
                SelectIndex = STEPINDEX_VERIFY;
                return;
            }

            if (!await SaveAuthenticatorAsync(UserNameText!, _currentSteamAuthenticator))
            {
                Toast.Show(ToastIcon.Error, AppResources.LocalAuth_JoinSteamAuthenticator_SaveLocalAuthenticatorError);
                return;
            }

            
/ </summary>
    
/ <returns></returns>
    public async Task ResetRevocationCodeAsync()
    {
        if (_currentSteamLoginState == null)
        {
            return;
        }

        
/ 根据登录信息 获取/初始化 TwoFA Steam Authenticator 信息
        var (initialized, errMsg) = await InitTwoFASteamAuthenticatorAsync(_currentSteamLoginState);

        if (!initialized)
        {
            Toast.Show(ToastIcon.Error, errMsg);
            return;
        }

        RevocationCodeText = _currentSteamAuthenticator!.RecoveryCode;
    }

    #endregion 联合 Steam令牌 页面流程

    #region 辅助方法

    
/ </summary>
    
/ <param name="loginState"></param>
    
/ <returns></returns>
    private async Task<(bool initialized, string errorMsg)> InitTwoFASteamAuthenticatorAsync(SteamLoginState loginState)
    {
        _currentSteamAuthenticator = new SteamAuthenticator();

        string? steamId = loginState.SteamId != default
            ? loginState.SteamId.ToString()
            : null;

        if (string.IsNullOrEmpty(steamId))
            return (false, $"{AppResources.LocalAuth_JoinSteamAuthenticator_InitLocalAuthenticatorError}:{nameof(steamId)}");

        string deviceId = CreateNewDeviceId();

        var client = _currentSteamAuthenticator.GetClient();

        string authenticatorJson;

        try
        {
            authenticatorJson = await client
                .AddAuthenticatorAsync(
                        steamId,
                        DateTimeOffset.UtcNow.ToUnixTimeSeconds().ToString(),
                        deviceId,
                        loginState.AccessToken ?? string.Empty
                    );
        }
        catch (Exception ex)
        {
            return (false, $"{AppResources.LocalAuth_JoinSteamAuthenticator_RequestUser2FAInfoError}:{ex.Message}");
        }

        if (string.IsNullOrEmpty(authenticatorJson))
            return (false, AppResources.LocalAuth_JoinSteamAuthenticator_RequestUser2FAInfoError);

        var (initialized, msg) = TryParseSteamAuthenticator(authenticatorJson, out var parsedSteamData)
            ? (true, string.Empty)
            : (false, AppResources.LocalAuth_JoinSteamAuthenticator_ParseUser2FAInfoError);

        
/ </summary>
    
/ <returns></returns>
    private async Task<bool> CompareCodeAsync()
    {
        if (_currentSteamAuthenticator == null)
        {
            return false;
        }

        try
        {
            await Task.Yield();

            _currentSteamAuthenticator.Sync();
        }
        catch (Exception ex)
        {
            ex.LogAndShowT();
            return false;
        }

        bool compareResult = string.Equals(Code, _currentSteamAuthenticator?.CurrentCode, StringComparison.OrdinalIgnoreCase);

        return compareResult;
    }

    
/ </summary>
    
/ <param name="authenticatorJson"></param>
    
/ <param name="parsedSteamAuthenticator">已解析的响应信息</param>
    
/ <returns></returns>
    private static bool TryParseSteamAuthenticator(string authenticatorJson, out SteamConvertSteamDataJsonStruct? parsedSteamAuthenticator)
    {
        parsedSteamAuthenticator = default;

        SteamDoLoginTfaJsonStruct? authenticatorDataResp;

        try
        {
            authenticatorDataResp = SystemTextJsonSerializer.Deserialize(
                   authenticatorJson,
                   SteamJsonContext.Default.SteamDoLoginTfaJsonStruct
               );
        }
        catch (Exception)
        {
            return false;
        }

        if (authenticatorDataResp == null || authenticatorDataResp.Response == null)
            return false;

        parsedSteamAuthenticator = authenticatorDataResp.Response;

        
/ </summary>
    
/ <param name="authenticatorName"></param>
    
/ <param name="authenticator"></param>
    
/ <returns></returns>
    private static Task<bool> SaveAuthenticatorAsync(string authenticatorName, SteamAuthenticator authenticator)
    {
        var iADTO = new AuthenticatorDTO
        {
            Name = $"Steam({authenticatorName})",
            Value = authenticator,
            Created = DateTimeOffset.Now,
        };

        return AuthenticatorHelper.SaveAuthenticator(iADTO);
    }

    
/ </summary>
    
/ <returns></returns>
    private static string CreateNewDeviceId() => $"android:{Guid.NewGuid()}";

    
/ </summary>
    public void Reset()
    {
        UserNameText = default;
        PasswordText = default;
        Code = default;
        VerifyCodeText = default;
        RequireVerifyCode = default;
        RevocationCodeText = default;
        SelectIndex = STEPINDEX_LOGIN;

        _currentSteamAuthenticator = default;
        _currentSteamLoginState = default;
    }

    #endregion 辅助方法
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Authenticator\UI\ViewModels\SteamGuardImportPageViewModel.cs
/* AuthService.ImportSteamGuard (System.String name, System.String uuid, System.String steamGuard, System.Boolean isLocal, System.String password)
                 * System.NullReferenceException: Object reference not set to an instance of an object
                 * Crash Version 2.6.5(20220206) 12 users 14 reports
                 * Android 9 ~ 12
                 */
            PhoneImportUuid.ThrowIsNull();
            PhoneImportSteamGuard.ThrowIsNull();
            ImportAuthNewName.ThrowIsNull();

            
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Authenticator\UI\ViewModels\SteamLoginImportPageViewModel.cs
/ </summary>
    public void Reset()
    {
        _steamLoginState = new();
        UserNameText = null;
        PasswordText = null;
        CaptchaImageText = null;
        EmailAuthText = null;
        EmailDomainText = null;
        PhoneCodeText = null;
        RevocationCodeText = null;
        SelectIndex = 0;
    }

    private async Task LoginSteamFirstAsync()
    {
        if (string.IsNullOrWhiteSpace(UserNameText) || string.IsNullOrWhiteSpace(PasswordText))
        {
            Toast.Show(ToastIcon.Error, AppResources.Error_PleaseEnterUsernamePassword);
            return;
        }
        _steamLoginState.Username = UserNameText;
        _steamLoginState.Password = PasswordText;
        _steamLoginState.Language = ResourceService.GetCurrentCultureSteamLanguageName();
        IsLoading = true;

        await _steamAccountService.DoLoginV2Async(_steamLoginState);
    }

    
/ </summary>
    
/ <returns></returns>
    async Task CheckAddAuthenticatorResult()
    {
        if (string.IsNullOrEmpty(_enrollState.Error) == false)
        {
            if (_enrollState.Error.Length > 50)
                await IWindowManager.Instance.ShowTaskDialogAsync(
                    new MessageBoxWindowViewModel { Content = _enrollState.Error });
            else
                Toast.Show(ToastIcon.Info, _enrollState.Error);
        }

        if (_enrollState.NoPhoneNumber == true)
        {
            _enrollState.Error = null;
            
/ </summary>
    
/ <param name="result"></param>
    
/ <returns>accessToken不为空返回true,否则返回false</returns>
    async Task<bool> CheckLoginResult()
    {
        
/ 如果通过弹出的绑定手机号绑定成功 开始执行替换令牌
                            if (added && IsVerifyAccountPhone)
                            {
                                /*
                                 * 绑定手机号会发送验证码
                                 * 执行开始替换令牌操作也会发送验证码
                                 * 如果两个操作间隔太短会导致 Steam 不发送验证码
                                 */

                                await Task.Delay(TimeSpan.FromSeconds(30));

                                await steamAuthenticator.RemoveAuthenticatorViaChallengeStartSync(_enrollState.AccessToken!);
                            }
                            
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Authenticator\UI\ViewModels\SteamLoginImportPageViewModel.props.cs
/ </summary>
    [Reactive]
    public int SelectIndex { get; set; }

    
/ </summary>
    [Reactive]
    public string? UserNameText { get; set; }

    
/ </summary>
    [Reactive]
    public string? PasswordText { get; set; }

    
/ </summary>
    [Reactive]
    public string? PhoneCodeText { get; set; }

    
/ </summary>
    [Reactive]
    public string? RevocationCodeText { get; set; }

    
/ </summary>
    [Reactive]
    public string? EmailAuthText { get; set; }

    
/ </summary>
    [Reactive]
    public bool Requires2FA { get; set; }

    
/ </summary>
    [Reactive]
    public string? CaptchaImageText { get; set; }

    
/ </summary>
    [Reactive]
    public string? EmailDomainText { get; set; }

    [Reactive]
    public string? PhoneNumberText { get; set; }

    
/ </summary>
    [Reactive]
    public bool IsVerifyAccountPhone { get; set; }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.GameAccount\Extensions\JTokenExtensions.cs
/ </summary>
    
/ <typeparam name="T"></typeparam>
    
/ <param name="jsonString">JSON string to edit</param>
    
/ <param name="path">Selector path of key to be edited</param>
    
/ <param name="newValue">New value for key/s</param>
    
/ <returns>Modified JSON string</returns>
    public static string ReplacePath<T>(string jsonString, string path, T newValue)
    {
        return JToken.Parse(jsonString).ReplacePath(path, newValue).ToString();
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.GameAccount\Helpers\JTokenHelper.cs
/ </summary>
    public static void SaveJsonFile(string path, JToken jo, bool formatted = true)
    {
        File.WriteAllText(path, JsonConvert.SerializeObject(jo, formatted ? Formatting.Indented : Formatting.None));
    }

    
/ </summary>
    
/ <param name="dictPath">Full *.json file path (file safe)</param>
    
/ <param name="isBasic"></param>
    public static Dictionary<string, string> ReadDict(string dictPath, bool isBasic = false)
    {
        var s = JsonConvert.SerializeObject(new Dictionary<string, string>());
        if (!File.Exists(dictPath))
        {
            if (isBasic && !IOPath.PathIsDirectoryEmpty(Path.GetDirectoryName(dictPath)!))
            {
                Toast.Show(ToastIcon.Error, AppResources.Error_OperateRegistryFilesFailed);
            }
            return JsonConvert.DeserializeObject<Dictionary<string, string>>(s) ?? new Dictionary<string, string>();
        }
        try
        {
            s = IPlatformService.Instance.ReadAllText(dictPath);
        }
        catch (Exception)
        {
        }

        return JsonConvert.DeserializeObject<Dictionary<string, string>>(s) ?? new Dictionary<string, string>();
    }

    public static void SaveDict(Dictionary<string, string> dict, string path, bool deleteIfEmpty = false)
    {
        if (path == null) return;
        var outText = JsonConvert.SerializeObject(dict);
        if (outText.Length < 4 && File.Exists(path))
            IPlatformService.Instance.FileTryDelete(path);
        else
            File.WriteAllText(path, outText);
    }

    public static Dictionary<string, string> ReadRegJson(string path) => ReadDict(path, true);

    public static void SaveRegJson(Dictionary<string, string> regJson, string path)
    {
        if (regJson.Count > 0)
            JTokenHelper.SaveDict(regJson, path, true);
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.GameAccount\Helpers\PathHelper.cs
/ </summary>
    
/ <param name="fromPath"></param>
    
/ <param name="toPath"></param>
    
/ <param name="localCachePath"></param>
    
/ <param name="reverse">FALSE: Platform -> LoginCache. TRUE: LoginCache -> J••Platform</param>
    public static bool HandleFileOrFolder(string fromPath, string toPath, string localCachePath, bool reverse, string? folderPath = null)
    {
        
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.GameAccount\Helpers\RegexHelper.cs
/ </summary>
    public static string ExpandRegex(string regex)
    {
        Dictionary<string, string> regexDictionary = new()
        {
                { "EMAIL_REGEX", "(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])" },
                { "WIN_FILEPATH_REGEX", @"[a-zA-Z]:[\\\/](?:[a-zA-Z0-9]+[\\\/])*([a-zA-Z0-9]+\.[a-zA-Z]*)" },
        };

        return regexDictionary.ContainsKey(regex) ? regexDictionary[regex] : regex;
    }

    
/ 获取注册表文件的字符串内容，或与正则表达式/通配符匹配的文件的路径。
    
/ </summary>
    
/ <param name="accFile"></param>
    
/ <param name="regex"></param>
    
/ <returns></returns>
    public static string? RegexSearchFileOrFolder(string accFile, string regex)
    {
        accFile = IOPath.ExpandEnvironmentVariables(accFile);
        regex = ExpandRegex(regex);
        
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.GameAccount\Helpers\RegexHelper.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.GameAccount\Models\PlatformAccount.cs
/LoadUsers();
    }

    public void LoadUsers()
    {
        Task2.InBackground(async () =>
        {
            if (IsLoading) return;
            IsLoading = true;
            try
            {
                Accounts.Clear();
                var users = await platformSwitcher.GetUsers(this, () =>
                {
                    if (Accounts.Any_Nullable())
                        foreach (var user in Accounts)
                        {
                            if (user is SteamAccount su)
                            {
                                su.RaisePropertyChanged(nameof(su.ImagePath));
                                su.RaisePropertyChanged(nameof(su.AvatarFramePath));
                            }
                        }
                });

                if (users.Any_Nullable())
                    Accounts = new ObservableCollection<IAccount>(users.OrderByDescending(x => x.LastLoginTime));
            }
            catch (Exception ex)
            {
                ex.LogAndShowT(nameof(PlatformAccount));
            }
            finally
            {
                IsLoading = false;
            }
        });
    }

    public async ValueTask<bool> CurrnetUserAdd(string? name)
    {
        if (string.IsNullOrEmpty(name))
        {
            await platformSwitcher.NewUserLogin(this);
            return true;
        }
        return await platformSwitcher.CurrnetUserAdd(name, this);
    }

    public async void CreateShortcut(IAccount acc)
    {
#if WINDOWS
        var gear = new[] { 512, 256, 128, 96, 64, 48, 32, 24, 16 };
        using var avatarImgBitmap = await Decode(acc.AvatarMedium);
        var iconSize = GetImgResolutionPower(Math.Min(avatarImgBitmap.Width, avatarImgBitmap.Height), gear);
        using var fBitmap = DrawIcon(avatarImgBitmap, SKBitmap.Decode(IApplication.Login_512), iconSize.Max());
        SKBitmap[]? bitmaps = new[] { fBitmap }.Concat(iconSize.Where(x => x != iconSize.Max())
            .Select(x => fBitmap.Resize(new SKSizeI { Height = x, Width = x }, SKFilterQuality.High)))
            .ToArray();
        try
        {
            var localCachePath = Path.Combine(PlatformLoginCache, acc.AccountName!, "Icon");
            IOPath.DirTryDelete(localCachePath);
            Directory.CreateDirectory(localCachePath);

            var savePath = Path.Combine(localCachePath, $"{Guid.NewGuid()}.ico");
            using (var fs = new FileStream(savePath, FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.ReadWrite | FileShare.Delete))
            {
                IcoEncoder.Encode(fs, bitmaps);
                fs.Flush();
            }
            var deskTopPath = Path.Combine(
                Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory),
                $"{acc.DisplayName ?? acc.AccountName ?? acc.AccountId}.lnk");

            var processPath = Environment.ProcessPath;
            processPath.ThrowIsNull();
            if (!DesktopBridge.IsRunningAsUwp)
            {
                platformSwitcher.CreateSystemProtocol(processPath);
            }
            var args = $"-clt steam -account {acc.AccountName}";
            await platformSwitcher.CreateLoginShortcut(
                deskTopPath,
                $"{Constants.CUSTOM_URL_SCHEME}args/{HttpUtility.UrlEncode(args)}",
                null,
                null,
                null,
                savePath,
                null);
            Toast.Show(ToastIcon.Success, Strings.CreateShortcutInfo);
        }
        finally
        {
            if (bitmaps != null)
                bitmaps.ForEach(x => x.Dispose());
        }
#endif
    }

    async Task<SKBitmap> Decode(string? avatarImgPath)
    {
        if (string.IsNullOrWhiteSpace(avatarImgPath))
            return SKBitmap.Decode(AssetLoader.Open(new Uri("avares:
/BD.WTTS.Client.Avalonia/UI/Assets/avatar.jpg")));
        if (avatarImgPath.StartsWith("https"))
        {
            using var client = new HttpClient();
            using var rspimg = await client.GetStreamAsync(avatarImgPath);
            return SKBitmap.Decode(rspimg);
        }
        return SKBitmap.Decode(avatarImgPath);
    }

    SKBitmap DrawIcon(SKBitmap originalBitmap, SKBitmap loginIcon, int iconSize)
    {
        loginIcon = loginIcon.Resize(new SKSizeI(iconSize / 3, iconSize / 3), SKFilterQuality.High);
        SKBitmap avatarImgBitmap = new(iconSize, iconSize);

        using SKCanvas canvas = new(avatarImgBitmap);
        SKPaint paint = new SKPaint();
        paint.FilterQuality = SKFilterQuality.High;
        canvas.DrawBitmap(originalBitmap.Resize(new SKSizeI(iconSize, iconSize), SKFilterQuality.High),
            new SKRect(0, 0, iconSize, iconSize), paint);

        canvas.DrawBitmap(loginIcon, new SKRect(0, 0, loginIcon.Width, loginIcon.Height));
        return avatarImgBitmap;
    }

    IEnumerable<int> GetImgResolutionPower(int size, int[] rp)
    {
        foreach (var item in rp)
        {
            if (item <= size) yield return item;
        }
    }
}

发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.GameAccount\Models\PlatformAccount.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.GameAccount\Plugins\Plugin.cs
/BD.WTTS.Client.Plugins.GameAccount/UI/Assets/userswitcher.ico";

    public override IEnumerable<MenuTabItemViewModel>? GetMenuTabItems()
    {
        yield return new MenuTabItemViewModel(this, nameof(Strings.UserFastChange))
        {
            PageType = typeof(GameAccountPage),
            IsResourceGet = true,
            IconKey = Icon,
        };
    }

    public override void ConfigureRequiredServices(IServiceCollection services, Startup startup)
    {
        services.AddSingleton<IPartialGameAccountSettings>(s =>
            s.GetRequiredService<IOptionsMonitor<GameAccountSettings_>>().CurrentValue);

        services.AddSingleton<IPlatformSwitcher, BasicPlatformSwitcher>()
                .AddSingleton<IPlatformSwitcher, SteamPlatformSwitcher>();
    }

    public override void OnAddAutoMapper(IMapperConfigurationExpression cfg)
    {

    }

    public override IEnumerable<(Action<IServiceCollection>? @delegate, bool isInvalid, string name)>? GetConfiguration(bool directoryExists)
    {
        yield return GetConfiguration<GameAccountSettings_>(directoryExists);
    }

    public override ValueTask OnInitializeAsync()
    {
        IViewModelManager.Instance.Get<GameAccountPageViewModel>();
        return default;
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.GameAccount\Properties\Resources.Designer.cs
/ </auto-generated>

/ </summary>
    
/ (以 /str 作为命令选项)，或重新生成 VS 项目。
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        
/ </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("BD.WTTS.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        
/ </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        
/ </summary>
        internal static byte[] userswitcher {
            get {
                object obj = ResourceManager.GetObject("userswitcher", resourceCulture);
                return ((byte[])(obj));
            }
        }
    }
}

发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.GameAccount\Services\IPlatformSwitcher.cs
WINDOWS
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.GameAccount\Services.Implementation\BasicPlatformSwitcher.cs
/ Foreach file/folder/reg in Platform.PathListToClear

        foreach (var accFile in platform.ClearPaths!)
        {
            if (!await DeleteFileOrFolder(accFile, platform))
                return false;
        }

        var uniqueIdFile = IOPath.ExpandEnvironmentVariables(platform.UniqueIdPath, platform.FolderPath);

        if (platform.UniqueIdType is UniqueIdType.JSON_SELECT or UniqueIdType.JSON_SELECT_FIRST or UniqueIdType.JSON_SELECT_LAST)
        {
            var path = uniqueIdFile.Split("::")[0];
            var selector = uniqueIdFile.Split("::")[1];
            JTokenHelper.ReplaceVarInJsonFile(path, selector, string.Empty);
        }

        if (platform.UniqueIdType != UniqueIdType.CREATE_ID_FILE) return true;

        
/ Could not find file/folder
                Toast.Show(ToastIcon.Error, AppResources.Error_CannotFindAccountFile_.Format(accFile));
                return false;
            }
            else
            {
                Log.Warn(nameof(CurrnetUserAdd), $"{accFile} Could not find file/folder");
            }
        }

        JTokenHelper.SaveRegJson(regJson, platform.RegJsonPath(name));

        var allIds = JTokenHelper.ReadDict(platform.IdsJsonPath);
        allIds[uniqueId] = name;
        File.WriteAllText(platform.IdsJsonPath, JsonConvert.SerializeObject(allIds));
        return true;
    }

    public string? GetUniqueId(PlatformAccount platform)
    {
#if WINDOWS
        if (platform.UniqueIdType is UniqueIdType.REGKEY &&
            !string.IsNullOrEmpty(platform.UniqueIdPath))
        {
            var r = Registry2.ReadRegistryKey(platform.UniqueIdPath[4..]);
            if (r == null)
                return null;

            switch (r)
            {
                case string s:
                    return s;
                case byte[] b:
                    return Hashs.String.SHA256(b);
                default:
                    Log.Warn(nameof(BasicPlatformSwitcher), $"{platform.FullName} Unexpected registry type encountered (1)! {r.GetType()}");
                    return null;
            }
        }
#endif

        if (string.IsNullOrEmpty(platform.UniqueIdPath))
            return null;

        var uniqueIdPath = IOPath.ExpandEnvironmentVariables(platform.UniqueIdPath, platform.FolderPath);

        if (string.IsNullOrEmpty(uniqueIdPath))
            return null;

        var uniqueId = "";

        if (platform.UniqueIdType is UniqueIdType.CREATE_ID_FILE)
        {
            return File.Exists(uniqueIdPath) ? File.ReadAllText(uniqueIdPath) : uniqueId;
        }

        if (uniqueId == "" && platform.UniqueIdType is UniqueIdType.JSON_SELECT or UniqueIdType.JSON_SELECT_FIRST or UniqueIdType.JSON_SELECT_LAST)
        {
            JToken? js = null;
            string searchFor;
            if (uniqueId == "" && platform.UniqueIdType is UniqueIdType.JSON_SELECT)
            {
                JTokenHelper.TryReadJsonFile(uniqueIdPath.Split("::")[0], ref js);
                searchFor = uniqueIdPath.Split("::")[1];
                uniqueId = IOPath.CleanPathIlegalCharacter((string?)js?.SelectToken(searchFor));
                return uniqueId;
            }

            string? delimiter;
            var firstResult = true;
            if (platform.UniqueIdType is UniqueIdType.JSON_SELECT_FIRST)
            {
                delimiter = platform.UniqueIdRegex;
            }
            else
            {
                delimiter = platform.UniqueIdRegex;
                firstResult = false;
            }

            JTokenHelper.TryReadJsonFile(uniqueIdPath.Split("::")[0], ref js);
            searchFor = uniqueIdPath.Split("::")[1];
            var res = (string?)js?.SelectToken(searchFor);
            if (res is null)
                return "";
            uniqueId = IOPath.CleanPathIlegalCharacter(firstResult ? res.Split(delimiter).First() : res.Split(delimiter).Last());
            return uniqueId;
        }

        if (!string.IsNullOrEmpty(uniqueIdPath) && (File.Exists(uniqueIdPath) || uniqueIdPath.Contains('*')))
        {
            if (!string.IsNullOrEmpty(platform.UniqueIdRegex))
            {
                uniqueId = IOPath.CleanPathIlegalCharacter(RegexHelper.RegexSearchFileOrFolder(uniqueIdPath, platform.UniqueIdRegex)); 
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.GameAccount\Services.Implementation\BasicPlatformSwitcher.cs
WINDOWS
WINDOWS
WINDOWS
WINDOWS
WINDOWS
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.GameAccount\Settings\GameAccountSettings.cs
/ </auto-generated>

/ </summary>
    [MPKey(0), MP2Key(0), JsonPropertyOrder(0)]
    public ConcurrentDictionary<string, string?>? AccountRemarks { get; set; } = IGameAccountSettings.DefaultAccountRemarks;

    
/ </summary>
    [MPKey(1), MP2Key(1), JsonPropertyOrder(1)]
    public IReadOnlyCollection<DisableAuthorizedDevice>? DisableAuthorizedDevice { get; set; } = IGameAccountSettings.DefaultDisableAuthorizedDevice;

    
/ </summary>
    [MPKey(2), MP2Key(2), JsonPropertyOrder(2)]
    public HashSet<string>? EnablePlatforms { get; set; } = IGameAccountSettings.DefaultEnablePlatforms;

    
/ </summary>
    [MPKey(3), MP2Key(3), JsonPropertyOrder(3)]
    public ConcurrentDictionary<string, PlatformSettings>? PlatformSettings { get; set; } = IGameAccountSettings.DefaultPlatformSettings;

    
/ </summary>
    [MPKey(4), MP2Key(4), JsonPropertyOrder(4)]
    public bool IsShowAccountName { get; set; } = IGameAccountSettings.DefaultIsShowAccountName;

}

public static partial class GameAccountSettings
{
    
/ </summary>
    public static SettingsProperty<string, string?, ConcurrentDictionary<string, string?>, GameAccountSettings_> AccountRemarks { get; }
        = new(DefaultAccountRemarks);

    
/ </summary>
    public static SettingsProperty<IReadOnlyCollection<DisableAuthorizedDevice>, GameAccountSettings_> DisableAuthorizedDevice { get; }
        = new(DefaultDisableAuthorizedDevice);

    
/ </summary>
    public static SettingsProperty<string, HashSet<string>, GameAccountSettings_> EnablePlatforms { get; }
        = new(DefaultEnablePlatforms);

    
/ </summary>
    public static SettingsProperty<string, PlatformSettings, ConcurrentDictionary<string, PlatformSettings>, GameAccountSettings_> PlatformSettings { get; }
        = new(DefaultPlatformSettings);

    
/ </summary>
    public static SettingsStructProperty<bool, GameAccountSettings_> IsShowAccountName { get; }
        = new(DefaultIsShowAccountName);

}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.GameAccount\Settings\Abstractions\IGameAccountSettings.cs
/ </auto-generated>

/ </summary>
    ConcurrentDictionary<string, string?>? AccountRemarks { get; set; }

    
/ </summary>
    IReadOnlyCollection<DisableAuthorizedDevice>? DisableAuthorizedDevice { get; set; }

    
/ </summary>
    HashSet<string>? EnablePlatforms { get; set; }

    
/ </summary>
    ConcurrentDictionary<string, PlatformSettings>? PlatformSettings { get; set; }

    
/ </summary>
    bool IsShowAccountName { get; set; }

    
/ </summary>
    static readonly ConcurrentDictionary<string, string?> DefaultAccountRemarks = new();

    
/ </summary>
    static readonly IReadOnlyCollection<DisableAuthorizedDevice> DefaultDisableAuthorizedDevice = Array.Empty<DisableAuthorizedDevice>();

    
/ </summary>
    static readonly HashSet<string> DefaultEnablePlatforms = new();

    
/ </summary>
    static readonly ConcurrentDictionary<string, PlatformSettings> DefaultPlatformSettings = new();

    
/ </summary>
    static readonly bool DefaultIsShowAccountName = false;

}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.GameAccount\UI\ViewModels\GameAccountPageViewModel.props.cs
/BD.WTTS.Client.Plugins.GameAccount/UI/Assets/Platforms.json");

    public override string Name => Strings.UserFastChange;

    [Reactive]
    public ObservableCollection<PlatformAccount>? GamePlatforms { get; set; }

    [Reactive]
    public ObservableCollection<PlatformAccount>? AddGamePlatforms { get; set; }

    [Reactive]
    public PlatformAccount? SelectedPlatform { get; set; }

    public bool IsSelectedSteam => SelectedPlatform?.FullName == nameof(ThirdpartyPlatform.Steam) == true;

    public ICommand AddPlatformCommand { get; }

    public ICommand LoginNewCommand { get; }

    public ICommand SaveCurrentUserCommand { get; }

    public ICommand RefreshCommand { get; }

    public ICommand ShareManageCommand { get; }
}

发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.GameAccount\UI\Views\Controls\AccountItems.axaml.cs
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.GameList\Plugins\Plugin.cs
/BD.WTTS.Client.Plugins.GameList/UI/Assets/game.ico";

    public override IEnumerable<MenuTabItemViewModel>? GetMenuTabItems()
    {
        yield return new MenuTabItemViewModel(this, nameof(Strings.GameList))
        {
            PageType = typeof(MainFramePage),
            IsResourceGet = true,
            IconKey = Icon,
        };
    }

    public override async ValueTask OnCommandRun(params string[] commandParams)
    {
        if (commandParams.Length == 2)
        {
            var id = Convert.ToInt32(commandParams[0]);
            var action = commandParams[1];

            switch (action)
            {
                case "achievement":
                    App.InitializeMainWindow += (s) =>
                    {
                        return new AchievementWindow(id);
                    };
                    break;
                case "cloudmanager":
                    App.InitializeMainWindow += (s) =>
                    {
                        return new CloudArchiveWindow(id);
                    };
                    break;
            }
        }
        await ValueTask.CompletedTask;
    }

    public override void ConfigureDemandServices(IServiceCollection services, Startup startup)
    {
    }

    public override void ConfigureRequiredServices(IServiceCollection services, Startup startup)
    {
        services.AddSingleton<IPartialGameLibrarySettings>(s =>
            s.GetRequiredService<IOptionsMonitor<GameLibrarySettings_>>().CurrentValue);
    }

    public override void OnAddAutoMapper(IMapperConfigurationExpression cfg)
    {

    }

    public override IEnumerable<(Action<IServiceCollection>? @delegate, bool isInvalid, string name)>? GetConfiguration(bool directoryExists)
    {
        yield return GetConfiguration<GameLibrarySettings_>(directoryExists);
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.GameList\Properties\Resources.Designer.cs
/ </auto-generated>

/ </summary>
    
/ (以 /str 作为命令选项)，或重新生成 VS 项目。
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        
/ </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("BD.WTTS.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        
/ </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        
/ </summary>
        internal static byte[] defaultappimage {
            get {
                object obj = ResourceManager.GetObject("defaultappimage", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        
/ </summary>
        internal static byte[] game {
            get {
                object obj = ResourceManager.GetObject("game", resourceCulture);
                return ((byte[])(obj));
            }
        }
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.GameList\Settings\GameLibrarySettings.cs
/ </auto-generated>

/ </summary>
    [MPKey(0), MP2Key(0), JsonPropertyOrder(0)]
    public bool GameInstalledFilter { get; set; } = IGameLibrarySettings.DefaultGameInstalledFilter;

    
/ </summary>
    [MPKey(1), MP2Key(1), JsonPropertyOrder(1)]
    public GridLayoutType GameLibraryLayoutType { get; set; } = IGameLibrarySettings.DefaultGameLibraryLayoutType;

    
/ </summary>
    [MPKey(2), MP2Key(2), JsonPropertyOrder(2)]
    public bool GameCloudArchiveFilter { get; set; } = IGameLibrarySettings.DefaultGameCloudArchiveFilter;

    
/ </summary>
    [MPKey(3), MP2Key(3), JsonPropertyOrder(3)]
    public List<SteamAppType>? GameTypeFiltres { get; set; } = IGameLibrarySettings.DefaultGameTypeFiltres;

    
/ </summary>
    [MPKey(4), MP2Key(4), JsonPropertyOrder(4)]
    public Dictionary<uint, string?>? HideGameList { get; set; } = IGameLibrarySettings.DefaultHideGameList;

    
/ </summary>
    [MPKey(5), MP2Key(5), JsonPropertyOrder(5)]
    public Dictionary<uint, string?>? AFKAppList { get; set; } = IGameLibrarySettings.DefaultAFKAppList;

    
/ </summary>
    [MPKey(6), MP2Key(6), JsonPropertyOrder(6)]
    public bool IsAutoAFKApps { get; set; } = IGameLibrarySettings.DefaultIsAutoAFKApps;

}

public static partial class GameLibrarySettings
{
    
/ </summary>
    public static SettingsStructProperty<bool, GameLibrarySettings_> GameInstalledFilter { get; }
        = new(DefaultGameInstalledFilter);

    
/ </summary>
    public static SettingsStructProperty<GridLayoutType, GameLibrarySettings_> GameLibraryLayoutType { get; }
        = new(DefaultGameLibraryLayoutType);

    
/ </summary>
    public static SettingsStructProperty<bool, GameLibrarySettings_> GameCloudArchiveFilter { get; }
        = new(DefaultGameCloudArchiveFilter);

    
/ </summary>
    public static SettingsProperty<SteamAppType, List<SteamAppType>, GameLibrarySettings_> GameTypeFiltres { get; }
        = new(DefaultGameTypeFiltres);

    
/ </summary>
    public static SettingsProperty<uint, string?, Dictionary<uint, string?>, GameLibrarySettings_> HideGameList { get; }
        = new(DefaultHideGameList);

    
/ </summary>
    public static SettingsProperty<uint, string?, Dictionary<uint, string?>, GameLibrarySettings_> AFKAppList { get; }
        = new(DefaultAFKAppList);

    
/ </summary>
    public static SettingsStructProperty<bool, GameLibrarySettings_> IsAutoAFKApps { get; }
        = new(DefaultIsAutoAFKApps);

}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.GameList\Settings\Abstractions\IGameLibrarySettings.cs
/ </auto-generated>

/ </summary>
    bool GameInstalledFilter { get; set; }

    
/ </summary>
    GridLayoutType GameLibraryLayoutType { get; set; }

    
/ </summary>
    bool GameCloudArchiveFilter { get; set; }

    
/ </summary>
    List<SteamAppType>? GameTypeFiltres { get; set; }

    
/ </summary>
    Dictionary<uint, string?>? HideGameList { get; set; }

    
/ </summary>
    Dictionary<uint, string?>? AFKAppList { get; set; }

    
/ </summary>
    bool IsAutoAFKApps { get; set; }

    
/ </summary>
    const bool DefaultGameInstalledFilter = false;

    
/ </summary>
    const GridLayoutType DefaultGameLibraryLayoutType = GridLayoutType.Grid;

    
/ </summary>
    const bool DefaultGameCloudArchiveFilter = false;

    
/ </summary>
    static readonly List<SteamAppType> DefaultGameTypeFiltres = new List<SteamAppType> { SteamAppType.Game, SteamAppType.Application, SteamAppType.Demo, SteamAppType.Beta };

    
/ </summary>
    static readonly Dictionary<uint, string?> DefaultHideGameList = new();

    
/ </summary>
    static readonly Dictionary<uint, string?> DefaultAFKAppList = new();

    
/ </summary>
    const bool DefaultIsAutoAFKApps = true;

}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.GameList\UI\ViewModels\Windows\AchievementAppPageViewModel.cs
/ </summary>
    void EnforceClose()
    {
        Process.GetCurrentProcess().Kill();
    }

    bool LoadUserGameStatsSchema()
    {
        var path = ISteamService.Instance.SteamDirPath;
        if (string.IsNullOrWhiteSpace(path)) return false;
        path = Path.Combine(path, "appcache");
        path = Path.Combine(path, "stats");
        path = Path.Combine(path, string.Format(
            CultureInfo.InvariantCulture,
            "UserGameStatsSchema_{0}.bin",
            AppId));

        if (File.Exists(path) == false)
        {
            return false;
        }

        var kv = KeyValue.LoadAsBinary(path);

        if (kv == null)
        {
            return false;
        }

        var currentLanguage = ResourceService.GetCurrentCultureSteamLanguageName();
        var stats = kv[AppId.ToString(CultureInfo.InvariantCulture)]["stats"];
        if (stats.Valid == false ||
            stats.Children == null)
        {
            return false;
        }

        foreach (var stat in stats.Children)
        {
            if (stat.Valid == false)
            {
                continue;
            }

            var rawType = stat["type_int"].Valid
                              ? stat["type_int"].AsInteger(0)
                              : stat["type"].AsInteger(0);
            var type = (UserStatType)rawType;
            switch (type)
            {
                case UserStatType.Invalid:
                    {
                        break;
                    }

                case UserStatType.Integer:
                    {
                        var id = stat["name"].AsString("");
                        string name = GetLocalizedString(stat["display"]["name"], currentLanguage, id!);

                        _StatisticsSourceList.Add(new IntStatInfo()
                        {
                            Id = stat["name"].AsString(""),
                            DisplayName = name,
                            MinValue = stat["min"].AsInteger(int.MinValue),
                            MaxValue = stat["max"].AsInteger(int.MaxValue),
                            MaxChange = stat["maxchange"].AsInteger(0),
                            IncrementOnly = stat["incrementonly"].AsBoolean(false),
                            DefaultValue = stat["default"].AsInteger(0),
                            Permission = stat["permission"].AsInteger(0),
                        });
                        break;
                    }

                case UserStatType.Float:
                case UserStatType.AverageRate:
                    {
                        var id = stat["name"].AsString("");
                        string name = GetLocalizedString(stat["display"]["name"], currentLanguage, id!);

                        _StatisticsSourceList.Add(new FloatStatInfo()
                        {
                            Id = stat["name"].AsString(""),
                            DisplayName = name,
                            MinValue = stat["min"].AsFloat(float.MinValue),
                            MaxValue = stat["max"].AsFloat(float.MaxValue),
                            MaxChange = stat["maxchange"].AsFloat(0.0f),
                            IncrementOnly = stat["incrementonly"].AsBoolean(false),
                            DefaultValue = stat["default"].AsFloat(0.0f),
                            Permission = stat["permission"].AsInteger(0),
                        });
                        break;
                    }

                case UserStatType.Achievements:
                case UserStatType.GroupAchievements:
                    {
                        if (stat.Children != null)
                        {
                            foreach (var bits in stat.Children.Where(
                                b => string.Compare(b.Name, "bits", StringComparison.InvariantCultureIgnoreCase) == 0))
                            {
                                if (bits.Valid == false ||
                                    bits.Children == null)
                                {
                                    continue;
                                }

                                foreach (var bit in bits.Children)
                                {
                                    string id = bit["name"].AsString("");
                                    string name = GetLocalizedString(bit["display"]["name"], currentLanguage, id!);
                                    string desc = GetLocalizedString(bit["display"]["desc"], currentLanguage, "");

                                    _AchievementsSourceList.Add(new AchievementInfo()
                                    {
                                        AppId = AppId,
                                        Id = id,
                                        Name = name,
                                        Description = desc,
                                        IconNormal = bit["display"]["icon"].AsString(""),
                                        IconLocked = bit["display"]["icon_gray"].AsString(""),
                                        IsHidden = bit["display"]["hidden"].AsBoolean(false),
                                        Permission = bit["permission"].AsInteger(0),
                                    });
                                }
                            }
                        }

                        break;
                    }

                default:
                    {
                        throw new InvalidOperationException("invalid stat type");
                    }
            }
        }

        return true;
    }

    static string GetLocalizedString(KeyValue kv, string language, string defaultValue)
    {
        var name = kv[language].AsString("");
        if (string.IsNullOrEmpty(name) == false)
        {
            return name;
        }

        language = ISteamworksLocalApiService.Instance.GetCurrentGameLanguage();

        name = kv[language].AsString("");
        if (string.IsNullOrEmpty(name) == false)
        {
            return name;
        }

        if (language != "english")
        {
            name = kv["english"].AsString("");
            if (string.IsNullOrEmpty(name) == false)
            {
                return name;
            }
        }

        name = kv.AsString("");
        if (string.IsNullOrEmpty(name) == false)
        {
            return name;
        }

        return defaultValue;
    }

    void GetAchievements()
    {
        var list = new List<AchievementInfo>();
        foreach (var def in _AchievementsSourceList.Items)
        {
            if (string.IsNullOrEmpty(def.Id) == true)
            {
                continue;
            }

            if (ISteamworksLocalApiService.Instance.GetAchievementAndUnlockTime(def.Id, out bool isAchieved, out var unlockTime) == false)
            {
                continue;
            }

            
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.GameList\UI\ViewModels\Windows\CloudArchiveAppPageViewModel.cs
/ToastService.Current.Set(Strings.Achievement_LoadData);

        RefreshList();
    }

    public void RefreshList()
    {
        if (!IsLoading)
        {
            IsLoading = true;
            var results = ISteamworksLocalApiService.Instance.GetCloudArchiveFiles();
            _CloudArchivewSourceList.Clear();
            if (results.Any_Nullable())
                _CloudArchivewSourceList.AddRange(results);
            IsLoading = false;
        }
        _CloudArchivewSourceList.Items.Sum(x => x.Size);
        ISteamworksLocalApiService.Instance.GetCloudArchiveQuota(out var totalBytes, out var availBytes);
        TotalQutoa = (int)(totalBytes / 1024 / 1024);
        UsedQutoa = (int)(_CloudArchivewSourceList.Items.Sum(x => x.Size) / 1024 / 1024);
    }

    public async void ClearAllFiles()
    {
        var result = await MessageBox.ShowAsync(Strings.GameList_CloudArchiveDeleteAllTip, Title, MessageBox.Button.OKCancel);
        if (result.IsOK())
        {
            foreach (var file in _CloudArchivewSourceList.Items)
            {
                file.Delete();
            }
            RefreshList();
        }
    }

    public async void UploadFile()
    {
        var result = await FilePicker2.PickMultipleAsync(new PickOptions
        {
            PickerTitle = "",
        });

        if (result != null)
        {
            foreach (var f in result)
            {
                var file = new SteamRemoteFile(f.FileName.ToLowerInvariant());

                try
                {
                    byte[] data = File.ReadAllBytes(f.FullPath);
                    if (!file.WriteAllBytes(data))
                    {
                        throw new IOException("Upload File Write Failed");
                    }
                    Toast.Show(ToastIcon.Success, Strings.UploadSuccess);
                }
                catch (IOException)
                {
                    Toast.Show(ToastIcon.Error, Strings.UploadFailed);
                }
            }
        }

        RefreshList();
    }

    void EnforceClose()
    {
        Process.GetCurrentProcess().Kill();
    }
}

发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.GameTools\Extensions\HandleWindowExtensions.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.GameTools\Plugins\Plugin.cs
/BD.WTTS.Client.Plugins.GameTools/UI/Assets/toolbox.ico";

    public override IEnumerable<MenuTabItemViewModel>? GetMenuTabItems()
    {
        yield return new MenuTabItemViewModel(this, nameof(Strings.GameRelated))
        {
            PageType = typeof(GameToolsPage),
            IsResourceGet = true,
            IconKey = Icon,
        };
    }

    public override void ConfigureDemandServices(IServiceCollection services, Startup startup)
    {
    }

    public override void ConfigureRequiredServices(IServiceCollection services, Startup startup)
    {
    }

    public override void OnAddAutoMapper(IMapperConfigurationExpression cfg)
    {

    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.GameTools\Properties\Resources.Designer.cs
/ </auto-generated>

/ </summary>
    
/ (以 /str 作为命令选项)，或重新生成 VS 项目。
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        
/ </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("BD.WTTS.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        
/ </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        
/ </summary>
        internal static byte[] toolbox {
            get {
                object obj = ResourceManager.GetObject("toolbox", resourceCulture);
                return ((byte[])(obj));
            }
        }
    }
}

发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.GameTools\UI\ViewModels\BorderlessGamePageViewModel.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.GameTools\UI\ViewModels\CsgoVacRepairPageViewModel.cs
/I "Steam.exe"
                if errorlevel 1 goto closedstatus
                if not errorlevel 1 goto killsteam
                
                :killsteam
                taskkill /F /IM Steam.exe
                goto steamrepair
                
                :closedstatus
                echo Info - Not Started
                goto steamrepair
                
                :enableservice
                sc config Netman start= AUTO
                sc start Netman
                sc config RasMan start= AUTO
                sc start RasMan
                sc config TapiSrv start= AUTO
                sc start TapiSrv
                sc config MpsSvc start= AUTO
                sc start MpsSvc
                netsh advfirewall set allprofiles state on
                goto steam
                
                :steamrepair
                echo Info - ※^>^>^> 执行修复启动器服务项
                cd /d %1
                steamservice /install
                ping -n 2 127.0.0.1>nul
                echo.
                steamservice /repair
                ping -n 2 127.0.0.1>nul
                echo Info - ※ 恢复DEP默认启动设置
                bcdedit /deletevalue nointegritychecks
                bcdedit /deletevalue loadoptions
                bcdedit /debug off
                bcdedit /deletevalue nx
                echo Info - ※^>^>^> 重启 Steam
                cd /d ..
                start /high steam
                ping -n 2 127.0.0.1>nul
                sc config "Steam Client Service" start= AUTO
                sc start "Steam Client Service"
                echo Info - ※ 执行完毕
                exit
                """u8);
        stream.Flush();
        stream.SetLength(stream.Position);
    }

    void OutHandle(string? msg)
    {
        if (!string.IsNullOrEmpty(msg))
        {
            OutputString += msg + Environment.NewLine;

            if (msg.Contains("Add firewall exception failed for steamservice.exe", StringComparison.OrdinalIgnoreCase))
            {
                OutputString += "info - ※ 修复 Steam Services 失败\n";
                OutputString += "info - ※ 请检查您的防火墙设置(关闭 \"不允许例外\" 选项)再次尝试\n";
            }
        }
    }

#endif
}

发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Plugins.GameTools\UI\ViewModels\CsgoVacRepairPageViewModel.cs
WINDOWS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.SteamIdleCard\Enums\IdleRule.cs
/ </summary>
public enum IdleRule : byte
{
    
/ </summary>
    [Description("快速掉卡模式（推荐）")]
    FastMode = 0,

    
/ </summary>
    [Description("按顺序运行")]
    OnlyOneGame = 1,

    
/ </summary>
    [Description("先挂卡已满（游戏最小运行时间）的游戏，然后再并行挂时长")]
    OneThenMany = 2,

    
/ </summary>
    [Description("先并行挂时长满（游戏最小运行时间）后再挂卡")]
    ManyThenOne = 3,
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.SteamIdleCard\Enums\IdleSequentital.cs
/ </summary>
public enum IdleSequentital : byte
{
    
/ </summary>
    [Description("默认（按字母顺序）")]
    Default = 0,

    
/ </summary>
    [Description("按卡片数量最少优先")]
    LeastCards = 1,

    
/ </summary>
    [Description("按卡片数量最多优先")]
    Mostcards = 2,

    
/ </summary>
    [Description("按卡片价值最高优先")]
    Mostvalue = 3,

}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.SteamIdleCard\Properties\Resources.Designer.cs
/ </auto-generated>

/ </summary>
    
/ (以 /str 作为命令选项)，或重新生成 VS 项目。
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        
/ </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("BD.WTTS.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        
/ </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        
/ </summary>
        internal static byte[] card {
            get {
                object obj = ResourceManager.GetObject("card", resourceCulture);
                return ((byte[])(obj));
            }
        }
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.SteamIdleCard\Settings\SteamIdleSettings.cs
/ </auto-generated>

/ </summary>
    [MPKey(0), MP2Key(0), JsonPropertyOrder(0)]
    public TimeSpan IdleTime { get; set; } = ISteamIdleSettings.DefaultIdleTime;

    
/ </summary>
    [MPKey(1), MP2Key(1), JsonPropertyOrder(1)]
    public IdleRule IdleRule { get; set; } = ISteamIdleSettings.DefaultIdleRule;

    
/ </summary>
    [MPKey(2), MP2Key(2), JsonPropertyOrder(2)]
    public IdleSequentital IdleSequentital { get; set; } = ISteamIdleSettings.DefaultIdleSequentital;

    
/ </summary>
    [MPKey(3), MP2Key(3), JsonPropertyOrder(3)]
    public int MaxIdleCount { get; set; } = ISteamIdleSettings.DefaultMaxIdleCount;

    
/ </summary>
    [MPKey(4), MP2Key(4), JsonPropertyOrder(4)]
    public double MinRunTime { get; set; } = ISteamIdleSettings.DefaultMinRunTime;

    
/ </summary>
    [MPKey(5), MP2Key(5), JsonPropertyOrder(5)]
    public double SwitchTime { get; set; } = ISteamIdleSettings.DefaultSwitchTime;

    
/ </summary>
    [MPKey(6), MP2Key(6), JsonPropertyOrder(6)]
    public double RefreshBadgesTime { get; set; } = ISteamIdleSettings.DefaultRefreshBadgesTime;

}

public static partial class SteamIdleSettings
{
    
/ </summary>
    public static SettingsStructProperty<TimeSpan, SteamIdleSettings_> IdleTime { get; }
        = new(DefaultIdleTime);

    
/ </summary>
    public static SettingsStructProperty<IdleRule, SteamIdleSettings_> IdleRule { get; }
        = new(DefaultIdleRule);

    
/ </summary>
    public static SettingsStructProperty<IdleSequentital, SteamIdleSettings_> IdleSequentital { get; }
        = new(DefaultIdleSequentital);

    
/ </summary>
    public static SettingsStructProperty<int, SteamIdleSettings_> MaxIdleCount { get; }
        = new(DefaultMaxIdleCount);

    
/ </summary>
    public static SettingsStructProperty<double, SteamIdleSettings_> MinRunTime { get; }
        = new(DefaultMinRunTime);

    
/ </summary>
    public static SettingsStructProperty<double, SteamIdleSettings_> SwitchTime { get; }
        = new(DefaultSwitchTime);

    
/ </summary>
    public static SettingsStructProperty<double, SteamIdleSettings_> RefreshBadgesTime { get; }
        = new(DefaultRefreshBadgesTime);

}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.SteamIdleCard\Settings\Abstractions\ISteamIdleSettings.cs
/ </auto-generated>

/ </summary>
    TimeSpan IdleTime { get; set; }

    
/ </summary>
    IdleRule IdleRule { get; set; }

    
/ </summary>
    IdleSequentital IdleSequentital { get; set; }

    
/ </summary>
    int MaxIdleCount { get; set; }

    
/ </summary>
    double MinRunTime { get; set; }

    
/ </summary>
    double SwitchTime { get; set; }

    
/ </summary>
    double RefreshBadgesTime { get; set; }

    
/ </summary>
    static readonly TimeSpan DefaultIdleTime = TimeSpan.FromMinutes(6);

    
/ </summary>
    static readonly IdleRule DefaultIdleRule = IdleRule.FastMode;

    
/ </summary>
    static readonly IdleSequentital DefaultIdleSequentital = IdleSequentital.Default;

    
/ </summary>
    static readonly int DefaultMaxIdleCount = 30;

    
/ </summary>
    static readonly double DefaultMinRunTime = 2;

    
/ </summary>
    static readonly double DefaultSwitchTime = 5000;

    
/ </summary>
    static readonly double DefaultRefreshBadgesTime = 6;

}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.SteamIdleCard\UI\ViewModels\IdleCardPageViewModel.cs
/ </summary>
    public async Task IdleRunStartOrStop_Click()
    {
        if (!SteamTool.IsRunningSteamProcess)
        {
            Toast.Show(ToastIcon.Warning, Strings.SteamNotRuning);
            
/ </summary>
    public async Task ManualRunNext()
    {
        using (await asyncLock.LockAsync())
        {
            RunNextIdle();
        }
    }

    
/ </summary>
    
/ <param name="idleApp"></param>
    
/ <returns></returns>
    public async Task PriorityRunIdleGame(IdleApp idleApp)
    {
        using (await asyncLock.LockAsync())
        {
            StopIdle();
            PauseAutoNext(true);
            StartSoloIdle(idleApp);
            CurrentIdleIndex = IdleGameList.IndexOf(idleApp);
            ChangeRunTxt();
        }
    }

    #region PrivateFields

    
/ </summary>
    private int CurrentIdleIndex = 0;

    
/ </summary>
    private bool IsAutoNextPaused = false;

    
/ </summary>
    private CancellationTokenSource AutoNextCancellationTokenSource = new();

    
/ </summary>
    private CancellationTokenSource DropCardCancellationTokenSource = new();

    
/ </summary>
    private bool IsReloaded;

    #endregion

    #region Private Method

    private async Task<bool> LoginSteam()
    {
        var seesion = await Ioc.Get<ISteamSessionService>().LoadSession();

        if (seesion != null && ulong.TryParse(seesion.SteamId, out var steamid))
        {
            SteamLoginState.SteamId = steamid;
            SteamLoginState.AccessToken = seesion.AccessToken;
            SteamLoginState.RefreshToken = seesion.RefreshToken;
            SteamLoginState.Cookies = seesion.CookieContainer.GetAllCookies();

            
/ </summary>
    
/ <returns></returns>
    private async Task IdleRuleChange()
    {
        if (SteamIdleSettings.IdleRule.Value == IdleRule.FastMode)
            ShowSettingsOpenAutoNextWarning();
        if (RunState)
        {
            using (await asyncLock.LockAsync())
            {
                StopIdle();
                PauseAutoNext(true);
                ResetCurrentIdle();
                StartIdle();
                ChangeRunTxt();
            }
        }
    }

    
/ </summary>
    
/ <returns></returns>
    private async Task IdleSequentitalChance()
    {
        if (RunState)
        {
            using (await asyncLock.LockAsync())
            {
                StopIdle();
                ResetCurrentIdle();
                SteamAppsSort();
                StartIdle();
                ChangeRunTxt();
            }
        }

    }

    
/ </summary>
    
/ <returns></returns>
    private async Task<bool> LoadBadges()
    {
        try
        {
            var isTokenAccess = Ioc.Get<ISteamAccountService>().IsAccessTokenValid(SteamLoginState.AccessToken!);
            if (isTokenAccess)
            {
                await RunLoadBadges();
            }
            else
            {
                var new_accessToken = await Ioc.Get<ISteamAccountService>().RefreshAccessToken(SteamLoginState.SteamId, SteamLoginState.RefreshToken!);
                if (new_accessToken is not null) 
/ </summary>
    
/ <returns></returns>
    private bool SteamAppsSort()
    {
        try
        {
            var badges = Badges.Where(w => w.CardsRemaining != 0);
            var apps = (SteamIdleSettings.IdleSequentital.Value switch
            {
                IdleSequentital.LeastCards => badges.OrderBy(o => o.CardsRemaining).Select(s => new IdleApp(s)),
                IdleSequentital.Mostcards => badges.OrderByDescending(o => o.CardsRemaining).Select(s => new IdleApp(s)),
                IdleSequentital.Mostvalue => badges.OrderByDescending(o => o.RegularAvgPrice).Select(s => new IdleApp(s)),
                _ => badges.Select(s => new IdleApp(s)),
            }).ToImmutableList();
            Dispatcher.UIThread.Invoke(() =>
            {
                IdleGameList.Clear();
                EnumerableExtensions.AddRange(IdleGameList, apps);
            });
            return true;
        }
        catch (Exception ex)
        {
            ex.LogAndShowT();
            return false;
        }
    }

    private async Task<bool> ReadyToGoIdle(bool isFirstStart = false)
    {
        ResetCurrentIdle();
        if (await LoadBadges() && SteamAppsSort())
        {
            if (isFirstStart)
                DroppedCardsCount = TotalCardsRemaining;
            StartIdle();
            ChangeRunTxt();
            return true;
        }
        return false;
    }

    
/ </summary>
    private void StartIdle(bool isNext = false)
    {
        IdleApp idleApp;

        if (!IdleGameList.Any())
        {
            IdleComplete();
            return;
        }

        if (SteamIdleSettings.IdleRule.Value == IdleRule.FastMode)
        {
            var multi = IdleGameList.Where(z => z.Badge.HoursPlayed >= SteamIdleSettings.MinRunTime.Value).ToList();

            var isLastSingle = multi.Count == 1 && IdleGameList.Count == 1; 
/ </summary>
    private void RunNextIdle()
    {
        if (RunState)
        {
            StopIdle();
            StartIdle(true);
        }
    }

    
/ </summary>
    
/ <param name="item"></param>
    private void StartSoloIdle(IdleApp item)
    {
        CurrentIdle = item;
        SteamConnectService.Current.RuningSteamApps.TryGetValue(item.AppId, out var runState);
        if (runState == null)
        {
            item.App.StartSteamAppProcess();
            SteamConnectService.Current.RuningSteamApps.TryAdd(item.AppId, item.App);
        }
        else
        {
            if (runState.Process == null || !runState.Process.HasExited)
            {
                runState.StartSteamAppProcess();
            }
            else
            {
                item.App.Process = runState.Process;
            }
        }
    }

    private void StartMultipleIdle()
    {
        foreach (var item in IdleGameList)
        {
            if (item.Badge.HoursPlayed >= SteamIdleSettings.MinRunTime.Value)
                StopSoloIdle(item.App);

            if (item.Badge.HoursPlayed < SteamIdleSettings.MinRunTime.Value && IdleGameList.Count(x => x.App.Process != null) < SteamIdleSettings.MaxIdleCount)
                StartSoloIdle(item);
        }
        ResetCurrentIdle();

        if (!IdleGameList.Any(x => x.App.Process != null))
            StartIdle();

    }

    
/ </summary>
    private void StopIdle()
    {
        foreach (var item in IdleGameList)
        {
            SteamConnectService.Current.RuningSteamApps.TryGetValue(item.AppId, out var runState);
            if (runState != null)
            {
                runState.Process?.KillEntireProcessTree();
                SteamConnectService.Current.RuningSteamApps.TryRemove(item.AppId, out var remove);
                item.App.Process = null;
            }
            else
            {
                item.App.Process = null;
                SteamConnectService.Current.RuningSteamApps.TryAdd(item.AppId, item.App);
            }
        }
    }

    private void StopSoloIdle(SteamApp item)
    {
        SteamConnectService.Current.RuningSteamApps.TryGetValue(item.AppId, out var runState);
        if (runState != null)
        {
            runState.Process?.KillEntireProcessTree();
            SteamConnectService.Current.RuningSteamApps.TryRemove(item.AppId, out var remove);
            item.Process = null;
        }
        else
        {
            item.Process = null;
            SteamConnectService.Current.RuningSteamApps.TryAdd(item.AppId, item);
        }
    }

    #region AutoNext

    
/ </summary>
    
/ <param name="b"></param>
    private void PauseAutoNext(bool b)
    {
        if (b && !IsAutoNextPaused)
        {
            IsAutoNextPaused = true;
        }
        else if (!b && IsAutoNextPaused)
        {
            IsAutoNextPaused = false;
        }
    }

    
/ </summary>
    
/ <param name="b"></param>
    private void RunOrStopAutoNext(bool b)
    {
        if (b)
        {
            if (RunState)
            {
                if (AutoNextCancellationTokenSource.Token.IsCancellationRequested)
                    AutoNextCancellationTokenSource = new();

                Task2.InBackground(() =>
                {
                    while (!AutoNextCancellationTokenSource.Token.IsCancellationRequested)
                    {
                        try
                        {
                            Task.Delay(TimeSpan.FromMilliseconds(100), AutoNextCancellationTokenSource.Token).Wait();
                            IdleTime += TimeSpan.FromMilliseconds(100);
                            AutoNextTask().Wait();
                        }
                        catch (AggregateException ae)
                        {
                            if (!ae.InnerExceptions.Any(x => x is TaskCanceledException || x is InvalidOperationException))
                                ae.LogAndShowT();
                        }
                    }
                }, true);
            }
            else
                Toast.Show(ToastIcon.Info, Strings.Idle_PleaseStartIdle);
        }
        else
        {
            if (IsAutoNextPaused)
                IsAutoNextPaused = false;

            AutoNextCancellationTokenSource.Cancel();
        }
    }

    
/ </summary>
    private async Task AutoNextTask()
    {
        if (IdleTime.TotalMilliseconds != 0 && IdleTime.TotalMilliseconds % SteamIdleSettings.SwitchTime.Value == 0)
        {
            using (await asyncLock.LockAsync())
            {
                if (IsAutoNextPaused)
                {
                    return;
                }
                if (IdleGameList.Sum(s => s.Badge.CardsRemaining) == 0) 
/ </summary>
    private void IdleComplete()
    {
        RunState = false;
        var message = Strings.Idle_Complete.Format(DropCardsCount, IdleTime.TotalHours.ToInt32());
        Toast.Show(ToastIcon.Success, message);
        INotificationService.Instance.Notify(message, NotificationType.Message);
    }

    private async Task RefreshAccessTokenAsync(string new_accessToken)
    {
        SteamLoginState.AccessToken = new_accessToken;
        SteamSession session = new SteamSession()
        {
            SteamId = SteamLoginState.SteamId.ToString(),
            AccessToken = SteamLoginState.AccessToken,
            RefreshToken = SteamLoginState.RefreshToken
        };
        session.GenerateSetCookie();
        var sessionService = Ioc.Get<ISteamSessionService>();
        sessionService.AddOrSetSeesion(session);

        if (LoginViewModel is null || LoginViewModel.RemenberLogin)
            await sessionService.SaveSession(session);
    }
    #endregion

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void ShowSettingsOpenAutoNextWarning()
    {
        if (Ioc.Get_Nullable<IToastIntercept>() is StartupToastIntercept intercept
            && !intercept.IsStartuped)
        {
            return;
        }
        Toast.Show(ToastIcon.Info, Strings.SteamIdle_OpenAutoNextWarning);
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.SteamIdleCard\UI\ViewModels\IdleCardPageViewModel.props.cs
/ </summary>
    public ICommand PriorityRunIdle { get; }

    public ICommand LoginSteamCommand { get; }

    public ICommand IdleRunStartOrStop { get; }

    public ICommand IdleManualRunNext { get; }

    
/ </summary>
    [Reactive]
    public UserIdleInfo? UserIdleInfo { get; set; }

    
/ </summary>
    [Reactive]
    public ObservableCollection<IdleApp> IdleGameList { get; set; } = new();

    
/ </summary>
    [Reactive]
    public ObservableCollection<Badge> Badges { get; set; } = new();

    [Reactive]
    public TimeSpan IdleTime { get; set; }

    [Reactive]
    public int DroppedCardsCount { get; set; }

    [Reactive]
    public int TotalCardsRemaining { get; set; }

    [Reactive]
    public int ViewState { get; set; } = 1;

    [Reactive]
    public IdleSteamLoginPageViewModel? LoginViewModel { get; set; }

    public int DropCardsCount => Math.Max(DroppedCardsCount - TotalCardsRemaining, 0);

    [Reactive]
    public decimal TotalCardsAvgPrice { get; set; }

    
/ </summary>
    [Reactive]
    public IdleApp? CurrentIdle { get; set; }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.SteamIdleCard\UI\ViewModels\IdleSteamLoginPageViewModel.cs
/", "steamcommunity.com"));
                    cookieContainer.Add(new Cookie("sessionid", SeesionId, "/", "steamcommunity.com"));
                    cookieContainer.Add(new Cookie("steamLoginSecure", SteamLoginSecure, "/", "steampowered.com"));
                    cookieContainer.Add(new Cookie("sessionid", SeesionId, "/", "steampowered.com"));
                    SteamSession session = new SteamSession()
                    {
                        SteamId = steamid.ToString(),
                        AccessToken = SteamLoginState.AccessToken,
                        RefreshToken = string.Empty,
                        CookieContainer = cookieContainer,
                    };

                    SteamSession.AddOrSetSeesion(session);

                    if (RemenberLogin)
                    {
                        await SteamSession.SaveSession(session);
                    }

                    SteamLoginState.Success = true;
                    Toast.Show(ToastIcon.Success, Strings.Success_.Format(Strings.User_Login));
                    IsLoading = false;
                    Close?.Invoke(false);
                }
            }
            IsLoading = false;
        }
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.SteamIdleCard\UI\ViewModels\IdleSteamLoginPageViewModel.props.cs
/ </summary>
    [Reactive]
    public string? UserNameText { get; set; }

    
/ </summary>
    [Reactive]
    public string? PasswordText { get; set; }

    
/ </summary>
    [Reactive]
    public string? TwofactorCode { get; set; }

    
/ </summary>
    [Reactive]
    public bool Requires2FA { get; set; }

    
/ </summary>
    [Reactive]
    public bool RequiresEmailAuth { get; set; }

    
/ </summary>
    [Reactive]
    public bool RemenberLogin { get; set; } = true;

    [Reactive]
    public bool IsLoading { get; set; }

    
/ </summary>
    [Reactive]
    public string? SeesionId { get; set; }

    
/ </summary>
    [Reactive]
    public string? SteamLoginSecure { get; set; }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Plugins.Update\WebEncoders.cs
/github.com/dotnet/aspnetcore/blob/v7.0.5/src/Shared/WebEncoders/WebEncoders.cs


/ </summary>
    
/ <param name="input">The base64url-encoded input to decode.</param>
    
/ <returns>The base64url-decoded form of the input.</returns>
    
/ Throws <see cref="FormatException"/> if the input is malformed.
    
/ </remarks>
    public static byte[] Base64UrlDecode(string input)
    {
        if (input == null)
        {
            throw new ArgumentNullException(nameof(input));
        }

        return Base64UrlDecode(input, offset: 0, count: input.Length);
    }

    
/ </summary>
    
/ <param name="input">A string containing the base64url-encoded input to decode.</param>
    
/ <param name="offset">The position in <paramref name="input"/> at which decoding should begin.</param>
    
/ <param name="count">The number of characters in <paramref name="input"/> to decode.</param>
    
/ <returns>The base64url-decoded form of the input.</returns>
    
/ Throws <see cref="FormatException"/> if the input is malformed.
    
/ </remarks>
    public static byte[] Base64UrlDecode(string input, int offset, int count)
    {
        if (input == null)
        {
            throw new ArgumentNullException(nameof(input));
        }

        
/ Decodes a base64url-encoded <paramref name="input"/> into a <c>byte[]</c>.
    
/ </summary>
    
/ <param name="input">A string containing the base64url-encoded input to decode.</param>
    
/ <param name="offset">The position in <paramref name="input"/> at which decoding should begin.</param>
    
/ Scratch buffer to hold the <see cref="char"/>s to decode. Array must be large enough to hold
    
/ <paramref name="bufferOffset"/> and <paramref name="count"/> characters as well as Base64 padding
    
/ </param>
    
/ The offset into <paramref name="buffer"/> at which to begin writing the <see cref="char"/>s to decode.
    
/ </param>
    
/ <param name="count">The number of characters in <paramref name="input"/> to decode.</param>
    
/ <returns>The base64url-decoded form of the <paramref name="input"/>.</returns>
    
/ Throws <see cref="FormatException"/> if the input is malformed.
    
/ </remarks>
    public static byte[] Base64UrlDecode(string input, int offset, char[] buffer, int bufferOffset, int count)
    {
        if (input == null)
        {
            throw new ArgumentNullException(nameof(input));
        }
        if (buffer == null)
        {
            throw new ArgumentNullException(nameof(buffer));
        }

        
/ Copy input into buffer, fixing up '-' -> '+' and '_' -> '/'.
        var i = bufferOffset;
        for (var j = offset; i - bufferOffset < count; i++, j++)
        {
            var ch = input[j];
            if (ch == '-')
            {
                buffer[i] = '+';
            }
            else if (ch == '_')
            {
                buffer[i] = '/';
            }
            else
            {
                buffer[i] = ch;
            }
        }

        
/ Gets the minimum <c>char[]</c> size required for decoding of <paramref name="count"/> characters
    
/ with the <see cref="Base64UrlDecode(string, int, char[], int, int)"/> method.
    
/ </summary>
    
/ <param name="count">The number of characters to decode.</param>
    
/ The minimum <c>char[]</c> size required for decoding  of <paramref name="count"/> characters.
    
/ </returns>
    public static int GetArraySizeRequiredToDecode(int count)
    {
        if (count < 0)
        {
            throw new ArgumentOutOfRangeException(nameof(count));
        }

        if (count == 0)
        {
            return 0;
        }

        var numPaddingCharsToAdd = GetNumBase64PaddingCharsToAddForDecode(count);

        return checked(count + numPaddingCharsToAdd);
    }

    private static int GetNumBase64PaddingCharsToAddForDecode(int inputLength)
    {
        switch (inputLength % 4)
        {
            case 0:
                return 0;
            case 2:
                return 2;
            case 3:
                return 1;
            default:
                throw new FormatException(
                    string.Format(
                        CultureInfo.CurrentCulture,
                        "Malformed input: {0} is an invalid input length.",
                        inputLength));
        }
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.HostsTest\Program.cs
/learn.microsoft.com/zh-cn/sysinternals/downloads/handle

var fColor = Console.ForegroundColor;
var bColor = Console.BackgroundColor;
try
{
    var isProcessElevated = IsProcessElevated(Process.GetCurrentProcess());
    Console.WriteLine($"当前进程是否为管理员权限：{isProcessElevated}");

    var hostsFilePath = Path.Combine(Environment.SystemDirectory, "drivers", "etc", "hosts");
    Console.WriteLine($"hosts 文件路径：{hostsFilePath}");

    try
    {
        var text = File.ReadAllText(hostsFilePath);
        Console.WriteLine("hosts 文件内容：");
        Console.WriteLine("--------------------------------------------------");
        Console.WriteLine(text);
        Console.WriteLine("--------------------------------------------------");

        File.WriteAllText(hostsFilePath, text);
        Console.ForegroundColor = ConsoleColor.White;
        Console.BackgroundColor = ConsoleColor.DarkGreen;
        Console.WriteLine("OK");
    }
    catch (Exception ex)
    {
        Console.ForegroundColor = ConsoleColor.White;
        Console.BackgroundColor = ConsoleColor.DarkRed;
        Console.WriteLine("错误：");
        Console.WriteLine(ex.ToString());

        
/learn.microsoft.com/zh-cn/sysinternals/downloads/handle
        Console.WriteLine("查找 hosts 文件被哪个进程占用的命令，需要安装工具：");
        Console.WriteLine("https:
/learn.microsoft.com/zh-cn/sysinternals/downloads/handle");
        Console.WriteLine();
        Console.WriteLine(
$"""
handle.exe "{hostsFilePath}" /accepteula
""");
    }
}
finally
{
    Console.ForegroundColor = fColor;
    Console.BackgroundColor = bColor;
    Console.WriteLine("键入回车键后退出此程序：");
    Console.ReadLine();
}


/ </summary>

/ <param name="process"></param>

/ <returns></returns>
[MethodImpl(MethodImplOptions.AggressiveInlining)]
static unsafe bool IsProcessElevated(Process process)
{
    try
    {
        var handle = process.Handle;

        
/github.com/dotnet/runtime/pull/77355/files#diff-1c6f0e5208d48036e96fcc9c0243d93595f3ce16f2d1a50f51ba604d930ca69dR87
        PInvoke.Kernel32.SafeObjectHandle? token = null;
        try
        {
            if (PInvoke.AdvApi32.OpenProcessToken(handle,
                PInvoke.AdvApi32.TokenAccessRights.TOKEN_READ,
                out token))
            {
                TOKEN_ELEVATION elevation = default;
                if (PInvoke.AdvApi32.GetTokenInformation(
                    token,
                    PInvoke.AdvApi32.TOKEN_INFORMATION_CLASS.TokenElevation,
                    &elevation,
                    sizeof(TOKEN_ELEVATION),
                    out _))
                {
                    return elevation.TokenIsElevated != BOOL.FALSE;
                }
            }
        }
        finally
        {
            token?.Dispose();
        }

        var error = Marshal.GetLastPInvokeError();
        throw new Win32Exception(error);

        
/return principal.IsInRole(WindowsBuiltInRole.Administrator);
    }
    catch (Win32Exception ex)
    {
        /* “process.Handle”引发了类型“System.ComponentModel.Win32Exception”的异常
         * Data: {System.Collections.ListDictionaryInternal}
         * ErrorCode: -2147467259
         * HResult: -2147467259
         * HelpLink: null
         * InnerException: null
         * Message: "拒绝访问。"
         * NativeErrorCode: 5
         * Source: "System.Diagnostics.Process"
         */
        if (ex.NativeErrorCode == 5)
            return true;
    }
    return false;
}


/msdn.microsoft.com/en-us/library/windows/desktop/bb530717.aspx
struct TOKEN_ELEVATION
{
    public BOOL TokenIsElevated;
}


/ </summary>

/ </remarks>
enum BOOL : int
{
    FALSE = 0,
    TRUE = 1,
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\Constants.cs
/ <para></para>
    
/ <para></para>
    
/ 可更变名称的值为 <see cref="ThisAssembly.AssemblyTrademark"/>
    
/ </summary>
    const string HARDCODED_APP_NAME = "Steam++";

    interface LinuxPackConstants
    {
        const string TargetName = Constants.HARDCODED_APP_NAME;
        const string PackagePrefix = TargetName;
        const string PackageName = PackagePrefix;
        const string Prefix = "/usr/share/" + PackagePrefix;
        const string Release = "0";
        const bool CreateUser = false;
        const string UserName = Constants.HARDCODED_APP_NAME;
        const bool InstallService = false;
        const string ServiceName = PackagePrefix;
        const string RpmVendor = AssemblyInfo.Company;
        const string Description = AssemblyInfo.Description;
        const string Url = "https:
/dotnetcli.azureedge.net/dotnet";
    const string feed_no_cdn = "https:
/dotnetcli.blob.core.windows.net/dotnet";

    static string GetRuntimeDownloadLink(
        string osname,
        string normalized_architecture,
        bool? no_cdn = null)
    {
        
/learn.microsoft.com/zh-cn/dotnet/core/tools/dotnet-install-script
        
/dot.net/v1/dotnet-install.sh
        
/dot.net/v1/dotnet-install.ps1
        if (!no_cdn.HasValue) no_cdn = !ProjectUtils.IsCI();
        var specific_version = $"{Environment.Version.Major}.{Environment.Version.Minor}.{Environment.Version.Build}";
        var download_link = $"{(no_cdn.Value ? feed_no_cdn : feed)}/aspnetcore/Runtime/{specific_version}/aspnetcore-runtime-{specific_version}-{osname}-{normalized_architecture}.{(osname == "win" ? "zip" : "tar.gz")}";
        return download_link;
    }

    static void CopyDirectory(string sourceDir, string destinationDir, bool recursive) 
/learn.microsoft.com/zh-cn/dotnet/standard/io/how-to-copy-directories
    {
        
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\Commands\ICompressedPackageCommand.cs
/ </summary>
interface ICompressedPackageCommand : ICommand
{
    const string commandName = "compressed";

    static Command ICommand.GetCommand()
    {
        var sevenzip = new Option<bool>("--7z", "Create 7z compressed");
        var zip = new Option<bool>("--zip", "Create Zip compressed");
        var tgz = new Option<bool>("--gz", "Create tgz compressed");
        var zstd = new Option<bool>("--zstd", "Create tar.zst compressed");
        var rids = new Option<string[]>("--rids", "RID is short for runtime identifier");
        var command = new Command(commandName, "Create compressed package")
        {
            sevenzip, zip, tgz, zstd, rids,
        };
        command.SetHandler(Handler, sevenzip, zip, tgz, zstd, rids);
        return command;
    }

    internal static void Handler(bool sevenzip, bool zip, bool tgz, bool zstd, string[] rids)
    {
        var tasks = AppPublishInfo.Instance.
            Where(x => rids.Contains(x.RuntimeIdentifier)).
            Select(x =>
            {
                return GetTasks();
                IEnumerable<ThreadTask> GetTasks()
                {
                    if (sevenzip)
                        yield return InBackground(() =>
                        {
                            GenerateCompressedPackage(x, CloudFileType.SevenZip);
                        });
                    if (tgz)
                        yield return InBackground(() =>
                        {
                            GenerateCompressedPackage(x, CloudFileType.TarGzip);
                        });
                    if (zstd)
                        yield return InBackground(() =>
                        {
                            GenerateCompressedPackage(x, CloudFileType.TarZstd);
                        });
                }
            }).SelectMany(x => x).ToArray();
        ThreadTask.WaitAll(tasks);
        Console.WriteLine($"{commandName} OK");
    }

    static void GenerateCompressedPackage(AppPublishInfo item, CloudFileType type)
    {
        var fileEx = GetFileExByCloudFileType(type);
        var packPath = GetPackPath(item, fileEx);
        Console.WriteLine($"正在生成压缩包：{packPath}");
        IOPath.FileIfExistsItDelete(packPath);

        GetCreatePackByCloudFileType(type)(packPath, item.Files);

        using var fileStream = File.OpenRead(packPath);
        var sha384 = Hashs.String.SHA384(fileStream);
        var sha256 = Hashs.String.SHA256(fileStream);
        AppPublishFileInfo info = new()
        {
            FileEx = fileEx,
            FilePath = packPath,
            Length = fileStream.Length,
            SHA384 = sha384,
            SHA256 = sha256,
        };
        if (item.SingleFile.ContainsKey(type))
            item.SingleFile[type] = info;
        else
            item.SingleFile.Add(type, info);
        Console.WriteLine($"压缩包已生成：{packPath}");
    }

    
/ </summary>
    
/ <param name="compressedType"></param>
    
/ <returns></returns>
    
/ <exception cref="ArgumentOutOfRangeException"></exception>
    static string GetFileExByCloudFileType(CloudFileType cloudFileType) => cloudFileType switch
    {
        CloudFileType.TarGzip => FileEx.TAR_GZ,
        CloudFileType.TarBrotli => FileEx.TAR_BR_LONG,
        CloudFileType.SevenZip => FileEx._7Z,
        CloudFileType.TarZstd => FileEx.TAR_ZST,
        CloudFileType.TarXz => FileEx.TAR_XZ,
        CloudFileType.Json => FileEx.JSON,
        CloudFileType.Dll => ".dll",
        CloudFileType.Xml => ".xml",
        CloudFileType.So => ".so",
        CloudFileType.Dylib => ".dylib",
        CloudFileType.None => "",
        CloudFileType.Js => ".js",
        CloudFileType.Xaml => ".xaml",
        CloudFileType.AXaml => ".axaml",
        CloudFileType.CSharp => ".cs",
        _ => throw new ArgumentOutOfRangeException(nameof(cloudFileType), cloudFileType, null),
    };

    
/ </summary>
    
/ <param name="compressedType"></param>
    
/ <returns></returns>
    
/ <exception cref="ArgumentOutOfRangeException"></exception>
    static Action<string, IEnumerable<AppPublishFileInfo>> GetCreatePackByCloudFileType(CloudFileType cloudFileType) => cloudFileType switch
    {
        CloudFileType.TarGzip => CreateGZipPack,
        CloudFileType.TarBrotli => CreateBrotliPack,
        CloudFileType.SevenZip => CreateSevenZipPack,
        CloudFileType.TarZstd => CreateZstdPack,
        CloudFileType.TarXz => CreateXZPack,
        _ => throw new ArgumentOutOfRangeException(nameof(cloudFileType), cloudFileType, null),
    };

    static void CreateGZipPack(string packPath, IEnumerable<AppPublishFileInfo> files)
    {
        using var fs = File.Create(packPath);
        using var s = new GZipOutputStream(fs);
        s.SetLevel(Deflater.BEST_COMPRESSION);
        using var archive = TarArchive.CreateOutputTarArchive(s,
            TarBuffer.DefaultBlockFactor, EncodingCache.UTF8NoBOM);
        foreach (var file in files)
        {
#if DEBUG
            Console.WriteLine($"正在压缩：{file.FilePath}");
#endif
            var entry = TarEntry.CreateEntryFromFile(file.FilePath);
            entry.Name = file.RelativePath;
            if (Path.DirectorySeparatorChar != IOPath.UnixDirectorySeparatorChar)
                entry.Name = entry.Name.Replace(Path.DirectorySeparatorChar, IOPath.UnixDirectorySeparatorChar);
            archive.WriteEntry(entry, false);
        }
    }

    static void CreateBrotliPack(string packPath, IEnumerable<AppPublishFileInfo> files)
    {
        using var fs = File.Create(packPath);
        using var s = new BrotliStream(fs, NCompressionMode.Compress);
        using var archive = TarArchive.CreateOutputTarArchive(s,
            TarBuffer.DefaultBlockFactor, EncodingCache.UTF8NoBOM);
        foreach (var file in files)
        {
#if DEBUG
            Console.WriteLine($"正在压缩：{file.FilePath}");
#endif
            var entry = TarEntry.CreateEntryFromFile(file.FilePath);
            entry.Name = file.RelativePath;
            if (Path.DirectorySeparatorChar != IOPath.UnixDirectorySeparatorChar)
                entry.Name = entry.Name.Replace(Path.DirectorySeparatorChar, IOPath.UnixDirectorySeparatorChar);
            archive.WriteEntry(entry, false);
        }
    }

    static readonly Lazy<object?> SetSevenZipLibraryPath = new(() =>
    {
        var libPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles), "7-Zip", "7z.dll");
        SevenZipBase.SetLibraryPath(libPath);
        return null;
    });

    static void CreateSevenZipPack(string packPath, IEnumerable<AppPublishFileInfo> files)
    {
        _ = SetSevenZipLibraryPath.Value;
        SevenZipCompressor? compressor = new()
        {
            ArchiveFormat = OutArchiveFormat.SevenZip,
            CompressionLevel = SevenZip.CompressionLevel.Ultra,
            CompressionMethod = CompressionMethod.Lzma2,
            FastCompression = false,
            ScanOnlyWritable = true,
            DirectoryStructure = true,
        };
        compressor.FileCompressionStarted += FileCompressionStarted;
        static void FileCompressionStarted(object? s, FileNameEventArgs e)
        {
#if DEBUG
            Console.WriteLine($"正在压缩：{e.FileName}");
#endif
        }
        var dict = files.ToDictionary(x => x.RelativePath, x => x.FilePath);
        compressor.CompressFileDictionary(dict, packPath);
        compressor.FileCompressionStarted -= FileCompressionStarted;
        compressor = null;
    }

    static void CreateZstdPack(string packPath, IEnumerable<AppPublishFileInfo> files)
    {
        using var fs = File.Create(packPath);
        var maxCompressionLevel = CompressionOptions.MaxCompressionLevel;
        Console.WriteLine($"MaxCompressionLevel: {maxCompressionLevel}");
        using var s = new CompressionStream(fs, new CompressionOptions(maxCompressionLevel));
        using var archive = TarArchive.CreateOutputTarArchive(s,
            TarBuffer.DefaultBlockFactor, EncodingCache.UTF8NoBOM);
        foreach (var file in files)
        {
#if DEBUG
            Console.WriteLine($"正在压缩：{file.FilePath}");
#endif
            var entry = TarEntry.CreateEntryFromFile(file.FilePath);
            entry.Name = file.RelativePath;
            if (Path.DirectorySeparatorChar != IOPath.UnixDirectorySeparatorChar)
                entry.Name = entry.Name.Replace(Path.DirectorySeparatorChar, IOPath.UnixDirectorySeparatorChar);
            archive.WriteEntry(entry, false);
        }
    }

    static void CreateXZPack(string packPath, IEnumerable<AppPublishFileInfo> files)
    {
        using var fs = File.Create(packPath);
        using var s = new XZOutputStream2(fs);
        using var archive = TarArchive.CreateOutputTarArchive(s,
            TarBuffer.DefaultBlockFactor, EncodingCache.UTF8NoBOM);
        foreach (var file in files)
        {
#if DEBUG
            Console.WriteLine($"正在压缩：{file.FilePath}");
#endif
            var entry = TarEntry.CreateEntryFromFile(file.FilePath);
            entry.Name = file.RelativePath;
            if (Path.DirectorySeparatorChar != IOPath.UnixDirectorySeparatorChar)
                entry.Name = entry.Name.Replace(Path.DirectorySeparatorChar, IOPath.UnixDirectorySeparatorChar);
            archive.WriteEntry(entry, false);
        }
    }

    sealed class XZOutputStream2 : XZOutputStream
    {
        public XZOutputStream2(Stream s) : base(s)
        {
        }

        public XZOutputStream2(Stream s, int threads) : base(s, threads)
        {
        }

        public XZOutputStream2(Stream s, int threads, uint preset) : base(s, threads, preset)
        {
        }

        public XZOutputStream2(Stream s, int threads, uint preset, bool leaveOpen) : base(s, threads, preset, leaveOpen)
        {
        }

        public override void Flush()
        {
        }
    }

    static void CreateZipPack(string packPath, IEnumerable<AppPublishFileInfo> files)
    {
        using var archive = ZipFile.Open(packPath, ZipArchiveMode.Create);
        foreach (var file in files)
        {
#if DEBUG
            Console.WriteLine($"正在压缩：{file.FilePath}");
#endif
            var name = file.RelativePath;
            if (Path.DirectorySeparatorChar != IOPath.UnixDirectorySeparatorChar)
                name = name.Replace(Path.DirectorySeparatorChar, IOPath.UnixDirectorySeparatorChar);
            archive.CreateEntryFromFile(file.FilePath, name);
        }
    }
}

发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Tools.Publish\Commands\ICompressedPackageCommand.cs
DEBUG
DEBUG
DEBUG
DEBUG
DEBUG
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\Commands\IDotNetPublishCommand.cs
/ </summary>
interface IDotNetPublishCommand : ICommand
{
    const string commandName = "run";

    const string EntryPointAssemblyName = "Steam++";

    static string releaseTimestamp = DateTimeOffset.Now.ToString("yyMMdd_HHmmssfffffff");

    static string GetPublishFileName(bool debug, string rid, string fileEx = "")
    {
        var value = $"[{(debug ? "Debug" : "Release")}] {EntryPointAssemblyName}_v{AssemblyInfo.InformationalVersion}_{rid.Replace('-', '_')}_{releaseTimestamp}{fileEx}";
        return value;
    }

    static bool GetDefForceSign()
    {
        var machineName = Hashs.String.SHA256(Environment.MachineName, false);
        return machineName switch
        {
            "EACD5C77C0E7160CF8D2A6C21C4F0C1F04CEF40097DB4799127AABB2CF8786B6" or
            "E34AB34336AF93190C550A082960F7610D01DE121897F432D9A5CBC6E326B5AB"
            => true,
            _ => false,
        };
    }

    static Command ICommand.GetCommand()
    {
        var debug = new Option<bool>("--debug", "Defines the build configuration");
        var rids = new Option<string[]>("--rids", "RID is short for runtime identifier");
        var force_sign = new Option<bool>("--force-sign", GetDefForceSign, "Mandatory verification must be digitally signed");
        var hsm_sign = new Option<bool>("--hsm-sign", "");
        var sha256 = new Option<bool>("--sha256", () => true, "Calculate file hash value");
        var sha384 = new Option<bool>("--sha384", () => true, "Calculate file hash value");
        var stm_upload = new Option<bool>("--stm-upload", "Steam upload zip file");
        var command = new Command(commandName, "DotNet publish app")
        {
           debug, rids, force_sign, sha256, sha384, stm_upload, hsm_sign,
        };
        command.SetHandler(Handler, debug, rids, force_sign, sha256, sha384, stm_upload, hsm_sign);
        return command;
    }

#pragma warning disable CS0612 
/ 复制运行时
                SetConsoleColor(ConsoleColor.White, ConsoleColor.DarkMagenta);
                Console.WriteLine("开始复制运行时");
                ResetConsoleColor();
                CopyRuntime(rootPublishDir, info.Platform, isCopyRuntime, info.Architecture);
                SetConsoleColor(ConsoleColor.White, ConsoleColor.DarkGreen);
                Console.WriteLine("完成复制运行时");
                ResetConsoleColor();

                var appPublish = new AppPublishInfo()
                {
                    DeploymentMode = DeploymentMode.SCD,
                    RuntimeIdentifier = arg.RuntimeIdentifier,
                    DirectoryPath = rootPublishDir,
                };

                IOPath.DirTryDelete(Path.Combine(rootPublishDir, IOPath.DirName_AppData));
                IOPath.DirTryDelete(Path.Combine(rootPublishDir, IOPath.DirName_Cache));
                SetConsoleColor(ConsoleColor.White, ConsoleColor.DarkGreen);
                Console.WriteLine("已删除 AppData/Cache");
                ResetConsoleColor();

                SetConsoleColor(ConsoleColor.White, ConsoleColor.DarkMagenta);
                Console.WriteLine("开始扫描文件");
                ResetConsoleColor();
                IScanPublicDirectoryCommand.ScanPathCore(appPublish.DirectoryPath,
                    appPublish.Files,
                    ignoreRootDirNames: ignoreDirNames);
                SetConsoleColor(ConsoleColor.White, ConsoleColor.DarkGreen);
                Console.WriteLine("完成扫描文件");
                ResetConsoleColor();

                SetConsoleColor(ConsoleColor.White, ConsoleColor.DarkMagenta);
                Console.WriteLine("开始文件计算哈希值");
                ResetConsoleColor();
                if (sha256)
                {
                    foreach (var item in appPublish.Files)
                    {
                        using var fileStream = File.OpenRead(item.FilePath);
                        item.SHA256 = Hashs.String.SHA256(fileStream);
                    }
                }
                if (sha384)
                {
                    foreach (var item in appPublish.Files)
                    {
                        using var fileStream = File.OpenRead(item.FilePath);
                        item.SHA384 = Hashs.String.SHA384(fileStream);
                    }
                }
                SetConsoleColor(ConsoleColor.White, ConsoleColor.DarkGreen);
                Console.WriteLine("完成文件计算哈希值");
                ResetConsoleColor();

                if (OperatingSystem.IsWindows() && isWindows)
                {
                    
/ msix 签名证书名必须与包名一致
                    MSIXHelper.SignTool.Start(force_sign, $"\"{msixBundleFilePath}\"", MSIXHelper.SignTool.pfxFilePath_MSStore_CodeSigning);

                    using var msixFileStream = File.OpenRead(msixBundleFilePath);

                    var msixInfo = new AppPublishFileInfo
                    {
                        FileEx = ".msixbundle",
                        FilePath = msixBundleFilePath,
                        Length = msixFileStream.Length,
                        SignatureSHA384 = Hashs.String.SHA384(msixFileStream),
                    };
                    appPublish.SingleFile.Add(CloudFileType.MsixBundle, msixInfo);

                    SetConsoleColor(ConsoleColor.White, ConsoleColor.DarkGreen);
                    Console.Write("已生成【MSIX 包】，文件大小：");
                    Console.Write(IOPath.GetDisplayFileSizeString(msixInfo.Length));
                    Console.Write("，路径：");
                    Console.WriteLine(msixFilePath);
                    ResetConsoleColor();
                }

                SetConsoleColor(ConsoleColor.White, ConsoleColor.DarkMagenta);
                Console.WriteLine("开始创建【压缩包】");
                ResetConsoleColor();
                string? packPath = null;
                string GetPackPathWithTryDelete(string fileEx)
                {
                    var packPath = $"{rootPublishDir}{fileEx}";
                    IOPath.FileTryDelete(packPath);
                    return packPath;
                }
                switch (info.Platform)
                {
                    case Platform.Windows:
                    case Platform.UWP:
                    case Platform.WinUI:
                    case Platform.Apple:
                        ICompressedPackageCommand.CreateSevenZipPack(packPath = GetPackPathWithTryDelete(FileEx._7Z), appPublish.Files);
                        break;
                    case Platform.Linux:
                        ICompressedPackageCommand.CreateGZipPack(packPath = GetPackPathWithTryDelete(FileEx.TAR_GZ), appPublish.Files);
                        break;
                }
                if (stm_upload)
                {
                    List<AppPublishFileInfo> mainFiles = new();
                    List<AppPublishFileInfo> modulesFiles = new();
                    List<AppPublishFileInfo> stmUploads = new();
                    foreach (var item in appPublish.Files)
                    {
                        if (item.RelativePath.Contains("modules"))
                        {
                            modulesFiles.Add(item);
                        }
                        else
                        {
                            mainFiles.Add(item);
                        }
                    }
                    var stmupload_main_zip_path = GetPackPathWithTryDelete("_Main.stmupload.zip");
                    stmUploads.Add(new()
                    {
                        FilePath = stmupload_main_zip_path,
                        RelativePath = Path.GetFileName(stmupload_main_zip_path),
                    });
                    ICompressedPackageCommand.CreateZipPack(stmupload_main_zip_path, mainFiles);

                    var query = from module in modulesFiles
                                let split = module.RelativePath.Split(new char[] { '\\', '/' }, StringSplitOptions.RemoveEmptyEntries)
                                let name = split.Length >= 2 ? split[1] : null
                                where name != null
                                group module by name;
                    var items = query.ToArray();
                    foreach (var item in items)
                    {
                        if (string.IsNullOrWhiteSpace(item.Key))
                            continue;
                        var files = item.ToArray();
                        var stmupload_item_zip_path = GetPackPathWithTryDelete($"_{item.Key}.stmupload.zip");
                        stmUploads.Add(new()
                        {
                            FilePath = stmupload_item_zip_path,
                            RelativePath = Path.GetFileName(stmupload_item_zip_path),
                        });
                        ICompressedPackageCommand.CreateZipPack(stmupload_item_zip_path, files);
                    }
                    ICompressedPackageCommand.CreateZipPack(GetPackPathWithTryDelete(".stmupload.zip"), stmUploads);
                }
                SetConsoleColor(ConsoleColor.White, ConsoleColor.DarkGreen);
                Console.Write("创建成功【压缩包】，文件大小：");
                if (packPath != null)
                {
                    Console.Write(IOPath.GetDisplayFileSizeString(new FileInfo(packPath).Length));
                }
                else
                {
                    Console.Write(0);
                }
                Console.Write("，路径：");
                Console.WriteLine(packPath);
                ResetConsoleColor();

                var jsonFilePath = $"{rootPublishDir}.json";
                using var jsonFileStream = File.Open(jsonFilePath, FileMode.OpenOrCreate);
                JsonSerializer.Serialize(jsonFileStream, appPublish, new AppPublishInfoContext(new JsonSerializerOptions
                {
                    WriteIndented = true,
                    Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping,
                }).AppPublishInfo);
                jsonFileStream.Flush();
                jsonFileStream.SetLength(jsonFileStream.Position);

                SetConsoleColor(ConsoleColor.White, ConsoleColor.DarkGreen);
                Console.Write("发布文件信息清单已生成，文件大小：");
                Console.Write(IOPath.GetDisplayFileSizeString(appPublish.Files.Sum(x => x.Length)));
                Console.Write("，路径：");
                Console.WriteLine(jsonFilePath);
                ResetConsoleColor();
            }

            SetConsoleColor(ConsoleColor.White, ConsoleColor.DarkGreen);
            Console.WriteLine("OK");
            ResetConsoleColor();
        }
        finally
        {
            ResetConsoleColor();
        }
    }

    private static readonly Lazy<string> _AppVersion4 = new(() =>
    {
        var v = new Version(AssemblyInfo.FileVersion);
        static int GetInt32(int value) => value < 0 ? 0 : value;
        return $"{GetInt32(v.Major)}.{GetInt32(v.Minor)}.{GetInt32(v.Build)}.{GetInt32(v.Revision)}";
    });

    static string AppVersion4 => _AppVersion4.Value;

    
/ </summary>
    
/ <param name="rootPublishDir"></param>
    
/ <param name="isWindows"></param>
    
/ <param name="architecture"></param>
    static void CopyRuntime(string rootPublishDir, Platform platform, bool isCopyRuntime, Architecture architecture)
    {
        switch (platform)
        {
            case Platform.UWP:
            case Platform.WinUI:
            case Platform.Windows:
                if (isCopyRuntime)
                {
                    
/ </summary>
    
/ <param name="arg"></param>
    static void RemoveCreateDump(string publishDir)
    {
        var path = Path.Combine(publishDir, "createdump.exe");
        if (File.Exists(path)) File.Delete(path);
        path = Path.Combine(publishDir, "createdump");
        if (File.Exists(path)) File.Delete(path);
    }

    
/ </summary>
    
/ <param name="libraryName"></param>
    
/ <param name="platform"></param>
    
/ <param name="fileExtension"></param>
    
/ <returns></returns>
    
/ <exception cref="ArgumentOutOfRangeException"></exception>
    static string GetLibraryFileName(string libraryName, Platform platform, string? fileExtension = null)
    {
        if (string.IsNullOrWhiteSpace(fileExtension))
        {
            fileExtension = platform switch
            {
                Platform.UWP or Platform.Windows or Platform.WinUI => ".dll",
                Platform.Linux or Platform.Android => ".so",
                Platform.Apple => ".dylib",
                _ => throw new ArgumentOutOfRangeException(nameof(platform), platform, null),
            };
        }
        if (!libraryName.EndsWith(fileExtension, StringComparison.OrdinalIgnoreCase))
            libraryName += fileExtension;
        return libraryName;
    }

    
/ </summary>
    
/ <param name="arg"></param>
    
/ <param name="platform"></param>
    static void MoveNativeLibrary(string publishDir, string runtimeIdentifier, Platform platform)
    {
        var nativeDir = Path.Combine(publishDir, "..", "native");
        var nativeWithRuntimeIdentifierDir = Path.Combine(nativeDir, runtimeIdentifier);
        
/ </summary>
    
/ <param name="isDebug"></param>
    
/ <param name="platform"></param>
    
/ <param name="deviceIdiom"></param>
    
/ <param name="architecture"></param>
    
/ <returns></returns>
    
/ <exception cref="ArgumentOutOfRangeException"></exception>
    static PublishCommandArg SetPublishCommandArgumentList(
        bool isDebug,
        Platform platform,
        DeviceIdiom deviceIdiom,
        Architecture architecture)
    {
        PublishCommandArg arg = default;
        arg.IsDebug = isDebug;
        switch (platform)
        {
            case Platform.Windows:
                switch (deviceIdiom)
                {
                    case DeviceIdiom.Desktop:
                        arg.Framework = $"net{Environment.Version.Major}.{Environment.Version.Minor}-windows{windowssdkver}";
                        arg.RuntimeIdentifier = $"win-{ArchToString(architecture)}";
                        arg.UseAppHost = false;
                        arg.SingleFile = false;
                        arg.ReadyToRun = false;
                        arg.Trimmed = false;
                        arg.SelfContained = false;
                        break;
                    default:
                        throw new ArgumentOutOfRangeException(nameof(deviceIdiom), deviceIdiom, null);
                }
                break;
            case Platform.Linux:
                switch (deviceIdiom)
                {
                    case DeviceIdiom.Desktop:
                        arg.Framework = $"net{Environment.Version.Major}.{Environment.Version.Minor}";
                        arg.RuntimeIdentifier = $"linux-{ArchToString(architecture)}";
                        arg.UseAppHost = false;
                        arg.SingleFile = false;
                        arg.ReadyToRun = false;
                        arg.Trimmed = false;
                        arg.SelfContained = false;
                        arg.Architecture = architecture;
                        
/learn.microsoft.com/zh-cn/dotnet/core/tools/dotnet-run
                        
/download.visualstudio.microsoft.com/download/pr/c1e2729e-ab96-4929-911d-bf0f24f06f47/1b2f39cbc4eb530e39cfe6f54ce78e45/aspnetcore-runtime-7.0.7-linux-x64.tar.gz
                        
/arg.SelfContained = true;
                        break;
                    default:
                        throw new ArgumentOutOfRangeException(nameof(deviceIdiom), deviceIdiom, null);
                }
                break;
            case Platform.Apple:
                switch (deviceIdiom)
                {
                    case DeviceIdiom.Desktop:
                        arg.Framework = $"net{Environment.Version.Major}.{Environment.Version.Minor}-macos";
                        arg.RuntimeIdentifier = $"osx-{ArchToString(architecture)}";
                        arg.UseAppHost = null;
                        arg.SingleFile = null;
                        arg.ReadyToRun = null;
                        arg.Trimmed = null;
                        arg.SelfContained = null;
                        arg.CreatePackage = null;
                        break;
                    default:
                        throw new ArgumentOutOfRangeException(nameof(deviceIdiom), deviceIdiom, null);
                }
                break;
            default:
                throw new ArgumentOutOfRangeException(nameof(platform), platform, null);
        }
        return arg;
    }

    record struct PublishCommandArg(
        bool IsDebug,
        string Framework,
        string RuntimeIdentifier,
        bool? UseAppHost = false,
        bool? SingleFile = false,
        bool? ReadyToRun = false,
        bool? Trimmed = false,
        bool? SelfContained = false,
        bool? EnableMsixTooling = null,
        bool? GenerateAppxPackageOnBuild = null,
        bool? StripSymbols = null,
        bool? CreatePackage = null,
        Architecture? Architecture = null
        )
    {
        string? _Configuration;

        public static string GetConfiguration(bool debug) => debug ? "Debug" : "Release";

        public string Configuration
        {
            get
            {
                _Configuration ??= GetConfiguration(IsDebug);
                return _Configuration;
            }
        }

        string? _PublishDir;

        public string GetPublishDirWithAssemblies()
        {
            var value = string.Join(Path.DirectorySeparatorChar, new[]
                {
                    "bin",
                    Configuration,
                    "Publish",
                    GetPublishFileName(IsDebug, RuntimeIdentifier),
                    "assemblies",
                });
            return value;
        }

        public string GetPublishDir()
        {
            var value = string.Join(Path.DirectorySeparatorChar, new[]
                {
                    "bin",
                    Configuration,
                    "Publish",
                    GetPublishFileName(IsDebug, RuntimeIdentifier),
                });
            return value;
        }

        public string PublishDir
        {
            get
            {
                _PublishDir ??= /*RuntimeIdentifier.StartsWith("linux") ? GetPublishDir() :*/ GetPublishDirWithAssemblies();
                return _PublishDir;
            }

            set
            {
                _PublishDir = value;
            }
        }
    }

    const string publish_apphost_winany_arg =
"""
publish -c {0} -p:OutputType={1} -p:PublishDir=bin\{0}\Publish\win-any -p:PublishReferencesDocumentationFiles=false  -p:PublishDocumentationFile=false -p:PublishDocumentationFiles=false -f {2} -p:DebugType=none -p:DebugSymbols=false --nologo -v q /property:WarningLevel=1
""";

    static void PublishAppHost(string publishDir, Platform platform, bool debug)
    {
        const string appconfigFileName = "Steam++.exe.config";

        var rootPublishDir = Path.Combine(publishDir, "..");
        
/ net4x 不能兼容 2.x~3.x
                        appconfigContent = appconfigContent.Replace(
"""
<supportedRuntime version="v2.0.50727" />
""", null);

                        if (app_host_tfm == "net40")
                        {
                            appconfigContent = appconfigContent.Replace(
"""
<supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.0" />
""", null);
                        }
                    }
                    var xmlDoc = new XmlDocument();
                    xmlDoc.LoadXml(appconfigContent);
                    appconfigContent = xmlDoc.InnerXml;
                    File.WriteAllText(destFileName, appconfigContent);
                }
                else
                {
                    File.Copy(sourceFileName, destFileName, true);
                }
            }

        }
    }

    
/ </summary>
    
/ <param name="argumentList"></param>
    
/ <param name="arg"></param>
    static void SetPublishCommandArgumentList(
        IList<string> argumentList,
        PublishCommandArg arg)
    {
        
/learn.microsoft.com/zh-cn/dotnet/core/tools/dotnet-publish
        
/learn.microsoft.com/zh-cn/dotnet/core/project-sdk/msbuild-props
        
/learn.microsoft.com/zh-cn/dotnet/maui/mac-catalyst/deployment/publish-unsigned
        
/learn.microsoft.com/zh-cn/windows/apps/windows-app-sdk/single-project-msix?tabs=csharp
        
/learn.microsoft.com/zh-cn/windows/apps/package-and-deploy/project-properties
        
/learn.microsoft.com/zh-cn/dotnet/core/compatibility/deployment/8.0/stripsymbols-default

        argumentList.Add("publish");
        var configuration = arg.Configuration;

        
/ (macos/maccatalyst)一个可选参数，用于控制是创建 .app 还是 .pkg。 将 false 用于 .app。
        if (arg.CreatePackage.HasValue)
            argumentList.Add($"-p:CreatePackage={arg.CreatePackage.Value.ToLowerString()}");

        
/ 发布针对给定运行时的应用程序。 有关运行时标识符 (RID) 的列表，请参阅 RID 目录。
        argumentList.Add("-r");
        argumentList.Add(arg.RuntimeIdentifier);

        argumentList.Add("-v");
        argumentList.Add("q");
        argumentList.Add("/property:WarningLevel=1");

        
/ </summary>
    
/ <param name="publishDir"></param>
    
/ <param name="configuration"></param>
    
/ <param name="framework"></param>
    
/ <exception cref="FileNotFoundException"></exception>
    static void PublishPlugins(
                bool isDebug,
                Platform platform,
                Architecture architecture,
                string publishDir,
                string configuration,
                string framework)
    {
        foreach (var pluginName in GetPluginNames(platform))
        {
            var projRootPath = Path.Combine(ProjectUtils.ProjPath, "src", $"BD.WTTS.Client.Plugins.{pluginName}");
            StartProcessAndWaitForExit(projRootPath, $"build -c {configuration} --nologo -v q /property:WarningLevel=1");

            var dllFileName = $"BD.WTTS.Client.Plugins.{pluginName}.dll";
            var pluginBuildDir = Path.Combine(projRootPath, "bin", configuration);
            var dllPath = Path.Combine(pluginBuildDir, framework, dllFileName);
            if (!File.Exists(dllPath))
            {
                framework = framework.Split('-').FirstOrDefault()!;
                if (!string.IsNullOrEmpty(framework))
                {
                    dllPath = Path.Combine(pluginBuildDir, framework, dllFileName);
                    if (!File.Exists(dllPath))
                        throw new FileNotFoundException(null, dllPath);
                }
                else
                {
                    throw new FileNotFoundException(null, dllPath);
                }
            }
            var pluginDir = Path.Combine(publishDir, "..", "modules", pluginName);
            IOPath.DirCreateByNotExists(pluginDir);
            var destFileName = Path.Combine(pluginDir, dllFileName);
            File.Copy(dllPath, destFileName, true);

            
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\Commands\IGenerateBridgeContentXml.cs
/Link>

""");
                stream.Write(
"""
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>

"""u8);
                stream.Write(
"""
    </Content>

"""u8);
            }
            stream.Write("  </ItemGroup>"u8);
            stream.WriteNewLine();
            stream.Write($"  <!--[End] BD.WTTS.Client.Tools.Publish({(debug ? "Debug" : "Release")}-{rid}) -->");

            stream.Position = 0;

            var str = Encoding.UTF8.GetString(stream.ToByteArray());
            Console.WriteLine(str);
        }
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\Commands\IGenerateBsPatch.cs
/ </summary>
    
/ <param name="applyPath"></param>
    
/ <param name="saveFilePath"></param>
    
/ <param name="patchPath"></param>
    
/ <returns></returns>
    internal static async ThreadTask ApplyPatch(string applyPath, string saveFilePath, string patchPath)
    {
        if (!File.Exists(patchPath))
        {
            Console.WriteLine("PatchPath not exists");
            return;
        }

        if (!Directory.Exists(applyPath))
        {
            Console.WriteLine("ApplyPath not exists");
            return;
        }
        var fileStream = File.OpenRead(patchPath);
        var jsonData = new BrotliStream(fileStream, CompressionMode.Decompress);
        var dic = await MemoryPackSerializer.DeserializeAsync<Dictionary<string, PatchBundleInfo?>>(jsonData);
        if (dic is null)
        {
            Console.WriteLine("Patch Error");
            return;
        }
        if (!Directory.Exists(saveFilePath))
        {
            Directory.CreateDirectory(saveFilePath);
        }
        else
        {
            Directory.Delete(saveFilePath);
        }
        CopyDirectory(applyPath, saveFilePath);
        FileInfo? fileInfo = null;
        foreach (var item in dic.Where(x => x.Value is not null))
        {
            PatchBundleInfo info = item.Value!;
            if (info.PatchData is not null)
            {
                fileInfo = new FileInfo(Path.Combine(saveFilePath, item.Key));
                if (!(fileInfo.Directory?.Exists ?? false))
                    fileInfo.Directory?.Create();
                if (info.IsFullOrPatch)
                {
                    File.WriteAllBytes(Path.Combine(saveFilePath, item.Key), info.PatchData);
                }
                else
                {
                    using var oldFile = File.OpenRead(Path.Combine(applyPath, item.Key));
                    var newFile = Path.Combine(saveFilePath, item.Key);
                    using var saveFile = File.Exists(newFile) ? File.Create(newFile) : File.OpenWrite(newFile);
                    BinaryPatch.Apply(oldFile, () => new MemoryStream(info.PatchData), saveFile);
                }
            }
        }
        Console.WriteLine("ApplyPatch OK");
    }

    
/ </summary>
    
/ <param name="sourceDir"></param>
    
/ <param name="targetDir"></param>
    
/ <exception cref="DirectoryNotFoundException"></exception>
    public static void CopyDirectory(string sourceDir, string targetDir)
    {
        DirectoryInfo dir = new DirectoryInfo(sourceDir);
        DirectoryInfo[] dirs = dir.GetDirectories();

        
/ </summary>
    
/ <param name="oldByte"></param>
    
/ <param name="newByte"></param>
    
/ <param name="output"></param>
    internal static void GenerateBsPatch(byte[] oldByte, byte[] newByte, Stream output)
    {
        BinaryPatch.Create(oldByte, newByte, output);
    }

    
/ </summary>
    
/ <param name="appVer"></param>
    
/ <param name="jsonPath">发布工具生成的 Json</param>
    
/ <param name="platform"></param>
    
/ <returns></returns>
    internal static async ThreadTask UploadAppVer(string appVer, string jsonPath, ClientPlatform platform)
    {
        if (string.IsNullOrWhiteSpace(appVer))
        {
            Console.WriteLine("AppVer not exists");
            return;
        }
        if (string.IsNullOrWhiteSpace(jsonPath))
        {
            Console.WriteLine("jsonPath not exists");
            return;
        }
        if (!File.Exists(jsonPath))
        {
            Console.WriteLine("jsonPath not Find");
            return;
        }

        var fileListRaw = File.ReadAllBytes(jsonPath);
        var appver = await GetAppVer(appVer);
        if (appver is not null)
        {
            var thisFileList = appver.FileList?.FirstOrDefault(x => x.Platform == platform);
            if (thisFileList is not null)
            {
                if (Hashs.String.SHA384(thisFileList.FileListRaw) != Hashs.String.SHA384(fileListRaw))
                {
                    thisFileList.FileListRaw = fileListRaw;
                }
            }
            else
            {
                if (appver.FileList is null)
                {
                    appver.FileList = new List<AppVerFileList>
                {
                    new AppVerFileList
                    {
                        Platform = platform,
                        FileListRaw = fileListRaw
                    }
                };
                }
                else
                {
                    appver.FileList.Add(new AppVerFileList
                    {
                        Platform = platform,
                        FileListRaw = fileListRaw
                    });
                }
            }
            await UploadAppVer(appver);
        }
        else
        {
            appver = new AppVer
            {
                Platform = platform,
                Ver = appVer,
                Published = DateTimeOffset.Now,
                FileList = new List<AppVerFileList>
                {
                    new AppVerFileList
                    {
                        Platform = platform,
                        FileListRaw = fileListRaw
                    }
                }
            };
            await UploadAppVer(appver);
        }
    }

    
/ </summary>
    
/ <param name="appVer"></param>
    
/ <returns></returns>
    internal static async ThreadTask UploadAppVer(AppVer appVer)
    {
        using var httpClient = new HttpClient();
        var content = JsonContent.Create(appVer);
        var response = await httpClient.PostAsync($"{BaseUrl}/appver/", content);
    }

    
/ </summary>
    
/ <param name="oldVer"></param>
    
/ <param name="newVer"></param>
    
/ <param name="platform"></param>
    
/ <param name="patchFilePath"></param>
    
/ <returns></returns>
    internal static async ThreadTask GenerateAppPublishPatchBundleInfo(string oldVer, string newVer, ClientPlatform platform, string patchFilePath)
    {
        var oldAppVer = await GetAppVer(oldVer);
        var newAppVer = await GetAppVer(newVer);
        if (oldAppVer is null || newAppVer is null)
        {
            Console.WriteLine("AppVer not exists");
            return;
        }
        var oldFileList = await GetAppPublishInfo(oldAppVer.Id, platform);
        var newFileList = await GetAppPublishInfo(newAppVer.Id, platform);
        if (oldFileList is null || newFileList is null)
        {
            Console.WriteLine("AppPublishInfo not exists");
            return;
        }
        var oldAppVerFileList = JsonSerializer.Deserialize<AppPublishInfo>(oldFileList.FileListRaw);
        var newAppVerFileList = JsonSerializer.Deserialize<AppPublishInfo>(newFileList.FileListRaw);
        if (oldAppVerFileList is null || newAppVerFileList is null)
        {
            Console.WriteLine("AppPublishInfo not exists");
            return;
        }
        var pathSavePath = Path.Combine(patchFilePath, oldVer, $"{newVer}.dat");
        var pathFileInfo = new FileInfo(pathSavePath);
        if (!(pathFileInfo.Directory?.Exists ?? false))
        {
            pathFileInfo.Directory?.Create();
        }
        Console.WriteLine($"开始生成: {oldVer} -> {newVer} platform:{platform}");
        await ContrastVersion(oldAppVerFileList, newAppVerFileList, pathSavePath);

    }

    
/ </summary>
    
/ <param name="ver"></param>
    
/ <returns></returns>
    public static async Task<AppVer?> GetAppVer(string ver)
    {
        using var httpClient = new HttpClient();
        var response = await httpClient.GetAsync($"{BaseUrl}/appver/{ver}");
        var data = JsonSerializer.Deserialize<ApiRsp<AppVer?>>(await response.Content.ReadAsStringAsync(), new JsonSerializerOptions
        {
            PropertyNameCaseInsensitive = true
        });
        return data?.Content;
    }

    
/ </summary>
    
/ <param name="appVerId">版本号</param>
    
/ <param name="platform">平台</param>
    
/ <returns></returns>
    public static async Task<AppVerFileList?> GetAppPublishInfo(Guid appVerId, ClientPlatform platform)
    {
        using var httpClient = new HttpClient();
        var response = await httpClient.GetAsync($"{BaseUrl}/appver/file/{appVerId}/{platform}/list");
        var data = JsonSerializer.Deserialize<ApiRsp<AppVerFileList?>>(await response.Content.ReadAsStringAsync(), new JsonSerializerOptions
        {
            PropertyNameCaseInsensitive = true
        });
        return data?.Content;
    }

    
/ </summary>
    
/ <param name="oldFileList"></param>
    
/ <param name="newFileList"></param>
    
/ <param name="patchFilePath"></param>
    
/ <returns></returns>
    public static async ThreadTask ContrastVersion(AppPublishInfo oldFileList, AppPublishInfo newFileList, string patchFilePath)
    {
        var oldFiles = oldFileList.Files.Where(x => !x.RelativePath.StartsWith("dotnet\\"));
        var newFiles = newFileList.Files.Where(x => !x.RelativePath.StartsWith("dotnet\\"));
        Console.WriteLine($"旧版本文件数：{oldFiles.Count()}");
        Console.WriteLine($"新版本文件数：{newFiles.Count()}");
        var changeList = new Dictionary<string, PatchBundleInfo?>();

        var removeFiles = oldFiles.Select(x => x.RelativePath).Except(newFiles.Select(x => x.RelativePath));
        
/ </summary>
    
/ <param name="sha384"></param>
    
/ <returns></returns>
    public static async Task<AppVerFile?> GetFileRaw(string sha384)
    {
        using var httpClient = new HttpClient();
        var response = await httpClient.GetAsync($"{BaseUrl}/appver/file/{sha384}");
        var data = JsonSerializer.Deserialize<ApiRsp<AppVerFile?>>(await response.Content.ReadAsStringAsync(), new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
        return data?.Content;
    }

    
/ </summary>
    
/ <param name="directoryPath">需要上传的目录</param> 
    internal static async ThreadTask UploadFiles(string directoryPath)
    {
        DirectoryInfo directoryInfo = new(directoryPath);
        if (directoryInfo.Exists)
        {
            using var httpClient = new HttpClient();
            var fileList = new List<AppPublishFileInfo>();
            IScanPublicDirectoryCommand.ScanPathCore(directoryPath, fileList, null, null);
            using var form = new MultipartFormDataContent();
            fileList.ForEach(file =>
            {
                var fileStream = file.FileInfo!.OpenRead();
                form.Add(new StreamContent(fileStream), file.FileInfo!.Name, file.FileInfo!.Name);
            });
            if (form.Count() > 0)
            {
                var response = await httpClient.PostAsync($"{BaseUrl}/appver/file/upload", form);
                Console.WriteLine(response);
            }
        }
        else
        {
            Console.WriteLine("文件夹不存在");
        }
    }
}

发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Tools.Publish\Commands\IGenerateBsPatch.cs
DEBUG
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\Commands\IGenerateCaCertCommand.cs
/oidref.com/1.3.6.1.5.5.7.3.3
    
/ </summary>
    const string codeSigningOid = "1.3.6.1.5.5.7.3.3";

    
/oidref.com/1.3.6.1.4.1.311.10.3.13
    
/ </summary>
    const string _13Oid = "1.3.6.1.4.1.311.10.3.13";

    static (byte[] pfx, byte[] cer, string? csr) GenerateCodeSigningCert(string x500DistinguishedNameValue, string password, bool isCSR = false)
    {
        string? csr = default;
        if (!isCSR && string.IsNullOrWhiteSpace(password))
            throw new ArgumentOutOfRangeException(nameof(password), password, null);

        
/learn.microsoft.com/zh-cn/windows/win32/appxpkg/how-to-create-a-package-signing-certificate

        using var rsa = RSA.Create(KEY_SIZE_BITS);
        X500DistinguishedName subjectName = new(x500DistinguishedNameValue);
        CertificateRequest request = new(subjectName, rsa,
            HashAlgorithmName.SHA384, RSASignaturePadding.Pkcs1);

        
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\Commands\IHashCalcCommand.cs
/sub> | <sub>{hash_winx64_7z}</sub> |
| <sub>Steam++_v{AssemblyInfo.InformationalVersion}_win_x64.exe</sub> | <sub>{hash_winx64_exe}</sub> |
|||
| <sub>Steam++_v{AssemblyInfo.InformationalVersion}_linux_x64.tgz</sub> | <sub>{hash_linuxx64_tgz}</sub> |
|||
| <sub>Steam++_v{AssemblyInfo.InformationalVersion}_macos.dmg</sub> | <sub>{hash_mac_dmg}</sub> |
""";

        var filePath = Path.Combine(projRootPath, "Checksum.md");
        IOPath.FileTryDelete(filePath);
        File.WriteAllText(filePath, fileContent);
        Console.WriteLine(fileContent);
        Console.Write("OK, SavePath: ");
        Console.WriteLine(filePath);
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\Commands\IInstallPackageCommand.cs
/RedHat Linux installer");
        var deb = new Option<bool>("--deb", "Create Ubuntu/Debian Linux installer");
        var pkg = new Option<bool>("--pkg", "Create macOS installer");
        var msi = new Option<bool>("--msi", "Create Windows Installer (msi) package");
        var rids = new Option<string[]>("--rids", "RID is short for runtime identifier");
        var command = new Command(commandName, "Create install package")
        {
            rpm, deb, pkg, msi, rids,
        };
        command.SetHandler(Handler, rpm, deb, pkg, msi, rids);
        return command;
    }

    internal static void Handler(bool rpm, bool deb, bool pkg, bool msi, string[] rids)
    {
        var tasks = AppPublishInfo.Instance.
              Where(x => rids.Contains(x.RuntimeIdentifier)).
              Select(x =>
              {
                  return GetTasks();
                  IEnumerable<ThreadTask> GetTasks()
                  {
                      switch (x.Platform)
                      {
                          case Platform.Windows:
                              
/LinuxPackConstants.DebSection,
            "utils",
            LinuxPackConstants.DebPriority,
            LinuxPackConstants.DebHomepage,
            LinuxPackConstants.PreInstallScript,
            LinuxPackConstants.PostInstallScript,
            LinuxPackConstants.PreRemoveScript,
            LinuxPackConstants.PostRemoveScript,
            dependencies,
            recommends,
            null!);

            DebPackageCreator.WriteDebPackage(
                archiveEntries,
                tarXzStream,
                targetStream,
                pkg);
        }

        File.Delete(debTarXzPath);
    }

    sealed class ArchiveBuilder2 : ArchiveBuilder
    {
        public new void AddFile(string entry, string relativePath, string prefix, List<ArchiveEntry> value, ITaskItem[] metadata)
        {
            base.AddFile(entry, relativePath, prefix, value, metadata);
        }
    }

    static void AddFileNameDesktop(ArchiveBuilder2 archiveBuilder2, List<ArchiveEntry> archiveEntries)
    {
        var metadata = new Dictionary<string, string>()
        {
            { "CopyToPublishDirectory", "Always" },
            { "LinuxPath", "/usr/share/applications/" + LinuxPackConstants.FileNameDesktop },
            { "Link", LinuxPackConstants.FileNameDesktop },
        };

        var taskItem = new TaskItem(LinuxPackConstants.FileNameDesktop, metadata);
        var taskItems = new ITaskItem[] { taskItem };
        archiveBuilder2.AddFile(
            Path.Combine(AppContext.BaseDirectory, LinuxPackConstants.FileNameDesktop),
            LinuxPackConstants.FileNameDesktop,
            LinuxPackConstants.Prefix,
            archiveEntries,
            taskItems);
    }

    static PgpKeyRingGenerator? krgen;
    static PgpSecretKeyRing? secretKeyRing;
    static PgpPrivateKey? privateKey;

    static readonly Lazy<bool> init = new(() =>
    {
        try
        {
            krgen = PgpSigner.GenerateKeyRingGenerator("dotnet", "dotnet");
            secretKeyRing = krgen.GenerateSecretKeyRing();
            privateKey = secretKeyRing.GetSecretKey().ExtractPrivateKey("dotnet".ToCharArray());
            return true;
        }
        catch
        {
            return false;
        }
    });

    static void GenerateRpmPackage(AppPublishInfo item)
    {
        if (!init.Value) return;

        var rpmPath = GetPackPath(item, FileEx.RPM);
        
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\Commands\ILaunchAppTestCommand.cs
/ </summary>
interface ILaunchAppTestCommand : ICommand
{
    const string commandName = "launch";

    static Command ICommand.GetCommand()
    {
        var command = new Command(commandName, "Launch application testing")
        {

        };
        command.SetHandler(Handler);
        return command;
    }

    internal static void Handler(InvocationContext context)
    {
        var path = DebugRuntimeConfigPath;

        HandlerJsonFiles(path, Platform.Windows);

        
/ </summary>
    
/ <param name="path"></param>
    static void HandlerJsonFiles(string path, Platform platform)
    {
        using var stream = GetFileStream(path);
        var node = TryParseJsonNode(stream);
        if (stream != null && node != null)
        {
            bool isWindows = false;
            switch (platform)
            {
                case Platform.Windows:
                case Platform.UWP:
                case Platform.WinUI:
                    isWindows = true;
                    break;
            }
            if (isWindows)
            {
                
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\Commands\IMacOSBuildingUniversalBinaryCommand.cs
/developer.apple.com/documentation/apple-silicon/building-a-universal-macos-binary

    const string commandName = "macos-universal-binary";

    static Command ICommand.GetCommand()
    {
        
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\Commands\INSISBuildCommand.cs
/ hsm 目前无法映射到 CI VM 中
        }

        releaseTimestamp = timestamp;

        var rootDirPath = Path.Combine(ProjectUtils.ProjPath, "..", "NSIS-Build");
        var nsiFilePath = Path.Combine(rootDirPath, "AppCode", "Steampp", "app", "SteamPP_setup.nsi");

        if (!File.Exists(nsiFilePath))
        {
            Console.WriteLine($"找不到 NSIS-Build 文件，值：{nsiFilePath}");
            return;
        }

        var nsiFileContent = File.ReadAllText(nsiFilePath);
        var nsiFileContentBak = nsiFileContent;

        var appFileDirPath = Path.Combine(rootDirPath, "AppCode", "Steampp");
        var nsisExeFilePath = Path.Combine(rootDirPath, "NSIS", "makensis.exe");

        foreach (var rid in rids)
        {
            var info = DeconstructRuntimeIdentifier(rid);
            if (info == default) continue;

            var projRootPath = ProjectPath_AvaloniaApp;
            var arg = SetPublishCommandArgumentList(debug, info.Platform, info.DeviceIdiom, info.Architecture);
            var publishDir = Path.Combine(projRootPath, arg.PublishDir);
            Console.WriteLine(publishDir);
            var rootPublishDir = Path.GetFullPath(Path.Combine(publishDir, ".."));
            var packPath = $"{rootPublishDir}{FileEx._7Z}";

            var install7zFilePath = packPath;
            var install7zFileName = Path.GetFileName(install7zFilePath);
            var outputFileName = Path.GetFileNameWithoutExtension(install7zFilePath) + FileEx.EXE;
            var outputFilePath = Path.Combine(new FileInfo(install7zFilePath).DirectoryName!, outputFileName);
            IOPath.FileTryDelete(outputFilePath);
            var exeName = "Steam++.exe";

            var nsiFileContent2 = nsiFileContent
                     .Replace("${{ Steam++_Company }}", AssemblyInfo.Company)
                     .Replace("${{ Steam++_Copyright }}", AssemblyInfo.Copyright)
                     .Replace("${{ Steam++_ProductName }}", AssemblyInfo.Trademark)
                     .Replace("${{ Steam++_ExeName }}", exeName)
                     .Replace("${{ Steam++_Version }}", AppVersion4)
                     .Replace("${{ Steam++_OutPutFileName }}", outputFileName)
                     .Replace("${{ Steam++_AppFileDir }}", appFileDirPath)
                     .Replace("${{ Steam++_7zFilePath }}", install7zFilePath)
                     .Replace("${{ Steam++_7zFileName }}", install7zFileName)
                     .Replace("${{ Steam++_OutPutFilePath }}", outputFilePath)
                     .Replace("${{ Steam++_UninstFileName }}", Path.Combine(appFileDirPath, "app", "uninst.exe"))
                     ;
            File.WriteAllText(nsiFilePath, nsiFileContent2);

            var process = Process.Start(new ProcessStartInfo()
            {
                FileName = nsisExeFilePath,
                Arguments = $" /DINSTALL_WITH_NO_NSIS7Z=1 \"{nsiFilePath}\"",
                UseShellExecute = false,
            });
            process!.WaitForExit();

            if (!debug) 
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\Commands\IScanPublicDirectoryCommand.cs
/ </summary>
interface IScanPublicDirectoryCommand : ICommand
{
    const string commandName = "scan";

    static Command ICommand.GetCommand()
    {
        var sha256 = new Option<bool>("--sha256", () => true, "Calculate hash sha256");
        var sha384 = new Option<bool>("--sha384", () => true, "Calculate hash sha384");
        var signature = new Option<bool>("--signature", () => true, "Digital signature");
        var rids = new Option<string[]>("--rids", "RID is short for runtime identifier");
        var command = new Command(commandName, "Scan publish directory")
        {
            sha256, sha384, signature, rids,
        };
        command.SetHandler(Handler, sha256, sha384, signature, rids);
        return command;
    }

    
/ </summary>
    
/ <param name="rids"></param>
    
/ <returns></returns>
    static string[] GetRuntimeIdentifiers(string[] rids)
    {
        if (rids == null || !rids.Any())
        {
            rids = all_rids;
        }
        return rids;
    }

    
/ </summary>
    
/ <param name="rid"></param>
    
/ <param name="deploymentMode"></param>
    
/ <returns></returns>
    static AppPublishInfo? GetAppPublishInfo(string rid, DeploymentMode deploymentMode)
    {
        var info = new AppPublishInfo()
        {
            DeploymentMode = deploymentMode,
            RuntimeIdentifier = rid,
        };
        (info.Platform, info.DeviceIdiom, info.Architecture) = DeconstructRuntimeIdentifier(rid);
        return info;
    }

    
/ </summary>
    
/ <param name="info"></param>
    
/ <returns></returns>
    static bool HasFrameworkDependent(AppPublishInfo info)
    {
        if (info.Platform == Platform.Windows)
        {
            return true;
        }
        return default;
    }

    internal static void Handler(bool sha256, bool sha384, bool signature, string[] rids)
    {
        ConcurrentBag<AppPublishInfo> infos = new();
        rids = GetRuntimeIdentifiers(rids);
        var tasks = rids.Select(rid => InBackground(() =>
        {
            DeploymentMode deploymentMode = DeploymentMode.SCD;
            if (TryAddInfo(rid, deploymentMode, out var info))
            {
                if (HasFrameworkDependent(info))
                {
                    TryAddInfo(rid, DeploymentMode.FDE, out var _);
                }
            }

            bool TryAddInfo(string rid,
                DeploymentMode deploymentMode,
                [NotNullWhen(true)] out AppPublishInfo? info)
            {
                info = GetAppPublishInfo(rid, deploymentMode);
                if (info == null)
                    return false;
                if (!ScanPath(rid, info))
                    return false;
                if (signature)
                {
                    
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\Enums\CloudFileType.cs
/ </summary>
public enum CloudFileType
{
    
发现 Windows 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\Helpers\MSIXHelper.cs
C:\MSStore_CodeSigning.pfx
C:\BeyondDimension_CodeSigning.pfx
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\Helpers\MSIXHelper.cs
/learn.microsoft.com/en-us/windows/uwp/app-resources/makepri-exe-command-options

            var xmlPath = @$"{rootPublicPath}\priconfig.xml";
            var mnPath = @$"{rootPublicPath}\AppXManifest.xml";

            IOPath.FileIfExistsItDelete(xmlPath);

            var fileName = GetMakePriPath();
            var psi = new ProcessStartInfo
            {
                FileName = fileName,
                UseShellExecute = false,
                Arguments =
$"""
createconfig /cf "{xmlPath}" /dq zh-CN /o /pv 10.0.0
""",
                WorkingDirectory = rootPublicPath,
            };
            ProcessHelper.StartAndWaitForExit(psi);

            var prixml = File.ReadAllText(xmlPath);
            prixml = prixml.Replace("<packaging>\r\n\t\t<autoResourcePackage qualifier=\"Language\"/>\r\n\t\t<autoResourcePackage qualifier=\"Scale\"/>\r\n\t\t<autoResourcePackage qualifier=\"DXFeatureLevel\"/>\r\n\t</packaging>", "");
            File.WriteAllText(xmlPath, prixml);

            var prPath = $@"{ProjectUtils.ProjPath}\res\windows\makepri";
            CopyDirectory(prPath, rootPublicPath, true);
            psi = new ProcessStartInfo
            {
                FileName = fileName,
                UseShellExecute = false,
                Arguments =
$"""
new /cf "{xmlPath}" /pr "{prPath}" /mn "{mnPath}"
""",
                WorkingDirectory = rootPublicPath,
            };
            ProcessHelper.StartAndWaitForExit(psi);

            IOPath.FileIfExistsItDelete(xmlPath);
        }
    }

    public static class MakeAppx
    {
        
/learn.microsoft.com/zh-cn/windows/msix/package/create-app-package-with-makeappx-tool
        
/var msixPath = $"{rootPublicPath}.msixbundle";
            IOPath.FileIfExistsItDelete(msixPath);

            var psi = new ProcessStartInfo
            {
                FileName = GetMakeAppxPath(),
                UseShellExecute = false,
                Arguments =
$"""
pack /v /h SHA256 /d "{rootPublicPath}" /p "{msixPath}"
""",
                
/bundle /v /d "{rootPublicPath}" /p "{msixPath}"
                
/GenerateBundleManifestXml(dirPath, version4);

            IOPath.FileIfExistsItDelete(msixPath);

            var psi = new ProcessStartInfo
            {
                FileName = GetMakeAppxPath(),
                UseShellExecute = false,
                Arguments =
$"""
bundle /v /bv {version4} /d "{dirPath}" /p "{msixPath}"
""",
            };
            ProcessHelper.StartAndWaitForExit(psi);
        }

        const string IdentityName = "4651ED44255E.47979655102CE";
        const string Publisher = "CN=A90E406B-B2D3-4A23-B061-0FA1D65C4F66";
        
/ </summary>
        
/ <param name="rootPublicPath"></param>
        
/ <param name="version4"></param>
        
/ <param name="processorArchitecture"></param>
        public static void GenerateAppxManifestXml(
            string rootPublicPath,
            string version4,
            Architecture processorArchitecture)
        {
            
/learn.microsoft.com/zh-cn/windows/msix/desktop/desktop-to-uwp-manual-conversion

            
/learn.microsoft.com/zh-cn/windows/uwp/launch-resume/handle-uri-activation

            var xmlString =
$"""
<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<Package IgnorableNamespaces="uap rescap desktop desktop2 build" xmlns="http:
/schemas.microsoft.com/appx/manifest/foundation/windows10" xmlns:uap="http:
/schemas.microsoft.com/appx/manifest/uap/windows10" xmlns:rescap="http:
/schemas.microsoft.com/appx/manifest/foundation/windows10/restrictedcapabilities" xmlns:desktop="http:
/schemas.microsoft.com/appx/manifest/desktop/windows10" xmlns:desktop2="http:
/schemas.microsoft.com/appx/manifest/desktop/windows10/2" xmlns:build="http:
/schemas.microsoft.com/developer/appx/2015/build">
  <Identity Name="{IdentityName}" Publisher="{Publisher}" 
Version="{version4}" ProcessorArchitecture="{processorArchitecture.ToString().ToLowerInvariant()}"/>
  <Properties>
    <DisplayName>{DisplayName}</DisplayName>
    <PublisherDisplayName>{PublisherDisplayName}</PublisherDisplayName>
    <Logo>images\StoreLogo.png</Logo>
  </Properties>
  <Dependencies>
    <TargetDeviceFamily Name="Windows.Universal" MinVersion="10.0.17763.0" MaxVersionTested="10.0.19041.0"/>
    <TargetDeviceFamily Name="Windows.Desktop" MinVersion="10.0.17763.0" MaxVersionTested="10.0.19041.0"/>
  </Dependencies>
  <Resources>
    <Resource Language="zh-CN"/>
    <Resource uap:Scale="200"/>
  </Resources>
  <Applications>
    <Application Id="App" Executable="Steam++.exe" EntryPoint="Windows.FullTrustApplication">
      <uap:VisualElements DisplayName="Watt Toolkit" Description="「Watt Toolkit」是一个开源跨平台的多功能游戏工具箱，此工具的大部分功能都是需要您下载安装 Steam 才能使用。" BackgroundColor="transparent" Square150x150Logo="images\Square150x150Logo.png" Square44x44Logo="images\Square44x44Logo.png">
        <uap:DefaultTile Wide310x150Logo="images\Wide310x150Logo.png" Square71x71Logo="images\SmallTile.png" Square310x310Logo="images\LargeTile.png" ShortName="{DisplayName}">
          <uap:ShowNameOnTiles>
            <uap:ShowOn Tile="square150x150Logo"/>
            <uap:ShowOn Tile="wide310x150Logo"/>
            <uap:ShowOn Tile="square310x310Logo"/>
          </uap:ShowNameOnTiles>
        </uap:DefaultTile>
        <uap:SplashScreen Image="images\SplashScreen.png"/>
        <uap:InitialRotationPreference>
          <uap:Rotation Preference="landscape"/>
        </uap:InitialRotationPreference>
        <uap:LockScreen BadgeLogo="images\BadgeLogo.png" Notification="badgeAndTileText"/>
      </uap:VisualElements>
      <Extensions>
        <desktop:Extension Category="windows.fullTrustProcess" Executable="Steam++.exe"/>
        <desktop:Extension Category="windows.startupTask" Executable="Steam++.exe" EntryPoint="Windows.FullTrustApplication">
          <desktop:StartupTask TaskId="BootAutoStartTask" Enabled="true" DisplayName="Steam++ System Boot Run"/>
        </desktop:Extension>
        <uap:Extension Category="windows.protocol">
            <uap:Protocol Name="spp">
                <uap:Logo>Images\Square44x44Logo.png</uap:Logo>
                <uap:DisplayName>Steam++ URI Scheme</uap:DisplayName>
            </uap:Protocol>
        </uap:Extension>
      </Extensions>
    </Application>
  </Applications>
  <Extensions>
    <desktop2:Extension Category="windows.firewallRules">
      <desktop2:FirewallRules Executable="modules\Accelerator\Steam++.Accelerator.exe">
        <desktop2:Rule Direction="in" IPProtocol="TCP" Profile="all"/>
        <desktop2:Rule Direction="in" IPProtocol="UDP" Profile="all"/>
      </desktop2:FirewallRules>
    </desktop2:Extension>
  </Extensions>
  <Capabilities>
    <Capability Name="internetClient"/>
    <rescap:Capability Name="runFullTrust"/>
    <rescap:Capability Name="allowElevation"/>
  </Capabilities>
</Package>
""";
            var xmlDoc = new XmlDocument();
            xmlDoc.LoadXml(xmlString);
            var xmlStringMini = xmlDoc.InnerXml;
            var xmlFilePath = Path.Combine(rootPublicPath, "AppxManifest.xml");
            File.WriteAllText(xmlFilePath, xmlStringMini);
        }

        [Obsolete]
        public static void GenerateBundleManifestXml(
            string dirPath,
            string version4)
        {
            const string fileName = "BundleManifest.xml";

            
/learn.microsoft.com/zh-cn/uwp/schemas/bundlemanifestschema/bundle-manifest

            var xmlString =
$"""
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<Bundle SchemaVersion="5.0" IgnorableNamespaces="b4 b5" xmlns="http:
/schemas.microsoft.com/appx/2013/bundle" xmlns:b4="http:
/schemas.microsoft.com/appx/2018/bundle" xmlns:b5="http:
/schemas.microsoft.com/appx/2019/bundle">
	<Identity Name="{IdentityName}" Publisher="{Publisher}" Version="{version4}"/>
</Bundle>
""";
            var xmlDoc = new XmlDocument();
            xmlDoc.LoadXml(xmlString);
            var xmlStringMini = xmlDoc.InnerXml;
            var xmlFilePath = Path.Combine(dirPath, fileName);
            File.WriteAllText(xmlFilePath, xmlStringMini);
        }

        
/ </summary>
        
/learn.microsoft.com/zh-cn/windows/msix/package/packaging-layout

        
/schemas.microsoft.com/appx/makeappx/2017">
        
/        <File DestinationPath="*" SourcePath="{2}"/>
        
/      </Files>
        
/    </Package>
        
/  </PackageFamily>
        
/</PackagingLayout>
        
/timestamp.digicert.com";

        public const string pfxFilePath_MSStore_CodeSigning = @"C:\MSStore_CodeSigning.pfx";
        public const string pfxFilePath_BeyondDimension_CodeSigning = @"C:\BeyondDimension_CodeSigning.pfx";
        public const string pfxFilePath_HSM_CodeSigning = "DBE4005A4E9371BB8621CD481CD124F8865621C9";

        public static void Start(
            bool force_sign,
            string fileName,
            string? pfxFilePath = null,
            string? workingDirectory = null)
        {
            if (pfxFilePath != pfxFilePath_MSStore_CodeSigning)
                return;

            ProcessStartInfo psi;
            switch (pfxFilePath)
            {
                case pfxFilePath_HSM_CodeSigning:
                    {
                        psi = new ProcessStartInfo
                        {
                            FileName = GetSignToolPath(),
                            UseShellExecute = false,
                            Arguments =
$"""
sign /fd SHA256 /sha1 {pfxFilePath_HSM_CodeSigning} /tr {timestamp_url} /td SHA256 {fileName}
""",
                        };
                    }
                    break;
                default:
                    {
                        pfxFilePath ??= pfxFilePath_BeyondDimension_CodeSigning;
                        var pwdTxtPath = $"{pfxFilePath}.txt";

                        if (!File.Exists(pwdTxtPath))
                        {
                            if (force_sign) throw new FileNotFoundException(null, pwdTxtPath);
                            return; 
/ 验证平台兼容性
                        var pwdS = Encoding.UTF8.GetString(pwd);
                        psi = new ProcessStartInfo
                        {
                            FileName = GetSignToolPath(),
                            UseShellExecute = false,
                            Arguments =
           $"""
            sign /a /fd SHA256 /f "{pfxFilePath}" /p "{pwdS}" /tr {timestamp_url} /td SHA256 {fileName}
            """,
                        };
                    }
                    break;
            }
            if (!string.IsNullOrWhiteSpace(workingDirectory))
                psi.WorkingDirectory = workingDirectory;
            ProcessHelper.StartAndWaitForExit(psi);
        }
    }

    
/ </summary>
    
/ <param name="filePath"></param>
    
/ <returns></returns>
    public static bool IsDigitalSigned(string filePath)
    {
        
/github.com/PowerShell/PowerShell/blob/v7.2.4/src/Microsoft.PowerShell.Security/security/SignatureCommands.cs#L269-L282
        var signature = SignatureHelper.GetSignature(filePath, null);
        var r = signature != null &&
            signature.SignerCertificate != null &&
            (signature.Status != SignatureStatus.NotSigned);
        return r;
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\Helpers\ObfuscarHelper.cs
/ dotnet tool install --global Obfuscar.GlobalTool

    const string configFileName = "Obfuscar.xml";

    static void WriteConfig(string dirPath)
    {
        var xml =
$"""
<?xml version='1.0'?>
<Obfuscator>
  <!-- 输入的工作路径，采用如约定的 Windows 下的路径表示法，如以下表示当前工作路径 -->
  <!-- 推荐使用当前工作路径，因为 DLL 的混淆过程，需要找到 DLL 的所有依赖。刚好当前工作路径下，基本都能满足条件 -->
  <Var name="InPath" value="." />
  <!-- 混淆之后的输出路径，如下面代码，设置为当前工作路径下的 Obfuscar 文件夹 -->
  <!-- 混淆完成之后的新 DLL 将会存放在此文件夹里 -->
  <Var name="OutPath" value=".\Obfuscar" />
  <!-- 以下的都是细节的配置，配置如何进行混淆 -->

  <!-- 使用 KeepPublicApi 配置是否保持公开的 API 不进行混淆签名，如公开的类型公开的方法等等，就不进行混淆签名了 -->
  <!-- 语法的写法就是 name 表示某个开关，而 value 表示值 -->
  <!-- 对于大部分的库来说，设置公开的 API 不进行混淆是符合预期的 -->
  <Var name="KeepPublicApi" value="false" />
  <!-- 设置 HidePrivateApi 为 true 表示，对于私有的 API 进行隐藏，隐藏也就是混淆的意思 -->
  <!-- 可以通过后续的配置，设置混淆的方式，例如使用 ABC 字符替换，或者使用不可见的 Unicode 代替 -->
  <Var name="HidePrivateApi" value="true" />
  <!-- 设置 HideStrings 为 true 可以设置是否将使用的字符串进行二次编码 -->
  <!-- 由于进行二次编码，将会稍微伤一点点性能，二次编码需要在运行的时候，调用 Encoding 进行转换为字符串 -->
  <Var name="HideStrings" value="false" />
  <!-- 设置 UseUnicodeNames 为 true 表示使用不可见的 Unicode 字符代替原有的命名，通过此配置，可以让反编译看到的类和命名空间和成员等内容都是不可见的字符 -->
  <Var name="UseUnicodeNames" value="false" />
  <Var name="UseKoreanNames" value="true" />
  <!-- 是否复用命名，设置为 true 的时候，将会复用命名，如在不同的类型里面，对字段进行混淆，那么不同的类型的字段可以是重名的 -->
  <!-- 设置为 false 的时候，全局将不会有重复的命名 -->
  <Var name="ReuseNames" value="true" />
  <!-- 配置是否需要重命名字段，默认配置了 HidePrivateApi 为 true 将都会打开重命名字段，因此这个配置的存在只是用来配置为 false 表示不要重命名字段 -->
  <Var name="RenameFields" value="true" />
  <!-- 是否需要重新生成调试信息，生成 PDB 符号文件 -->
  <Var name="RegenerateDebugInfo" value="false" />
  <Var name="OptimizeMethods" value="true" />
  <Var name="SuppressIldasm" value="true" />
  <Var name="KeyFile" value="{Path.Combine(ProjectUtils.ProjPath, "WattToolkit.snk")}" />
  <!-- 需要进行混淆的程序集，可以传入很多个，如传入一排排 -->
  <!-- <Module file="$(InPath)\Lib1.dll" /> -->
  <!-- <Module file="$(InPath)\Lib2.dll" /> -->
  <Module file="$(InPath)\Steam++.exe" />
</Obfuscator>
""";

        File.WriteAllBytes(Path.Combine(dirPath, configFileName), Encoding.UTF8.GetBytes(xml));
    }

    public static void Start(string dirPath)
    {
        WriteConfig(dirPath);

        var psi = DotNetCLIHelper.GetProcessStartInfo(AppContext.BaseDirectory);
        psi.Arguments = "tool install --global Obfuscar.GlobalTool";
        ProcessHelper.StartAndWaitForExit(psi, ignoreExitCode: true);

        psi = new ProcessStartInfo
        {
            FileName = "obfuscar.console.exe",
            UseShellExecute = false,
            Arguments = configFileName,
            WorkingDirectory = dirPath,
        };
        ProcessHelper.StartAndWaitForExit(psi);

        var oldFilePath = Path.Combine(dirPath, "Steam++.exe");
        var newFilePath = Path.Combine(dirPath, "Obfuscar", "Steam++.exe");
        File.Delete(oldFilePath);
        File.Move(newFilePath, oldFilePath);
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\Models\AppPublishFileInfo.cs
/ </summary>
[MP2Obj(SerializeLayout.Explicit)]
[DebuggerDisplay("{DebuggerDisplay(),nq}")]
public sealed partial class AppPublishFileInfo
{
    string DebuggerDisplay() => $"{IOPath.GetDisplayFileSizeString(Length)} {Path.GetDirectoryName(FilePath)}";

    [MP2Constructor]
    public AppPublishFileInfo()
    {

    }

    
/ </summary>
    [MP2Key(0)]
    public string FilePath { get; set; } = string.Empty;

    
/ </summary>
    [MP2Key(1)]
    public string RelativePath { get; set; } = string.Empty;

    
/ </summary>
    [MP2Key(2)]
    public string SHA256 { get; set; } = string.Empty;

    
/ </summary>
    [MP2Key(3)]
    public string SHA384 { get; set; } = string.Empty;

    
/ </summary>
    [MP2Key(4)]
    public string FileEx { get; set; } = string.Empty;

    
/ </summary>
    [MP2Key(5)]
    public string SignatureSHA256 { get; set; } = string.Empty;

    
/ </summary>
    [MP2Key(6)]
    public string SignatureSHA384 { get; set; } = string.Empty;

    
/ </summary>
    [MP2Key(7)]
    public long Length { get; set; }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\Models\AppPublishInfo.cs
/ </summary>
[MP2Obj(SerializeLayout.Explicit)]
[DebuggerDisplay("{DebuggerDisplay(),nq}")]
public sealed partial class AppPublishInfo
{
    string DebuggerDisplay() => $"{Platform} {Architecture} {DeviceIdiom} {DeploymentMode} {Path.GetDirectoryName(DirectoryPath)}";

    
/ </summary>
    [MP2Key(0)]
    public Architecture Architecture { get; set; }

    
/ </summary>
    [MP2Key(1)]
    public Platform Platform { get; set; }

    
/ </summary>
    [MP2Key(2)]
    public DeviceIdiom DeviceIdiom { get; set; }

    
/ </summary>
    [MP2Key(3)]
    public DeploymentMode DeploymentMode { get; set; }

    
/ </summary>
    [MP2Key(4)]
    public string DirectoryPath { get; set; } = string.Empty;

    
/ </summary>
    [MP2Key(5)]
    public Dictionary<CloudFileType, AppPublishFileInfo> SingleFile { get; set; } = new();

    
/ </summary>
    [MP2Key(6)]
    public List<AppPublishFileInfo> Files { get; set; } = new();

    [MP2Key(7)]
    public string RuntimeIdentifier { get; set; } = "";
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\Models\MacOSBuildingUniversalBinaryInfo.cs
/ </summary>

/ <param name="Arm64DiffX64">Arm64 与 X64 的差异文件相对路径</param>

/ <param name="X64DiffArm64">X64 与 Arm64 的差异文件相对路径</param>

/ <param name="Arm64">扫描的 Arm64 文件信息</param>

/ <param name="X64">扫描的 X64 文件信息</param>
public record class MacOSBuildingUniversalBinaryInfo(
    HashSet<string> Arm64DiffX64,
    HashSet<string> X64DiffArm64,
    AppPublishInfo Arm64,
    AppPublishInfo X64)
{
    public override string ToString()
    {
        var str = JsonSerializer.Serialize(this,
            MacOSBuildingUniversalBinaryInfoContext.Default.MacOSBuildingUniversalBinaryInfo);
        return str;
    }
}

[JsonSourceGenerationOptions(WriteIndented = true)]
[JsonSerializable(typeof(MacOSBuildingUniversalBinaryInfo))]
internal partial class MacOSBuildingUniversalBinaryInfoContext : JsonSerializerContext
{

}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\Models\BsdiffPatch\AppPublishPatchBundleInfo.cs
/ </summary>
[MP2Obj(SerializeLayout.Explicit)]
[DebuggerDisplay("{DebuggerDisplay(),nq}")]
public sealed partial class AppPublishPatchBundleInfo
{
    string DebuggerDisplay() => $"{OldAppVer}-{NewAppVer} {SHA384} {IOPath.GetDisplayFileSizeString(Length)}";

    
/ </summary>
    [MP2Key(0)]
    public string OldAppVer { get; set; } = string.Empty;

    
/ </summary>
    [MP2Key(1)]
    public string NewAppVer { get; set; } = string.Empty;

    
/ </summary>
    [MP2Key(2)]
    public string SHA384 { get; set; } = string.Empty;

    
/ </summary>
    [MP2Key(3)]
    public long Length { get; set; }

    
/ </summary>
    [MP2Key(4)]
    public string FilePath { get; set; } = string.Empty;

    
/ </summary>
    [MP2Key(5)]
    public Dictionary<string, PatchBundleInfo?> PatchData { get; set; } = new();
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\Models\BsdiffPatch\AppVer.cs
/ </summary>
    public string Ver { get; set; } = "";

    
/ </summary>
    public DateTimeOffset Published { get; set; }

    
/ </summary>
    public ClientPlatform Platform { get; set; }

    public IList<AppVerFileList>? FileList { get; set; }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\Models\BsdiffPatch\AppVerFile.cs
/ </summary>
    public string SHA384 { get; set; } = "";

    
/ </summary>
    public DateTimeOffset Published { get; set; }

    
/ </summary>
    public byte[] DataRaw { get; set; } = Array.Empty<byte>();

    
/ </summary>
    public long Length { get; set; }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\Models\BsdiffPatch\AppVerFileList.cs
/ </summary>
    public Guid AppVerId { get; set; }

    
/ </summary>
    public ClientPlatform Platform { get; set; }

    
/ </summary>
    public byte[] FileListRaw { get; set; } = Array.Empty<byte>();

    public AppVer? AppVerInfo { get; set; }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\Models\BsdiffPatch\PatchBundleInfo.cs
/ </summary>
[MP2Obj(SerializeLayout.Explicit)]
public sealed partial class PatchBundleInfo
{
    
/ </summary>
    [MP2Key(0)]
    public string? SHA384 { get; set; }

    
/ </summary>
    [MP2Key(1)]
    public byte[]? PatchData { get; set; }

    
/ </summary>
    [MP2Key(2)]
    public bool IsFullOrPatch { get; set; }

}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\MSBuild\ITaskItem.cs
/ </summary>
    string ItemSpec { get; set; }

    
/ </summary>
    ICollection<string> MetadataNames { get; }

    
/ </summary>
    
/ <param name="metadataName"></param>
    
/ <returns></returns>
    string GetMetadata(string metadataName);
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\MSBuild\MessageImportance.cs
/ </summary>
[Serializable]
public enum MessageImportance
{
    
/ </summary>
    High,

    
/ </summary>
    Normal,

    
/ </summary>
    Low,
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\MSBuild\Task.cs
/ </summary>
public abstract class Task
{
    
/ </summary>
    public TaskLoggingHelper Log => TaskLoggingHelper.Instance;

    
/ </summary>
    
/ <returns></returns>
    public abstract bool Execute();
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\MSBuild\TaskLoggingHelper.cs
/ </summary>
    
/ <param name="message"></param>
    
/ <param name="messageArgs"></param>
    public void LogWarning(string message, params object[] messageArgs)
    {
        Log.Warn(TAG, message, messageArgs);
    }

    
/ </summary>
    
/ <param name="importance"></param>
    
/ <param name="message"></param>
    
/ <param name="messageArgs"></param>
    public void LogMessage(MessageImportance importance, string message, params object[] messageArgs)
    {
        switch (importance)
        {
            case MessageImportance.High:
                Log.Warn(TAG, message, messageArgs);
                break;
            case MessageImportance.Normal:
                Log.Info(TAG, message, messageArgs);
                break;
            case MessageImportance.Low:
                Log.Debug(TAG, message, messageArgs);
                break;
        }
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\PowerShell\System.Management.Automation\engine\Utils.cs
/github.com/PowerShell/PowerShell/blob/v7.2.4/src/System.Management.Automation/engine/Utils.cs

using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.Linq;

/ </summary>
    internal static class Utils
    {
        
/ </summary>
        
/ <param name="d">The value to convert.</param>
        
/ <returns>Returns a BigInteger value equivalent to the input value rounded to nearest integer.</returns>
        internal static BigInteger AsBigInt(this double d) => new BigInteger(Math.Round(d));

        internal static bool TryCast(BigInteger value, out byte b)
        {
            if (value < byte.MinValue || value > byte.MaxValue)
            {
                b = 0;
                return false;
            }

            b = (byte)value;
            return true;
        }

        internal static bool TryCast(BigInteger value, out sbyte sb)
        {
            if (value < sbyte.MinValue || value > sbyte.MaxValue)
            {
                sb = 0;
                return false;
            }

            sb = (sbyte)value;
            return true;
        }

        internal static bool TryCast(BigInteger value, out short s)
        {
            if (value < short.MinValue || value > short.MaxValue)
            {
                s = 0;
                return false;
            }

            s = (short)value;
            return true;
        }

        internal static bool TryCast(BigInteger value, out ushort us)
        {
            if (value < ushort.MinValue || value > ushort.MaxValue)
            {
                us = 0;
                return false;
            }

            us = (ushort)value;
            return true;
        }

        internal static bool TryCast(BigInteger value, out int i)
        {
            if (value < int.MinValue || value > int.MaxValue)
            {
                i = 0;
                return false;
            }

            i = (int)value;
            return true;
        }

        internal static bool TryCast(BigInteger value, out uint u)
        {
            if (value < uint.MinValue || value > uint.MaxValue)
            {
                u = 0;
                return false;
            }

            u = (uint)value;
            return true;
        }

        internal static bool TryCast(BigInteger value, out long l)
        {
            if (value < long.MinValue || value > long.MaxValue)
            {
                l = 0;
                return false;
            }

            l = (long)value;
            return true;
        }

        internal static bool TryCast(BigInteger value, out ulong ul)
        {
            if (value < ulong.MinValue || value > ulong.MaxValue)
            {
                ul = 0;
                return false;
            }

            ul = (ulong)value;
            return true;
        }

        internal static bool TryCast(BigInteger value, out decimal dm)
        {
            if (value < (BigInteger)decimal.MinValue || (BigInteger)decimal.MaxValue < value)
            {
                dm = 0;
                return false;
            }

            dm = (decimal)value;
            return true;
        }

        internal static bool TryCast(BigInteger value, out double db)
        {
            if (value < (BigInteger)double.MinValue || (BigInteger)double.MaxValue < value)
            {
                db = 0;
                return false;
            }

            db = (double)value;
            return true;
        }

        
/ </summary>
        
/ <param name="digits">Span or string of binary digits. Assumes all digits are either 1 or 0.</param>
        
/ </param>
        
/ <returns>Returns the value of the binary string as a BigInteger.</returns>
        internal static BigInteger ParseBinary(ReadOnlySpan<char> digits, bool unsigned)
        {
            if (!unsigned)
            {
                if (digits[0] == '0')
                {
                    unsigned = true;
                }
                else
                {
                    switch (digits.Length)
                    {
                        
/ Calculate number of 8-bit bytes needed to hold the input,  rounded up to next whole number.
            int outputByteCount = (digits.Length + 7) / 8;
            Span<byte> outputBytes = outputByteCount <= MaxStackAllocation ? stackalloc byte[outputByteCount] : new byte[outputByteCount];
            int outputByteIndex = outputBytes.Length - 1;

            
/ </summary>
        internal static readonly string[] AllowedEditionValues = { "Desktop", "Core" };

        
/ </summary>
        
/<param name="arg"> arg to check </param>
        
/<param name="argName"> name of the arg </param>
        
/<returns> Does not return a value.</returns>
        
/ </summary>
        
/<param name="arg"> arg to check </param>
        
/<param name="argName"> name of the arg </param>
        
/<returns> Does not return a value.</returns>
        internal static void CheckArgForNullOrEmpty(string arg, string argName)
        {
            if (arg == null)
            {
                throw PSTraceSource.NewArgumentNullException(argName);
            }
            else if (arg.Length == 0)
            {
                throw PSTraceSource.NewArgumentException(argName);
            }
        }

        
/ </summary>
        
/<param name="arg"> arg to check </param>
        
/<param name="argName"> name of the arg </param>
        
/<returns> Does not return a value.</returns>
        internal static void CheckArgForNull(object arg, string argName)
        {
            if (arg == null)
            {
                throw PSTraceSource.NewArgumentNullException(argName);
            }
        }

        
/ </summary>
        
/<param name="arg"> arg to check </param>
        
/<param name="argName"> name of the arg </param>
        
/<returns> Does not return a value.</returns>
        internal static void CheckSecureStringArg(SecureString arg, string argName)
        {
            if (arg == null)
            {
                throw PSTraceSource.NewArgumentNullException(argName);
            }
        }

        [ArchitectureSensitive]
        internal static string GetStringFromSecureString(SecureString ss)
        {
            IntPtr p = IntPtr.Zero;
            string s = null;

            try
            {
                p = Marshal.SecureStringToCoTaskMemUnicode(ss);
                s = Marshal.PtrToStringUni(p);
            }
            finally
            {
                if (p != IntPtr.Zero)
                {
                    Marshal.ZeroFreeCoTaskMemUnicode(p);
                }
            }

            return s;
        }

        
/ </summary>
        
/ <returns></returns>
        
/ </summary>
        
/ </summary>
        
/ </returns>
        
/ </summary>
        
/ </returns>
        
/ </summary>
        
/ </summary>
        internal static bool IsWinPEHost()
        {
#if !UNIX
            RegistryKey winPEKey = null;

            try
            {
                
/ </summary>
        
/ <returns>String.</returns>
        
/ </remarks>
        
/ </summary>
        
/ <param name="versionString">String representing version.</param>
        
/ <returns>A Version Object.</returns>
        internal static Version StringToVersion(string versionString)
        {
            
/ </summary>
        
/ <param name="ver">Version to check.</param>
        
/ <returns>True if supported, false otherwise.</returns>
        
/ </summary>
        
/ <param name="checkVersion">Version to check.</param>
        
/ <returns>True if supported, false otherwise.</returns>
        
/ </summary>
        
/ <param name="checkEdition">Edition to check.</param>
        
/ <returns>True if supported, false otherwise.</returns>
        
/ </summary>
        
/ <param name="editions">The PowerShell editions to check compatibility with.</param>
        
/ <returns>True if the edition is supported by this runtime, false otherwise.</returns>
        
/ </summary>
        
/ <param name="editionValue">Edition value to check.</param>
        
/ <returns>True if allowed, false otherwise.</returns>
        internal static bool IsValidPSEditionValue(string editionValue)
        {
            return AllowedEditionValues.Contains(editionValue, StringComparer.OrdinalIgnoreCase);
        }

        #endregion

        
/ </summary>
        internal const string DefaultPowerShellShellID = "Microsoft.PowerShell";

        
/ </summary>
        internal const string ProductNameForDirectory = "PowerShell";

        
/ </summary>
        internal const string WslRootPath = @"\\wsl$";

        
/ </summary>
        internal static readonly string ModuleDirectory = Path.Combine(ProductNameForDirectory, "Modules");

        
/ </summary>
        
/ </summary>
        
/ <param name="instance">Policy object that will be filled with values from registry.</param>
        
/ <param name="instanceType">Type of policy object used.</param>
        
/ <param name="gpoKey">Registry key that has policy settings.</param>
        
/ <returns>True if any property was successfully set on the policy object.</returns>
        
/ </summary>
        
/ </summary>
        
/ </summary>
        internal const string ScheduledJobModuleName = "PSScheduledJob";

        
/ Returns modules (either loaded or in available) that match pattern <paramref name="module"/>.
        
/ </summary>
        
/ <param name="module"></param>
        
/ <param name="context"></param>
        
/ </returns>
        
/ Returns modules (either loaded or in available) that match FullyQualifiedName <paramref name="fullyQualifiedName"/>.
        
/ </summary>
        
/ <param name="fullyQualifiedName"></param>
        
/ <param name="context"></param>
        
/ </returns>
        
/ </summary>
        
/ <param name="impersonatedIdentity">Current impersonated Windows identity or null.</param>
        
/ <returns>True if current identity is impersonated.</returns>
        internal static bool TryGetWindowsImpersonatedIdentity(out WindowsIdentity impersonatedIdentity)
        {
            WindowsIdentity currentIdentity;
            if (TryGetWindowsCurrentIdentity(out currentIdentity) && (currentIdentity.ImpersonationLevel == TokenImpersonationLevel.Impersonation))
            {
                impersonatedIdentity = currentIdentity;
                return true;
            }

            impersonatedIdentity = null;
            return false;
        }
#endif

        internal static bool IsAdministrator()
        {
            
/ </summary>
        
/ <param name="mutex">The mutex to wait on. If it is null, a new one will be created.</param>
        
/ <param name="initializer">The initializer to use to recreate the mutex.</param>
        
/ <returns>A working mutex. If the mutex was abandoned, a new one is created to replace it.</returns>
        internal static Mutex SafeWaitMutex(Mutex mutex, MutexInitializer initializer)
        {
            try
            {
                mutex.WaitOne();
            }
            catch (AbandonedMutexException)
            {
                
/ </summary>
        
/ <param name="identityToImpersonate">Windows identity to impersonate or null.</param>
        
/ <param name="threadProc">Thread procedure for thread.</param>
        
/ <param name="state">Optional state for thread procedure.</param>
        internal static void QueueWorkItemWithImpersonation(
            WindowsIdentity identityToImpersonate,
            WaitCallback threadProc,
            object state)
        {
            object[] args = new object[3];
            args[0] = identityToImpersonate;
            args[1] = threadProc;
            args[2] = state;
            Threading.ThreadPool.QueueUserWorkItem(WorkItemCallback, args);
        }

        private static void WorkItemCallback(object callBackArgs)
        {
            object[] args = callBackArgs as object[];
            WindowsIdentity identityToImpersonate = args[0] as WindowsIdentity;
            WaitCallback callback = args[1] as WaitCallback;
            object state = args[2];

            if (identityToImpersonate != null)
            {
                WindowsIdentity.RunImpersonated(
                    identityToImpersonate.AccessToken,
                    () => callback(state));
                return;
            }

            callback(state);
        }
#endif

        
/ </summary>
        
/ <param name="commandName"></param>
        
/ <param name="moduleName"></param>
        
/ <returns>Command name and as appropriate Module name in out parameter.</returns>
        internal static string ParseCommandName(string commandName, out string moduleName)
        {
            var names = commandName.Split(Separators.Backslash, 2);
            if (names.Length == 2)
            {
                moduleName = names[0];
                return names[1];
            }

            moduleName = null;
            return commandName;
        }

        internal static ReadOnlyCollection<T> EmptyReadOnlyCollection<T>()
        {
            return EmptyReadOnlyCollectionHolder<T>._instance;
        }

        private static class EmptyReadOnlyCollectionHolder<T>
        {
            internal static readonly ReadOnlyCollection<T> _instance =
                new ReadOnlyCollection<T>(Array.Empty<T>());
        }

        internal static class Separators
        {
            internal static readonly char[] Backslash = new char[] { '\\' };
            internal static readonly char[] Directory = new char[] { '\\', '/' };
            internal static readonly char[] DirectoryOrDrive = new char[] { '\\', '/', ':' };

            internal static readonly char[] Colon = new char[] { ':' };
            internal static readonly char[] Dot = new char[] { '.' };
            internal static readonly char[] Pipe = new char[] { '|' };
            internal static readonly char[] Comma = new char[] { ',' };
            internal static readonly char[] Semicolon = new char[] { ';' };
            internal static readonly char[] StarOrQuestion = new char[] { '*', '?' };
            internal static readonly char[] ColonOrBackslash = new char[] { '\\', ':' };
            internal static readonly char[] PathSeparator = new char[] { Path.PathSeparator };

            internal static readonly char[] QuoteChars = new char[] { '\'', '"' };
            internal static readonly char[] Space = new char[] { ' ' };
            internal static readonly char[] QuotesSpaceOrTab = new char[] { ' ', '\t', '\'', '"' };
            internal static readonly char[] SpaceOrTab = new char[] { ' ', '\t' };
            internal static readonly char[] Newline = new char[] { '\n' };
            internal static readonly char[] CrLf = new char[] { '\r', '\n' };

            
/ </summary>
        internal static bool IsComObject(object obj)
        {
#if UNIX
            return false;
#else
            return obj != null && Marshal.IsComObject(obj);
#endif
        }

        
/ </summary>
        
/ <param name="context">ExecutionContext.</param>
        
/ <returns>Previous language mode or null for no language mode change.</returns>
        
/ <summary>This class is used for internal test purposes.</summary>
    public static class InternalTestHooks
    {
        internal static bool BypassGroupPolicyCaching;
        internal static bool ForceScriptBlockLogging;
        internal static bool UseDebugAmsiImplementation;
        internal static bool BypassAppLockerPolicyCaching;
        internal static bool BypassOnlineHelpRetrieval;
        internal static bool ForcePromptForChoiceDefaultOption;
        internal static bool NoPromptForPassword;
        internal static bool ForceFormatListFixedLabelWidth;

        
/ Stop/Restart/Rename Computer tests
        internal static bool TestStopComputer;
        internal static bool TestWaitStopComputer;
        internal static bool TestRenameComputer;
        internal static int TestStopComputerResults;
        internal static int TestRenameComputerResults;

        
/ <summary>This member is used for internal test purposes.</summary>
        public static void SetTestHook(string property, object value)
        {
            var fieldInfo = typeof(InternalTestHooks).GetField(property, BindingFlags.Static | BindingFlags.NonPublic);
            if (fieldInfo != null)
            {
                fieldInfo.SetValue(null, value);
            }
        }

        
/ </summary>
        
/ <param name="url">The connection URL to reflect in the returned instance's ConnectionString property.</param>
        
/ <param name="clientVersion">The version number to report as the remoting client's PowerShell version.</param>
        
/ <returns>The newly constructed custom PSSenderInfo instance.</returns>
        
/ Provides undo/redo functionality by using 2 instances of <seealso cref="BoundedStack{T}"/>.
    
/ </summary>
    internal class HistoryStack<T>
    {
        private readonly BoundedStack<T> _boundedUndoStack;
        private readonly BoundedStack<T> _boundedRedoStack;

        internal HistoryStack(int capacity)
        {
            _boundedUndoStack = new BoundedStack<T>(capacity);
            _boundedRedoStack = new BoundedStack<T>(capacity);
        }

        internal void Push(T item)
        {
            _boundedUndoStack.Push(item);
            if (RedoCount >= 0)
            {
                _boundedRedoStack.Clear();
            }
        }

        
/ </summary>
        
/ </summary>
        
/ </summary>
    internal class BoundedStack<T> : LinkedList<T>
    {
        private readonly int _capacity;

        
/ </summary>
        
/ <param name="capacity"></param>
        internal BoundedStack(int capacity)
        {
            _capacity = capacity;
        }

        
/ </summary>
        
/ <param name="item"></param>
        internal void Push(T item)
        {
            this.AddFirst(item);

            if (this.Count > _capacity)
            {
                this.RemoveLast();
            }
        }

        
/ </summary>
        
/ <returns></returns>
        
/ </summary>
    internal sealed class ReadOnlyBag<T> : IEnumerable
    {
        private readonly HashSet<T> _hashset;

        
/ </summary>
        internal ReadOnlyBag(HashSet<T> hashset)
        {
            if (hashset == null)
            {
                throw new ArgumentNullException(nameof(hashset));
            }

            _hashset = hashset;
        }

        
/ </summary>
        public int Count => _hashset.Count;

        
/ </summary>
        public bool IsReadOnly => true;

        
/ </summary>
        public bool Contains(T item) => _hashset.Contains(item);

        
/ </summary>
        public IEnumerator GetEnumerator() => _hashset.GetEnumerator();

        
/ </summary>
        internal static readonly ReadOnlyBag<T> Empty = new ReadOnlyBag<T>(new HashSet<T>(capacity: 0));
    }

    
/ </summary>
    internal static class Requires
    {
        internal static void NotNull(object value, string paramName)
        {
            if (value == null)
            {
                throw new ArgumentNullException(paramName);
            }
        }

        internal static void NotNullOrEmpty(string value, string paramName)
        {
            if (string.IsNullOrEmpty(value))
            {
                throw new ArgumentNullException(paramName);
            }
        }

        internal static void NotNullOrEmpty(ICollection value, string paramName)
        {
            if (value == null || value.Count == 0)
            {
                throw new ArgumentNullException(paramName);
            }
        }

        internal static void Condition([DoesNotReturnIf(false)] bool precondition, string paramName)
        {
            if (!precondition)
            {
                throw new ArgumentException(paramName);
            }
        }
    }
}
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Tools.Publish\PowerShell\System.Management.Automation\engine\Utils.cs
UNIX
UNIX
UNIX
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\PowerShell\System.Management.Automation\resources\Authenticode.Designer.cs
/ </auto-generated>

/ </summary>
    
/ (以 /str 作为命令选项)，或重新生成 VS 项目。
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Authenticode {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Authenticode() {
        }
        
        
/ </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("BD.WTTS.Client.Tools.Publish.PowerShell.System.Management.Automation.resources.Au" +
                            "thenticode", typeof(Authenticode).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        
/ </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        
/ </summary>
        internal static string AuthenticodePromptCaption {
            get {
                return ResourceManager.GetString("AuthenticodePromptCaption", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string AuthenticodePromptText {
            get {
                return ResourceManager.GetString("AuthenticodePromptText", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string AuthenticodePromptText_UnknownPublisher {
            get {
                return ResourceManager.GetString("AuthenticodePromptText_UnknownPublisher", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string CertNotGoodForSigning {
            get {
                return ResourceManager.GetString("CertNotGoodForSigning", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string Choice_AlwaysRun {
            get {
                return ResourceManager.GetString("Choice_AlwaysRun", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string Choice_AlwaysRun_Help {
            get {
                return ResourceManager.GetString("Choice_AlwaysRun_Help", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string Choice_DoNotRun {
            get {
                return ResourceManager.GetString("Choice_DoNotRun", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string Choice_DoNotRun_Help {
            get {
                return ResourceManager.GetString("Choice_DoNotRun_Help", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string Choice_NeverRun {
            get {
                return ResourceManager.GetString("Choice_NeverRun", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string Choice_NeverRun_Help {
            get {
                return ResourceManager.GetString("Choice_NeverRun_Help", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string Choice_RunOnce {
            get {
                return ResourceManager.GetString("Choice_RunOnce", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string Choice_RunOnce_Help {
            get {
                return ResourceManager.GetString("Choice_RunOnce_Help", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string Choice_Suspend {
            get {
                return ResourceManager.GetString("Choice_Suspend", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string Choice_Suspend_Help {
            get {
                return ResourceManager.GetString("Choice_Suspend_Help", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string InvalidHashAlgorithm {
            get {
                return ResourceManager.GetString("InvalidHashAlgorithm", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string Reason_DisallowedBySafer {
            get {
                return ResourceManager.GetString("Reason_DisallowedBySafer", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string Reason_DoNotRun {
            get {
                return ResourceManager.GetString("Reason_DoNotRun", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string Reason_FileContentUnavailable {
            get {
                return ResourceManager.GetString("Reason_FileContentUnavailable", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string Reason_NeverRun {
            get {
                return ResourceManager.GetString("Reason_NeverRun", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string Reason_NotTrusted {
            get {
                return ResourceManager.GetString("Reason_NotTrusted", resourceCulture);
            }
        }
        
        
/go.microsoft.com/fwlink/?LinkID=135170. 的本地化字符串。
        
/ </summary>
        internal static string Reason_RestrictedMode {
            get {
                return ResourceManager.GetString("Reason_RestrictedMode", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string Reason_Unknown {
            get {
                return ResourceManager.GetString("Reason_Unknown", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string RemoteFilePromptCaption {
            get {
                return ResourceManager.GetString("RemoteFilePromptCaption", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string RemoteFilePromptText {
            get {
                return ResourceManager.GetString("RemoteFilePromptText", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string TimeStampUrlRequired {
            get {
                return ResourceManager.GetString("TimeStampUrlRequired", resourceCulture);
            }
        }
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\PowerShell\System.Management.Automation\resources\AutomationExceptions.Designer.cs
/ </auto-generated>

/ </summary>
    
/ (以 /str 作为命令选项)，或重新生成 VS 项目。
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class AutomationExceptions {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal AutomationExceptions() {
        }
        
        
/ </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("BD.WTTS.Client.Tools.Publish.PowerShell.System.Management.Automation.resources.Au" +
                            "tomationExceptions", typeof(AutomationExceptions).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        
/ </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        
/ </summary>
        internal static string Argument {
            get {
                return ResourceManager.GetString("Argument", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string ArgumentNull {
            get {
                return ResourceManager.GetString("ArgumentNull", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string ArgumentOutOfRange {
            get {
                return ResourceManager.GetString("ArgumentOutOfRange", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string CanConvertOneClauseOnly {
            get {
                return ResourceManager.GetString("CanConvertOneClauseOnly", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string CanConvertOneOutputErrorRedir {
            get {
                return ResourceManager.GetString("CanConvertOneOutputErrorRedir", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string CanOnlyConvertOnePipeline {
            get {
                return ResourceManager.GetString("CanOnlyConvertOnePipeline", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string CantConvertEmptyPipeline {
            get {
                return ResourceManager.GetString("CantConvertEmptyPipeline", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string CantConvertPipelineStartsWithExpression {
            get {
                return ResourceManager.GetString("CantConvertPipelineStartsWithExpression", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string CantConvertScriptBlockToOpenGenericType {
            get {
                return ResourceManager.GetString("CantConvertScriptBlockToOpenGenericType", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string CantConvertScriptBlockWithNoContext {
            get {
                return ResourceManager.GetString("CantConvertScriptBlockWithNoContext", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string CantConvertScriptBlockWithTrap {
            get {
                return ResourceManager.GetString("CantConvertScriptBlockWithTrap", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string CantConvertWithCommandInvocations {
            get {
                return ResourceManager.GetString("CantConvertWithCommandInvocations", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string CantConvertWithDotSourcing {
            get {
                return ResourceManager.GetString("CantConvertWithDotSourcing", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string CantConvertWithDynamicExpression {
            get {
                return ResourceManager.GetString("CantConvertWithDynamicExpression", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string CantConvertWithNonConstantExpression {
            get {
                return ResourceManager.GetString("CantConvertWithNonConstantExpression", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string CantConvertWithScriptBlockInvocation {
            get {
                return ResourceManager.GetString("CantConvertWithScriptBlockInvocation", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string CantConvertWithScriptBlocks {
            get {
                return ResourceManager.GetString("CantConvertWithScriptBlocks", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string CantConvertWithUndeclaredVariables {
            get {
                return ResourceManager.GetString("CantConvertWithUndeclaredVariables", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string CantGetUsingExpressionValueWithSpecifiedVariableDictionary {
            get {
                return ResourceManager.GetString("CantGetUsingExpressionValueWithSpecifiedVariableDictionary", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string DynamicParametersWrongType {
            get {
                return ResourceManager.GetString("DynamicParametersWrongType", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string HaltCommandException {
            get {
                return ResourceManager.GetString("HaltCommandException", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string InvalidOperation {
            get {
                return ResourceManager.GetString("InvalidOperation", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string InvalidScopeIdArgument {
            get {
                return ResourceManager.GetString("InvalidScopeIdArgument", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string NotImplemented {
            get {
                return ResourceManager.GetString("NotImplemented", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string NotSupported {
            get {
                return ResourceManager.GetString("NotSupported", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string ObjectDisposed {
            get {
                return ResourceManager.GetString("ObjectDisposed", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string ScriptBlockInvokeOnOneClauseOnly {
            get {
                return ResourceManager.GetString("ScriptBlockInvokeOnOneClauseOnly", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string UsingVariableIsUndefined {
            get {
                return ResourceManager.GetString("UsingVariableIsUndefined", resourceCulture);
            }
        }
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\PowerShell\System.Management.Automation\resources\MshSignature.Designer.cs
/ </auto-generated>

/ </summary>
    
/ (以 /str 作为命令选项)，或重新生成 VS 项目。
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class MshSignature {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal MshSignature() {
        }
        
        
/ </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("BD.WTTS.Client.Tools.Publish.PowerShell.System.Management.Automation.resources.Ms" +
                            "hSignature", typeof(MshSignature).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        
/ </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        
/ </summary>
        internal static string MshSignature_HashMismatch {
            get {
                return ResourceManager.GetString("MshSignature_HashMismatch", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string MshSignature_Incompatible {
            get {
                return ResourceManager.GetString("MshSignature_Incompatible", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string MshSignature_Incompatible_HashAlgorithm {
            get {
                return ResourceManager.GetString("MshSignature_Incompatible_HashAlgorithm", resourceCulture);
            }
        }
        
        
/go.microsoft.com/fwlink/?LinkID=135170 的本地化字符串。
        
/ </summary>
        internal static string MshSignature_NotSigned {
            get {
                return ResourceManager.GetString("MshSignature_NotSigned", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string MshSignature_NotSupportedFileFormat {
            get {
                return ResourceManager.GetString("MshSignature_NotSupportedFileFormat", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string MshSignature_NotSupportedFileFormat_NoExtension {
            get {
                return ResourceManager.GetString("MshSignature_NotSupportedFileFormat_NoExtension", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string MshSignature_NotTrusted {
            get {
                return ResourceManager.GetString("MshSignature_NotTrusted", resourceCulture);
            }
        }
        
        
/ </summary>
        internal static string MshSignature_Valid {
            get {
                return ResourceManager.GetString("MshSignature_Valid", resourceCulture);
            }
        }
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\PowerShell\System.Management.Automation\security\Authenticode.cs
/github.com/PowerShell/PowerShell/blob/v7.2.4/src/System.Management.Automation/security/Authenticode.cs

#pragma warning disable 56523
#pragma warning disable SA1312 
/ </summary>
    public enum SigningOption
    {
        
/ </summary>
        AddOnlyCertificate,

        
/ </summary>
        AddFullCertificateChain,

        
/ </summary>
        AddFullCertificateChainExceptRoot,

        
/ </summary>
        Default = AddFullCertificateChainExceptRoot
    }

    
/ </summary>
    internal static class SignatureHelper
    {
        
/ </summary>
        [Dbg.TraceSource("SignatureHelper",
                          "tracer for SignatureHelper")]
        private static readonly Dbg.PSTraceSource s_tracer =
            Dbg.PSTraceSource.GetTracer("SignatureHelper",
                          "tracer for SignatureHelper");

        
/ </summary>
        
/ <param name="option">Option that controls what gets embedded in the signature blob.</param>
        
/ <param name="fileName">Name of file to sign.</param>
        
/ <param name="certificate">Signing cert.</param>
        
/ <param name="timeStampServerUrl">URL of time stamping server.</param>
        
/ algorithm to use.</param>
        
/ <returns>Does not return a value.</returns>
        
/ </exception>
        
/ </exception>
        
/ </exception>
        
/ </exception>
        [ArchitectureSensitive]
        internal static Signature SignFile(SigningOption option,
                                           string fileName,
                                           X509Certificate2 certificate,
                                           string timeStampServerUrl,
                                           string hashAlgorithm)
        {
            bool result = false;
            Signature signature = null;
            IntPtr pSignInfo = IntPtr.Zero;
            DWORD error = 0;
            string hashOid = null;

            Utils.CheckArgForNullOrEmpty(fileName, "fileName");
            Utils.CheckArgForNull(certificate, "certificate");

            
/ ISSUE-2004/05/08-kumarp : there seems to be a bug
                    
/ </summary>
        
/ <param name="fileName">Name of file to check.</param>
        
/ <param name="fileContent">Content of file to check.</param>
        
/ <returns>Signature object.</returns>
        
/ </exception>
        
/ </exception>
        
/ </exception>
        [ArchitectureSensitive]
        internal static Signature GetSignature(string fileName, string? fileContent)
        {
            Signature? signature = null;

            if (fileContent == null)
            {
                
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\PowerShell\System.Management.Automation\security\MshSignature.cs
/github.com/PowerShell/PowerShell/blob/v7.2.4/src/System.Management.Automation/security/MshSignature.cs

using System.ComponentModel;
using System.Management.Automation.Internal;
using System.Security.Cryptography.X509Certificates;

using DWORD = System.UInt32;

namespace System.Management.Automation
{
    internal static class Win32Errors
    {
        internal const DWORD NO_ERROR = 0;
        internal const DWORD E_FAIL = 0x80004005;
        internal const DWORD TRUST_E_NOSIGNATURE = 0x800b0100;
        internal const DWORD TRUST_E_BAD_DIGEST = 0x80096010;
        internal const DWORD TRUST_E_PROVIDER_UNKNOWN = 0x800b0001;
        internal const DWORD TRUST_E_SUBJECT_FORM_UNKNOWN = 0x800B0003;
        internal const DWORD CERT_E_UNTRUSTEDROOT = 0x800b0109;
        internal const DWORD TRUST_E_EXPLICIT_DISTRUST = 0x800B0111;
        internal const DWORD CRYPT_E_BAD_MSG = 0x8009200d;
        internal const DWORD NTE_BAD_ALGID = 0x80090008;
    }

    
/ </summary>
    public enum SignatureStatus
    {
        
/ </summary>
        Valid,

        
/ </summary>
        UnknownError,

        
/ </summary>
        NotSigned,

        
/ </summary>
        HashMismatch,

        
/ </summary>
        NotTrusted,

        
/ </summary>
        NotSupportedFileFormat,

        
/ </summary>
        Incompatible
    }

    
/ </summary>
    public enum SignatureType
    {
        
/ </summary>
        None = 0,

        
/ </summary>
        Authenticode = 1,

        
/ </summary>
        Catalog = 2
    }

    
/ </summary>
    public sealed class Signature
    {
        private string _path;
        private SignatureStatus _status = SignatureStatus.UnknownError;
        private DWORD _win32Error;
        private X509Certificate2 _signerCert;
        private string _statusMessage = string.Empty;
        private X509Certificate2 _timeStamperCert;
        
/            be updated/refreshed).
        
/ </summary>
        public X509Certificate2 SignerCertificate
        {
            get
            {
                return _signerCert;
            }
        }

        
/ </summary>
        public X509Certificate2 TimeStamperCertificate
        {
            get
            {
                return _timeStamperCert;
            }
        }

        
/ </summary>
        public SignatureStatus Status
        {
            get
            {
                return _status;
            }
        }

        
/ </summary>
        public string StatusMessage
        {
            get
            {
                return _statusMessage;
            }
        }

        
/ </summary>
        public string Path
        {
            get
            {
                return _path;
            }
        }

        
/ </summary>
        public SignatureType SignatureType { get; internal set; }

        
/ </summary>
        public bool IsOSBinary { get; internal set; }

        
/ </summary>
        
/ <param name="filePath">This signature is found in this file.</param>
        
/ <param name="error">Win32 error code.</param>
        
/ <param name="signer">Cert of the signer.</param>
        
/ <param name="timestamper">Cert of the time stamper.</param>
        
/ <returns>Constructed object.</returns>
#pragma warning disable CS8618 
/ </summary>
        
/ <param name="filePath">This signature is found in this file.</param>
        
/ <param name="signer">Cert of the signer.</param>
        
/ <returns>Constructed object.</returns>
#pragma warning disable CS8618 
/ </summary>
        
/ <param name="filePath">This signature is found in this file.</param>
        
/ <param name="error">Win32 error code.</param>
        
/ <param name="signer">Cert of the signer.</param>
        
/ <returns>Constructed object.</returns>
#pragma warning disable CS8618 
/ </summary>
        
/ <param name="filePath">This signature is found in this file.</param>
        
/ <param name="error">Win32 error code.</param>
        
/ <returns>Constructed object.</returns>
#pragma warning disable CS8618 
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\PowerShell\System.Management.Automation\security\nativeMethods.cs
/github.com/PowerShell/PowerShell/blob/v7.2.4/src/System.Management.Automation/security/nativeMethods.cs

#pragma warning disable 56523

using System.Runtime.InteropServices;
using System.Security.Cryptography.X509Certificates;
using System.Management.Automation.Internal;
using DWORD = System.UInt32;
using BOOL = System.UInt32;

namespace System.Management.Automation.Security
{
    
/ </Summary>
        public const int SAFER_TOKEN_NULL_IF_EQUAL = 1;

        
/ </Summary>
        public const int SAFER_TOKEN_COMPARE_ONLY = 2;

        
/ </Summary>
        public const int SAFER_TOKEN_MAKE_INERT = 4;

        
/ </Summary>
        public const int SAFER_CRITERIA_IMAGEPATH = 1;

        
/ </Summary>
        public const int SAFER_CRITERIA_NOSIGNEDHASH = 2;

        
/ </Summary>
        public const int SAFER_CRITERIA_IMAGEHASH = 4;

        
/ </Summary>
        public const int SAFER_CRITERIA_AUTHENTICODE = 8;

        
/ </Summary>
        public const int SAFER_CRITERIA_URLZONE = 16;

        
/ </Summary>
        public const int SAFER_CRITERIA_IMAGEPATH_NT = 4096;

        
/ </Summary>
        public const int WTD_UI_NONE = 2;

        
/ </Summary>
        public const int S_OK = 0;

        
/ </Summary>
        public const int S_FALSE = 1;

        
/ </Summary>
        public const int ERROR_MORE_DATA = 234;

        
/ </Summary>
        public const int ERROR_ACCESS_DISABLED_BY_POLICY = 1260;

        
/ </Summary>
        public const int ERROR_ACCESS_DISABLED_NO_SAFER_UI_BY_POLICY = 786;

        
/ </Summary>
        public const int SAFER_MAX_HASH_SIZE = 64;

        
/ </Summary>
        public const string SRP_POLICY_SCRIPT = "SCRIPT";

        
/ </Summary>
        internal const int SIGNATURE_DISPLAYNAME_LENGTH = NativeConstants.MAX_PATH;

        
/ </Summary>
        internal const int SIGNATURE_PUBLISHER_LENGTH = 128;

        
/ </Summary>
        internal const int SIGNATURE_HASH_LENGTH = 64;

        
/ </Summary>
        internal const int MAX_PATH = 260;

        
/ </Summary>
        internal const int FUNCTION_NOT_SUPPORTED = 120;
    }

    
/ </summary>
    internal static partial class NativeMethods
    {
        
/ </summary>
        internal delegate
        bool CertEnumSystemStoreCallBackProto([MarshalAs(UnmanagedType.LPWStr)]
                                               string storeName,
                                               DWORD dwFlagsNotUsed,
                                               IntPtr notUsed1,
                                               IntPtr notUsed2,
                                               IntPtr notUsed3);

        
/ </summary>
        [DllImport("crypt32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        internal static extern
        IntPtr CertEnumCertificatesInStore(IntPtr storeHandle,
                                            IntPtr certContext);

        
/ </summary>
        [DllImport("crypt32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        internal static extern
        IntPtr CertFindCertificateInStore(
            IntPtr hCertStore,
            Security.NativeMethods.CertOpenStoreEncodingType dwEncodingType,
            DWORD dwFindFlags,                  
/ </summary>
            RSA_FULL = 1,

            
/ </summary>
            RSA_SIG = 2,

            
/ </summary>
            DSS = 3,

            
/ </summary>
            FORTEZZA = 4,

            
/ </summary>
            MS_EXCHANGE = 5,

            
/ </summary>
            SSL = 6,

            
/ </summary>
            RSA_SCHANNEL = 12,

            
/ </summary>
            DSS_DH = 13,

            
/ </summary>
            EC_ECDSA_SIG = 14,

            
/ </summary>
            EC_ECNRA_SIG = 15,

            
/ </summary>
            EC_ECDSA_FULL = 16,

            
/ </summary>
            EC_ECNRA_FULL = 17,

            
/ </summary>
            DH_SCHANNEL = 18,

            
/ </summary>
            SPYRUS_LYNKS = 20,

            
/ </summary>
            RNG = 21,

            
/ </summary>
            INTEL_SEC = 22
        }

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        internal struct CRYPT_KEY_PROV_INFO
        {
            
/ </summary>
            public string pwszContainerName;

            
/ </summary>
            public string pwszProvName;

            
/ </summary>
            public PROV dwProvType;

            
/ </summary>
            public uint dwFlags;

            
/ </summary>
            public uint cProvParam;

            
/ </summary>
            public IntPtr rgProvParam;

            
/ </summary>
            public uint dwKeySpec;
        }

        internal const string NCRYPT_WINDOW_HANDLE_PROPERTY = "HWND Handle";

        [DllImport("crypt32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        internal static extern
        bool CertDeleteCertificateFromStore(IntPtr pCertContext);

        [DllImport("crypt32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        internal static extern
        IntPtr CertDuplicateCertificateContext(IntPtr pCertContext);

        [DllImport("crypt32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        internal static extern
        bool CertAddCertificateContextToStore(IntPtr hCertStore,
                                              IntPtr pCertContext,
                                              DWORD dwAddDisposition,
                                              ref IntPtr ppStoreContext);

        [DllImport("crypt32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        internal static extern
        bool CertFreeCertificateContext(IntPtr certContext);

        [DllImport("crypt32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        internal static extern
        bool CertGetCertificateContextProperty(IntPtr pCertContext,
                                               CertPropertyId dwPropId,
                                               IntPtr pvData,
                                               ref int pcbData);

        [DllImport("crypt32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        internal static extern
        bool CertSetCertificateContextProperty(IntPtr pCertContext,
                                               CertPropertyId dwPropId,
                                               DWORD dwFlags,
                                               IntPtr pvData);

        [DllImport("crypt32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        internal static extern
        IntPtr CryptFindLocalizedName(string pwszCryptName);

        [DllImport(PinvokeDllNames.CryptAcquireContextDllName, SetLastError = true, CharSet = CharSet.Unicode)]
        internal static extern
        bool CryptAcquireContext(ref IntPtr hProv,
                                 string strContainerName,
                                 string strProviderName,
                                 int nProviderType,
                                 uint uiProviderFlags);

        [DllImport(PinvokeDllNames.CryptReleaseContextDllName, SetLastError = true, CharSet = CharSet.Unicode)]
        internal static extern
        bool CryptReleaseContext(IntPtr hProv, int dwFlags);

        [DllImport(PinvokeDllNames.CryptSetProvParamDllName, SetLastError = true)]
        internal static extern unsafe
        bool CryptSetProvParam(IntPtr hProv, ProviderParam dwParam, void* pbData, int dwFlags);

        [DllImport("ncrypt.dll", CharSet = CharSet.Unicode)]
        internal static extern
        int NCryptOpenStorageProvider(ref IntPtr hProv,
                                      string strProviderName,
                                      uint dwFlags);

        [DllImport("ncrypt.dll", CharSet = CharSet.Unicode)]
        internal static extern
        int NCryptOpenKey(IntPtr hProv,
                          ref IntPtr hKey,
                          string strKeyName,
                          uint dwLegacySpec,
                          uint dwFlags);

        [DllImport("ncrypt.dll", CharSet = CharSet.Unicode)]
        internal static extern unsafe
        int NCryptSetProperty(IntPtr hProv, string pszProperty, void* pbInput, int cbInput, int dwFlags);

        [DllImport("ncrypt.dll", CharSet = CharSet.Unicode)]
        internal static extern
        int NCryptDeleteKey(IntPtr hKey,
                            uint dwFlags);

        [DllImport("ncrypt.dll", CharSet = CharSet.Unicode)]
        internal static extern
        int NCryptFreeObject(IntPtr hObject);

        
/ CryptUIWizDigitalSign() function and associated structures/enums
        
/ WinVerifyTrust() function and associated structures/enums
        
/ </summary>
    internal static partial class NativeMethods
    {
        internal const int CRYPT_E_NOT_FOUND = unchecked((int)0x80092004);
        internal const int E_INVALID_DATA = unchecked((int)0x8007000d);
        internal const int NTE_NOT_SUPPORTED = unchecked((int)0x80090029);

        internal enum AltNameType : uint
        {
            CERT_ALT_NAME_OTHER_NAME = 1,
            CERT_ALT_NAME_RFC822_NAME = 2,
            CERT_ALT_NAME_DNS_NAME = 3,
            CERT_ALT_NAME_X400_ADDRESS = 4,
            CERT_ALT_NAME_DIRECTORY_NAME = 5,
            CERT_ALT_NAME_EDI_PARTY_NAME = 6,
            CERT_ALT_NAME_URL = 7,
            CERT_ALT_NAME_IP_ADDRESS = 8,
            CERT_ALT_NAME_REGISTERED_ID = 9,
        }

        internal enum CryptDecodeFlags : uint
        {
            CRYPT_DECODE_ENABLE_PUNYCODE_FLAG = 0x02000000,
            CRYPT_DECODE_ENABLE_UTF8PERCENT_FLAG = 0x04000000,
            CRYPT_DECODE_ENABLE_IA5CONVERSION_FLAG = (CRYPT_DECODE_ENABLE_PUNYCODE_FLAG | CRYPT_DECODE_ENABLE_UTF8PERCENT_FLAG),
        }
    }

    #region SAFER_APIs

    
/ </summary>
    internal static partial class NativeMethods
    {
        
/ </summary>
    internal static partial class NativeMethods
    {
        [StructLayout(LayoutKind.Sequential)]
        internal struct CRYPT_ATTRIBUTE_TYPE_VALUE
        {
            [MarshalAs(UnmanagedType.LPStr)]
            internal string pszObjId;

            internal CRYPT_ATTR_BLOB Value;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct SIP_INDIRECT_DATA
        {
            internal CRYPT_ATTRIBUTE_TYPE_VALUE Data;
            internal CRYPT_ALGORITHM_IDENTIFIER DigestAlgorithm;
            internal CRYPT_ATTR_BLOB Digest;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal readonly struct CRYPTCATCDF
        {
            private readonly DWORD _cbStruct;
            private readonly IntPtr _hFile;
            private readonly DWORD _dwCurFilePos;
            private readonly DWORD _dwLastMemberOffset;
            private readonly BOOL _fEOF;

            [MarshalAs(UnmanagedType.LPWStr)]
            private readonly string _pwszResultDir;

            private readonly IntPtr _hCATStore;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct CRYPTCATMEMBER
        {
            internal DWORD cbStruct;

            [MarshalAs(UnmanagedType.LPWStr)]
            internal string pwszReferenceTag;

            [MarshalAs(UnmanagedType.LPWStr)]
            internal string pwszFileName;

            internal Guid gSubjectType;
            internal DWORD fdwMemberFlags;
            internal IntPtr pIndirectData;
            internal DWORD dwCertVersion;
            internal DWORD dwReserved;
            internal IntPtr hReserved;
            internal CRYPT_ATTR_BLOB sEncodedIndirectData;
            internal CRYPT_ATTR_BLOB sEncodedMemberInfo;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct CRYPTCATATTRIBUTE
        {
            private readonly DWORD _cbStruct;

            [MarshalAs(UnmanagedType.LPWStr)]
            internal string pwszReferenceTag;

            private readonly DWORD _dwAttrTypeAndAction;
            internal DWORD cbValue;
            internal System.IntPtr pbValue;
            private readonly DWORD _dwReserved;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct CRYPTCATSTORE
        {
            private readonly DWORD _cbStruct;
            internal DWORD dwPublicVersion;

            [MarshalAs(UnmanagedType.LPWStr)]
            internal string pwszP7File;

            private readonly IntPtr _hProv;
            private readonly DWORD _dwEncodingType;
            private readonly DWORD _fdwStoreFlags;
            private readonly IntPtr _hReserved;
            private readonly IntPtr _hAttrs;
            private readonly IntPtr _hCryptMsg;
            private readonly IntPtr _hSorted;
        }

        [DllImport("wintrust.dll", CharSet = CharSet.Unicode)]
        internal static extern IntPtr CryptCATCDFOpen(
            [MarshalAs(UnmanagedType.LPWStr)]
            string pwszFilePath,
            CryptCATCDFOpenCallBack pfnParseError
        );

        [DllImport("wintrust.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool CryptCATCDFClose(
            IntPtr pCDF
        );

        [DllImport("wintrust.dll", CharSet = CharSet.Unicode)]
        internal static extern IntPtr CryptCATCDFEnumCatAttributes(
            IntPtr pCDF,
            IntPtr pPrevAttr,
            CryptCATCDFOpenCallBack pfnParseError
        );

        [DllImport("wintrust.dll", CharSet = CharSet.Unicode)]
        internal static extern IntPtr CryptCATCDFEnumMembersByCDFTagEx(
            IntPtr pCDF,
            IntPtr pwszPrevCDFTag,
            CryptCATCDFEnumMembersByCDFTagExErrorCallBack fn,
            ref IntPtr ppMember,
            bool fContinueOnError,
            IntPtr pvReserved
        );

        [DllImport("wintrust.dll", CharSet = CharSet.Unicode)]
        internal static extern IntPtr CryptCATCDFEnumAttributesWithCDFTag(
            IntPtr pCDF,
            IntPtr pwszMemberTag,
            IntPtr pMember,
            IntPtr pPrevAttr,
            CryptCATCDFEnumMembersByCDFTagExErrorCallBack fn
        );

        [DllImport("wintrust.dll", CharSet = CharSet.Unicode)]
        internal static extern IntPtr CryptCATOpen(
            [MarshalAs(UnmanagedType.LPWStr)]
            string pwszFilePath,
            DWORD fdwOpenFlags,
            IntPtr hProv,
            DWORD dwPublicVersion,
            DWORD dwEncodingType
         );

        [DllImport("wintrust.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool CryptCATClose(
          IntPtr hCatalog
        );

        [DllImport("wintrust.dll", CharSet = CharSet.Unicode)]
        internal static extern IntPtr CryptCATStoreFromHandle(
            IntPtr hCatalog
        );

        [DllImport("wintrust.dll", CharSet = CharSet.Unicode)]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool CryptCATAdminAcquireContext2(
          ref IntPtr phCatAdmin,
          IntPtr pgSubsystem,
          [MarshalAs(UnmanagedType.LPWStr)]
          string pwszHashAlgorithm,
          IntPtr pStrongHashPolicy,
          DWORD dwFlags
      );

        [DllImport("wintrust.dll", CharSet = CharSet.Unicode)]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool CryptCATAdminReleaseContext(
            IntPtr phCatAdmin,
            DWORD dwFlags
        );

        [DllImport("kernel32", SetLastError = true, CharSet = CharSet.Unicode)]
        internal static extern unsafe IntPtr CreateFile(
            string lpFileName,
            DWORD dwDesiredAccess,
            DWORD dwShareMode,
            DWORD lpSecurityAttributes,
            DWORD dwCreationDisposition,
            DWORD dwFlagsAndAttributes,
            IntPtr hTemplateFile
           );

        [DllImport("wintrust.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        [return: MarshalAs(UnmanagedType.Bool)]
        internal static extern bool CryptCATAdminCalcHashFromFileHandle2(
            IntPtr hCatAdmin,
            IntPtr hFile,
            [In, Out] ref DWORD pcbHash,
            IntPtr pbHash,
            DWORD dwFlags
        );

        [DllImport("wintrust.dll", CharSet = CharSet.Unicode)]
        internal static extern IntPtr CryptCATEnumerateCatAttr(
            IntPtr hCatalog,
            IntPtr pPrevAttr
        );

        [DllImport("wintrust.dll", CharSet = CharSet.Unicode)]
        internal static extern IntPtr CryptCATEnumerateMember(
                IntPtr hCatalog,
                IntPtr pPrevMember
        );

        [DllImport("wintrust.dll", CharSet = CharSet.Unicode)]
        internal static extern IntPtr CryptCATEnumerateAttr(
            IntPtr hCatalog,
            IntPtr pCatMember,
            IntPtr pPrevAttr
        );

        
/ </summary>
        internal delegate
        void CryptCATCDFOpenCallBack(DWORD NotUsedDWORD1,
                                      DWORD NotUsedDWORD2,
                                      [MarshalAs(UnmanagedType.LPWStr)]
                                      string NotUsedString);

        
/ </summary>
        internal delegate
        void CryptCATCDFEnumMembersByCDFTagExErrorCallBack(DWORD NotUsedDWORD1,
                                      DWORD NotUsedDWORD2,
                                      [MarshalAs(UnmanagedType.LPWStr)]
                                      string NotUsedString);
    }
}

#pragma warning restore 56523
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\PowerShell\System.Management.Automation\security\SecuritySupport.cs
/github.com/PowerShell/PowerShell/blob/v7.2.4/src/System.Management.Automation/security/SecuritySupport.cs

#pragma warning disable 56523

using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Globalization;

/ </summary>
    public enum ExecutionPolicy
    {
        
/ </summary>
        Default = Restricted
    }

    
/ </summary>
    public enum ExecutionPolicyScope
    {
        
/ </summary>
    internal enum SaferPolicy
    {
        
/ </summary>
    public static class SecuritySupport
    {
        #region execution policy

        internal static ExecutionPolicyScope[] ExecutionPolicyScopePreferences
        {
            get
            {
                return new ExecutionPolicyScope[] {
                        ExecutionPolicyScope.MachinePolicy,
                        ExecutionPolicyScope.UserPolicy,
                        ExecutionPolicyScope.Process,
                        ExecutionPolicyScope.CurrentUser,
                        ExecutionPolicyScope.LocalMachine
                    };
            }
        }

        
/ </summary>
        
/ </remarks>
        
/ The implication is that logon / logoff scripts that somehow
        
/ affect logon / logoff scripts.
        
/ itself. A group policy should never block a logon /
        
/ </summary>
        
/ <param name="file">Name of file to check.</param>
        
/ <returns>True when file has product binary signature.</returns>
        
/ On OneCore SKUs like NanoServer/IoT, the API has a bug that makes it not able to find the
        
/ </summary>
        
/ <returns>NULL if it is not defined at this level.</returns>
        
/ </summary>
        
/ <returns>NULL if it is not defined at this level.</returns>
        
/ Get the pass / fail result of calling the SAFER API.
        
/ </summary>
        
/ <param name="path">The path to the file in question.</param>
        
/ <param name="handle">A file handle to the file in question, if available.</param>
        
/ </summary>
        
/ <param name="filePath">Path to file.</param>
        
/ <returns>Does not return a value.</returns>
        internal static void CheckIfFileExists(string filePath)
        {
            if (!File.Exists(filePath))
            {
                throw new FileNotFoundException(filePath);
            }
        }

        
/ </summary>
        
/ <param name="c">Certificate object.</param>
        
/ <returns>True on success, false otherwise.</returns>
        internal static bool CertIsGoodForSigning(X509Certificate2 c)
        {
            if (!c.HasPrivateKey)
            {
                return false;
            }

            return CertHasOid(c, CertificateFilterInfo.CodeSigningOid);
        }

        
/ </summary>
        
/ <param name="c">Certificate object.</param>
        
/ <returns>True on success, false otherwise.</returns>
        internal static bool CertIsGoodForEncryption(X509Certificate2 c)
        {
            return (
                CertHasOid(c, CertificateFilterInfo.DocumentEncryptionOid) &&
                (CertHasKeyUsage(c, X509KeyUsageFlags.DataEncipherment) ||
                 CertHasKeyUsage(c, X509KeyUsageFlags.KeyEncipherment)));
        }

        
/ </summary>
        
/ <param name="c">Certificate object.</param>
        
/ <param name="expiring">Certificate expire time.</param>
        
/ <returns>True on success, false otherwise.</returns>
        internal static bool CertExpiresByTime(X509Certificate2 c, DateTime expiring)
        {
            return c.NotAfter < expiring;
        }

        private static bool CertHasOid(X509Certificate2 c, string oid)
        {
            foreach (var extension in c.Extensions)
            {
                if (extension is X509EnhancedKeyUsageExtension ext)
                {
                    foreach (Oid ekuOid in ext.EnhancedKeyUsages)
                    {
                        if (ekuOid.Value == oid)
                        {
                            return true;
                        }
                    }
                    break;
                }
            }
            return false;
        }

        private static bool CertHasKeyUsage(X509Certificate2 c, X509KeyUsageFlags keyUsage)
        {
            foreach (X509Extension extension in c.Extensions)
            {
                X509KeyUsageExtension keyUsageExtension = extension as X509KeyUsageExtension;
                if (keyUsageExtension != null)
                {
                    if ((keyUsageExtension.KeyUsages & keyUsage) == keyUsage)
                    {
                        return true;
                    }
                    break;
                }
            }
            return false;
        }

        
/ </summary>
        
/ <param name="cert">Certificate object.</param>
        
/ <returns>A collection of cert eku strings.</returns>
        
/ </summary>
        
/ <param name="n">Signed int number.</param>
        
/ <returns>DWORD.</returns>
        internal static DWORD GetDWORDFromInt(int n)
        {
            UInt32 result = BitConverter.ToUInt32(BitConverter.GetBytes(n), 0);
            return (DWORD)result;
        }

        
/ </summary>
        
/ <param name="n">Number.</param>
        
/ <returns>Int.</returns>
        internal static int GetIntFromDWORD(DWORD n)
        {
            Int64 n64 = n - 0x100000000L;
            return (int)n64;
        }
    }

    
/ </summary>
    internal sealed class CertificateFilterInfo
    {
        internal CertificateFilterInfo()
        {
        }

        
/ </summary>
        internal CertificatePurpose Purpose
        {
            get;
            set;
        } = CertificatePurpose.NotSpecified;

        
/ </summary>
        internal bool SSLServerAuthentication
        {
            get;

            set;
        }

        
/ </summary>
        
/ </summary>
        
/ </summary>
        internal DateTime Expiring
        {
            get;
            set;
        } = DateTime.MinValue;

        internal const string CodeSigningOid = "1.3.6.1.5.5.7.3.3";
        internal const string OID_PKIX_KP_SERVER_AUTH = "1.3.6.1.5.5.7.3.1";

        
/ </summary>
    internal enum CertificatePurpose
    {
        
/ </summary>
        NotSpecified = 0,

        
/ </summary>
        CodeSigning = 0x1,

        
/ </summary>
        DocumentEncryption = 0x2,

        
/ </summary>
        All = 0xffff
    }
}

namespace System.Management.Automation
{
    using System.Security.Cryptography.Pkcs;

    
/ </summary>
    internal static class CmsUtils
    {
        
/ </summary>
        
/ <param name="bytes">The bytes to encode.</param>
        internal static string GetAsciiArmor(byte[] bytes)
        {
            StringBuilder output = new StringBuilder();
            output.AppendLine(BEGIN_CMS_SIGIL);

            string encodedString = Convert.ToBase64String(bytes, Base64FormattingOptions.InsertLineBreaks);
            output.AppendLine(encodedString);
            output.Append(END_CMS_SIGIL);

            return output.ToString();
        }

        
/ </summary>
        
/ <param name="actualContent">The Ascii armored content.</param>
        
/ <param name="beginMarker">The marker of the start of the Base64 content.</param>
        
/ <param name="endMarker">The marker of the end of the Base64 content.</param>
        
/ <param name="startIndex">The beginning of where the Ascii armor was detected.</param>
        
/ <param name="endIndex">The end of where the Ascii armor was detected.</param>
        internal static byte[] RemoveAsciiArmor(string actualContent, string beginMarker, string endMarker, out int startIndex, out int endIndex)
        {
            byte[] messageBytes = null;
            startIndex = -1;
            endIndex = -1;

            startIndex = actualContent.IndexOf(beginMarker, StringComparison.OrdinalIgnoreCase);
            if (startIndex < 0)
            {
                return null;
            }

            endIndex = actualContent.IndexOf(endMarker, startIndex, StringComparison.OrdinalIgnoreCase) +
                 endMarker.Length;
            if (endIndex < endMarker.Length)
            {
                return null;
            }

            int startContent = startIndex + beginMarker.Length;
            int endContent = endIndex - endMarker.Length;
            string encodedContent = actualContent.Substring(startContent, endContent - startContent);
            encodedContent = System.Text.RegularExpressions.Regex.Replace(encodedContent, "\\s", string.Empty);
            messageBytes = Convert.FromBase64String(encodedContent);

            return messageBytes;
        }
    }

    
/ </summary>
    public class CmsMessageRecipient
    {
        
/ </summary>
#pragma warning disable CS8618 
/ </summary>
        
/ </param>
#pragma warning disable CS8618 
/ </summary>
        
/ <param name="certificate">The certificate to use.</param>
#pragma warning disable CS8618 
/ </summary>
        public X509Certificate2Collection Certificates
        {
            get;
            internal set;
        }

        
/ </summary>
        
/ <param name="sessionState">A reference to an instance of Powershell's SessionState class.</param>
        
/ <param name="purpose">The purpose for which this identifier is being resolved (Encryption / Decryption.</param>
        
/ <param name="error">The error generated (if any) for this resolution.</param>
        
/ If we got an ItemNotFound / etc., then this didn't represent a valid path.
        
/social.technet.microsoft.com/wiki/contents/articles/13922.certificate-pfx-export-and-import-using-ad-ds-account-protection.aspx)
        
/ </summary>
    public enum ResolutionPurpose
    {
        
/ </summary>
        Encryption,

        
/ </summary>
        Decryption
    }

    
/ </summary>
    
/ <param name="content">The string to be scanned.</param>
    
/ <param name="sourceMetadata">Information about the source (filename, etc.).</param>
    
/ <returns>AMSI_RESULT_DETECTED if malware was detected in the sample.</returns>
    
/ </summary>
    
/ </summary>
    
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Tools.Publish\PowerShell\System.Management.Automation\security\SecuritySupport.cs
UNIX
UNIX
UNIX
UNIX
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\PowerShell\System.Management.Automation\utils\ArchitectureSensitiveAttribute.cs
/github.com/PowerShell/PowerShell/blob/v7.2.4/src/System.Management.Automation/utils/ArchitectureSensitiveAttribute.cs

namespace System.Management.Automation.Internal
{
    
/ which is likely to be sensitive to X86/X64/IA64 issues,
    
/ </summary>
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
    internal class ArchitectureSensitiveAttribute : Attribute
    {
        
/ </summary>
        internal ArchitectureSensitiveAttribute()
        {
        }
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\PowerShell\System.Management.Automation\utils\assert.cs
/github.com/PowerShell/PowerShell/blob/v7.2.4/src/System.Management.Automation/utils/assert.cs


/ </summary>
    internal class AssertException : SystemException
    {
        
/ </summary>
        
/ <param name="message">Repassed to the base class.</param>
        internal AssertException(string message) : base(message)
        {
            
/ </summary>
        
/ <value>the constructor's stackTrace</value>
        public override string StackTrace { get; }
    }

    
/ </summary>
    
/ <newpara/>
    
/ </code>
    
/ </example>
    
/ <newpara/>
    
/ </remarks>
    internal sealed class Diagnostics
    {
        internal static string StackTrace(int framesToSkip)
        {
            StackTrace trace = new StackTrace(true);
            StackFrame[] frames = trace.GetFrames();
            StringBuilder frameString = new StringBuilder();
            int maxFrames = 10;
            maxFrames += framesToSkip;
            for (int i = framesToSkip; (i < frames.Length) && (i < maxFrames); i++)
            {
                StackFrame frame = frames[i];
                frameString.Append(frame.ToString());
            }

            return frameString.ToString();
        }

        private static readonly object s_throwInsteadOfAssertLock = 1;

        private static bool s_throwInsteadOfAssert = false;

        
/ </summary>
        
/ <value>false for dialog, true for exception</value>
        internal static bool ThrowInsteadOfAssert
        {
            get
            {
                lock (s_throwInsteadOfAssertLock)
                {
                    return s_throwInsteadOfAssert;
                }
            }

            set
            {
                lock (s_throwInsteadOfAssertLock)
                {
                    s_throwInsteadOfAssert = value;
                }
            }
        }

        
/ </summary>
        private Diagnostics() { }

        
/ </summary>
        
/ </param>
        
/ </param>
        
/ </summary>
        
/ </param>
        
/ </param>
        
/ </param>
        
发现条件编译指令：../SteamTools\src\BD.WTTS.Client.Tools.Publish\PowerShell\System.Management.Automation\utils\assert.cs
DEBUG
RESHARPER
RESHARPER
RESHARPER
RESHARPER
ASSERTIONS
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\PowerShell\System.Management.Automation\utils\MshArgumentException.cs
/github.com/PowerShell/PowerShell/blob/v7.2.4/src/System.Management.Automation/utils/MshArgumentException.cs

using System.Runtime.Serialization;

namespace System.Management.Automation
{
    
/ <see cref="System.ArgumentException"/>
    
/ <see cref="System.Management.Automation.IContainsErrorRecord"/>.
    
/ </summary>
    
/ </remarks>
    [Serializable]
    public class PSArgumentException
            : ArgumentException/*, IContainsErrorRecord*/
    {
        #region ctor

        
/ </summary>
        
/ <returns>Constructed object.</returns>
#pragma warning disable CS8618 
/ </summary>
        
/ <param name="message"></param>
        
/ <returns>Constructed object.</returns>
        
/ </remarks>
#pragma warning disable CS8618 
/ </summary>
        
/ <param name="paramName"></param>
        
/ <param name="message"></param>
        
/ <returns>Constructed object.</returns>
        
/ </remarks>
        public PSArgumentException(string message, string paramName)
                : base(message, paramName)
        {
            _message = message;
        }

        #region Serialization

        
/ <see cref="System.Runtime.Serialization.ISerializable"/>
        
/ </summary>
        
/ <param name="info">Serialization information.</param>
        
/ <param name="context">Streaming context.</param>
        
/ <returns>Constructed object.</returns>
#pragma warning disable CS8618 
/ Serializer for <see cref="System.Runtime.Serialization.ISerializable"/>
        
/ </summary>
        
/ <param name="info">Serialization information.</param>
        
/ <param name="context">Streaming context.</param>
        public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            if (info == null)
            {
                throw new PSArgumentNullException(nameof(info));
            }

            base.GetObjectData(info, context);
            info.AddValue("ErrorId", _errorId);
            info.AddValue("PSArgumentException_MessageOverride", _message);
        }
        #endregion Serialization

        
/ </summary>
        
/ <param name="message"></param>
        
/ <param name="innerException"></param>
        
/ <returns>Constructed object.</returns>
        public PSArgumentException(string message,
                                    Exception innerException)
                : base(message, innerException)
        {
            _message = message;
        }
        #endregion ctor

        
/ </summary>
        
/ <value></value>
        
/ <see cref="System.Management.Automation.ParentContainsErrorRecordException"/>.
        
/ </remarks>
        
/ See <see cref="System.Exception.Message"/>
        
/ </summary>
        
/ </remarks>
        
/ <value></value>
        public override string Message
        {
            get { return string.IsNullOrEmpty(_message) ? base.Message : _message; }
        }

        private readonly string _message;
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\PowerShell\System.Management.Automation\utils\MshArgumentNullException.cs
/github.com/PowerShell/PowerShell/blob/v7.2.4/src/System.Management.Automation/utils/MshArgumentNullException.cs

using System.Runtime.Serialization;

namespace System.Management.Automation
{
    
/ <see cref="System.ArgumentNullException"/>
    
/ <see cref="System.Management.Automation.IContainsErrorRecord"/>.
    
/ </summary>
    
/ </remarks>
    [Serializable]
    public class PSArgumentNullException
            : ArgumentNullException/*, IContainsErrorRecord*/
    {
        #region ctor

        
/ </summary>
        
/ <returns>Constructed object.</returns>
#pragma warning disable CS8618 
/ </summary>
        
/ <param name="paramName"></param>
        
/ <returns>Constructed object.</returns>
        
/ </remarks>
#pragma warning disable CS8618 
/ </summary>
        
/ <param name="message"></param>
        
/ <param name="innerException"></param>
        
/ <returns>Constructed object.</returns>
        public PSArgumentNullException(string message, Exception innerException)
            : base(message, innerException)
        {
            _message = message;
        }

        
/ </summary>
        
/ <param name="paramName"></param>
        
/ <param name="message"></param>
        
/ <returns>Constructed object.</returns>
        
/ </remarks>
        public PSArgumentNullException(string paramName, string message)
            : base(paramName, message)
        {
            _message = message;
        }

        #region Serialization

        
/ <see cref="System.Runtime.Serialization.ISerializable"/>
        
/ </summary>
        
/ <param name="info">Serialization information.</param>
        
/ <param name="context">Streaming context.</param>
        
/ <returns>Constructed object.</returns>
#pragma warning disable CS8618 
/ Serializer for <see cref="System.Runtime.Serialization.ISerializable"/>
        
/ </summary>
        
/ <param name="info">Serialization information.</param>
        
/ <param name="context">Streaming context.</param>
        public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            if (info == null)
            {
                throw new PSArgumentNullException(nameof(info));
            }

            base.GetObjectData(info, context);
            info.AddValue("ErrorId", _errorId);
            info.AddValue("PSArgumentNullException_MessageOverride", _message);
        }
        #endregion Serialization
        #endregion ctor

        
/ </summary>
        
/ <value></value>
        
/ <see cref="System.Management.Automation.ParentContainsErrorRecordException"/>.
        
/ </remarks>
        
/ See <see cref="System.Exception.Message"/>
        
/ </summary>
        
/ </remarks>
        
/ <value></value>
        public override string Message
        {
            get { return string.IsNullOrEmpty(_message) ? base.Message : _message; }
        }

        private readonly string _message;
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\PowerShell\System.Management.Automation\utils\MshTraceSource.cs
/github.com/PowerShell/PowerShell/blob/v7.2.4/src/System.Management.Automation/utils/MshTraceSource.cs

#define TRACE

using System.Reflection;
using System.Management.Automation.Internal;

namespace System.Management.Automation
{
    
/ </summary>
    
/ It is permitted to subclass <see cref="PSTraceSource"/>
    
/ </remarks>
    
/ </summary>
    
/ <newpara/>
    
/ </code>
    
/ </example>
    
/ <newpara/>
    
/ </summary>
        private static readonly object s_getTracerLock = new object();

        
/ </summary>
        
/ </param>
        
/ </param>
        
/ </returns>
        internal static PSTraceSource GetTracer(
            string name,
            string description)
        {
            return PSTraceSource.GetTracer(name, description, true);
        }

        
/ </summary>
        
/ </param>
        
/ </param>
        
/ </param>
        
/ </returns>
        internal static PSTraceSource GetTracer(
            string name,
            string description,
            bool traceHeaders)
        {
            if (string.IsNullOrEmpty(name))
            {
                
/ 2005/04/13-JonN In theory this should be ArgumentException,
                
/ uniform output

            string fullName = name;
            /*
                            
/ trailing spaces if this actually does pad the name.
                            name =
                                string.Format(
                                    System.Globalization.CultureInfo.InvariantCulture,
                                    "{0,-16}",
                                    name);
            */
            PSTraceSource result =
                new PSTraceSource(
                    fullName,
                    name,
                    description,
                    traceHeaders);
            return result;
        }

        #region TraceFlags.New*Exception methods/helpers

        
/ </summary>
        
/ </param>
        
/ <returns>Exception instance ready to throw.</returns>
        internal static PSArgumentNullException NewArgumentNullException(string paramName)
        {
            if (string.IsNullOrEmpty(paramName))
            {
                throw new ArgumentNullException(nameof(paramName));
            }

            string message = StringUtil.Format(AutomationExceptions.ArgumentNull, paramName);
            var e = new PSArgumentNullException(paramName, message);

            return e;
        }

        
/ </summary>
        
/ </param>
        
/ </param>
        
/ </param>
        
/ <returns>Exception instance ready to throw.</returns>
        internal static PSArgumentNullException NewArgumentNullException(
            string paramName, string resourceString, params object[] args)
        {
            if (string.IsNullOrEmpty(paramName))
            {
                throw NewArgumentNullException(nameof(paramName));
            }

            if (string.IsNullOrEmpty(resourceString))
            {
                throw NewArgumentNullException(nameof(resourceString));
            }

            string message = StringUtil.Format(resourceString, args);

            
/ </summary>
        
/ </param>
        
/ <returns>Exception instance ready to throw.</returns>
        internal static PSArgumentException NewArgumentException(string paramName)
        {
            if (string.IsNullOrEmpty(paramName))
            {
                throw new ArgumentNullException(nameof(paramName));
            }

            string message = StringUtil.Format(AutomationExceptions.Argument, paramName);
            
/ </summary>
        
/ </param>
        
/ </param>
        
/ </param>
        
/ <returns>Exception instance ready to throw.</returns>
        internal static PSArgumentException NewArgumentException(
            string paramName, string resourceString, params object[] args)
        {
            if (string.IsNullOrEmpty(paramName))
            {
                throw NewArgumentNullException(nameof(paramName));
            }

            if (string.IsNullOrEmpty(resourceString))
            {
                throw NewArgumentNullException(nameof(resourceString));
            }

            string message = StringUtil.Format(resourceString, args);

            
/ </summary>
        
/ <returns>Exception instance ready to throw.</returns>
        
/ </summary>
        
/ </param>
        
/ </param>
        
/ <returns>Exception instance ready to throw.</returns>
        
/ </summary>
        
/ </param>
        
/ </param>
        
/ </param>
        
/ <returns>Exception instance ready to throw.</returns>
        
/ </summary>
        
/ <returns>Exception instance ready to throw.</returns>
        
/ </summary>
        
/ </param>
        
/ </param>
        
/ <returns>Exception instance ready to throw.</returns>
        
/ </summary>
        
/ <returns>Exception instance ready to throw.</returns>
        
/ </summary>
        
/ </param>
        
/ </param>
        
/ <returns>Exception instance ready to throw.</returns>
        
/ </summary>
        
/ </param>
        
/ </param>
        
/ </param>
        
/ </param>
        
/ <returns>Exception instance ready to throw.</returns>
        
/ </summary>
        
/ </param>
        
/ <returns>Exception instance ready to throw.</returns>
        
/ </remarks>
        
/}

        #endregion TraceFlags.New*Exception methods/helpers
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\PowerShell\System.Management.Automation\utils\PInvokeDllNames.cs
/github.com/PowerShell/PowerShell/blob/v7.2.4/src/System.Management.Automation/utils/PInvokeDllNames.cs

namespace System.Management.Automation
{
    
/ PinvokeDllNames contains the DLL names to be use for PInvoke in FullCLR/CoreCLR powershell.
    
/   of it. Add the comment '/*COUNT*/' with the new DLL name, and make sure the 'COUNT' is the
    
/ </summary>
    internal static class PinvokeDllNames
    {
        internal const string QueryDosDeviceDllName = "api-ms-win-core-file-l1-1-0.dll";                     /*1*/
        internal const string CreateSymbolicLinkDllName = "api-ms-win-core-file-l2-1-0.dll";                 /*2*/
        internal const string GetOEMCPDllName = "api-ms-win-core-localization-l1-2-0.dll";                   /*3*/
        internal const string DeviceIoControlDllName = "api-ms-win-core-io-l1-1-0.dll";                      /*4*/
        internal const string CreateFileDllName = "api-ms-win-core-file-l1-1-0.dll";                         /*5*/
        internal const string DeleteFileDllName = "api-ms-win-core-file-l1-1-0.dll";                         /*6*/
        internal const string FindCloseDllName = "api-ms-win-core-file-l1-1-0.dll";                          /*7*/
        internal const string GetFileAttributesDllName = "api-ms-win-core-file-l1-1-0.dll";                  /*8*/
        internal const string FindFirstFileDllName = "api-ms-win-core-file-l1-1-0.dll";                      /*9*/
        internal const string FindNextFileDllName = "api-ms-win-core-file-l1-1-0.dll";                       /*10*/
        internal const string RegEnumValueDllName = "api-ms-win-core-registry-l1-1-0.dll";                   /*11*/
        internal const string RegOpenKeyExDllName = "api-ms-win-core-registry-l1-1-0.dll";                   /*12*/
        internal const string RegOpenKeyTransactedDllName = "api-ms-win-core-registry-l2-1-0.dll";           /*13*/
        internal const string RegQueryInfoKeyDllName = "api-ms-win-core-registry-l1-1-0.dll";                /*14*/
        internal const string RegQueryValueExDllName = "api-ms-win-core-registry-l2-1-0.dll";                /*15*/
        internal const string RegSetValueExDllName = "api-ms-win-core-registry-l1-1-0.dll";                  /*16*/
        internal const string RegCreateKeyTransactedDllName = "api-ms-win-core-registry-l2-1-0.dll";         /*17*/
        internal const string CryptGenKeyDllName = "api-ms-win-security-cryptoapi-l1-1-0.dll";               /*18*/
        internal const string CryptDestroyKeyDllName = "api-ms-win-security-cryptoapi-l1-1-0.dll";           /*19*/
        internal const string CryptAcquireContextDllName = "api-ms-win-security-cryptoapi-l1-1-0.dll";       /*20*/
        internal const string CryptReleaseContextDllName = "api-ms-win-security-cryptoapi-l1-1-0.dll";       /*21*/
        internal const string CryptEncryptDllName = "api-ms-win-security-cryptoapi-l1-1-0.dll";              /*22*/
        internal const string CryptDecryptDllName = "api-ms-win-security-cryptoapi-l1-1-0.dll";              /*23*/
        internal const string CryptExportKeyDllName = "api-ms-win-security-cryptoapi-l1-1-0.dll";            /*24*/
        internal const string CryptImportKeyDllName = "api-ms-win-security-cryptoapi-l1-1-0.dll";            /*25*/
        internal const string CryptDuplicateKeyDllName = "api-ms-win-security-cryptoapi-l1-1-0.dll";         /*26*/
        internal const string GetLastErrorDllName = "api-ms-win-core-errorhandling-l1-1-0.dll";              /*27*/
        internal const string GetCPInfoDllName = "api-ms-win-core-localization-l1-2-0.dll";                  /*28*/
        internal const string CommandLineToArgvDllName = "api-ms-win-downlevel-shell32-l1-1-0.dll";          /*30*/
        internal const string LocalFreeDllName = "api-ms-win-core-misc-l1-1-0.dll";                          /*31*/
        internal const string CloseHandleDllName = "api-ms-win-core-handle-l1-1-0.dll";                      /*32*/
        internal const string GetTokenInformationDllName = "api-ms-win-security-base-l1-1-0.dll";            /*33*/
        internal const string LookupAccountSidDllName = "api-ms-win-security-lsalookup-l2-1-0.dll";          /*34*/
        internal const string OpenProcessTokenDllName = "api-ms-win-core-processsecurity-l1-1-0.dll";        /*35*/
        internal const string DosDateTimeToFileTimeDllName = "api-ms-win-core-kernel32-legacy-l1-1-0.dll";   /*36*/
        internal const string LocalFileTimeToFileTimeDllName = "api-ms-win-core-file-l1-1-0.dll";            /*37*/
        internal const string SetFileTimeDllName = "api-ms-win-core-file-l1-1-0.dll";                        /*38*/
        internal const string SetFileAttributesWDllName = "api-ms-win-core-file-l1-1-0.dll";                 /*39*/
        internal const string CreateHardLinkDllName = "api-ms-win-core-file-l2-1-0.dll";                     /*40*/
        internal const string RegCloseKeyDllName = "api-ms-win-core-registry-l1-1-0.dll";                    /*41*/
        internal const string GetFileInformationByHandleDllName = "api-ms-win-core-file-l1-1-0.dll";         /*42*/
        internal const string FindFirstStreamDllName = "api-ms-win-core-file-l1-2-2.dll";                    /*43*/
        internal const string FindNextStreamDllName = "api-ms-win-core-file-l1-2-2.dll";                     /*44*/
        internal const string GetSystemInfoDllName = "api-ms-win-core-sysinfo-l1-1-0.dll";                   /*45*/
        internal const string GetCurrentThreadIdDllName = "api-ms-win-core-processthreads-l1-1-0.dll";       /*46*/
        internal const string SetLocalTimeDllName = "api-ms-win-core-sysinfo-l1-1-0.dll";                    /*47*/
        internal const string CryptSetProvParamDllName = "api-ms-win-security-cryptoapi-l1-1-0.dll";         /*48*/
        internal const string GetNamedSecurityInfoDllName = "api-ms-win-security-provider-l1-1-0.dll";       /*49*/
        internal const string SetNamedSecurityInfoDllName = "api-ms-win-security-provider-l1-1-0.dll";       /*50*/
        internal const string ConvertStringSidToSidDllName = "api-ms-win-security-sddl-l1-1-0.dll";          /*51*/
        internal const string IsValidSidDllName = "api-ms-win-security-base-l1-1-0.dll";                     /*52*/
        internal const string GetLengthSidDllName = "api-ms-win-security-base-l1-1-0.dll";                   /*53*/
        internal const string LsaFreeMemoryDllName = "api-ms-win-security-lsapolicy-l1-1-0.dll";             /*54*/
        internal const string InitializeAclDllName = "api-ms-win-security-base-l1-1-0.dll";                  /*55*/
        internal const string GetCurrentProcessDllName = "api-ms-win-core-processthreads-l1-1-0.dll";        /*56*/
        internal const string GetCurrentThreadDllName = "api-ms-win-core-processthreads-l1-1-0.dll";         /*57*/
        internal const string OpenThreadTokenDllName = "api-ms-win-core-processthreads-l1-1-0.dll";          /*58*/
        internal const string LookupPrivilegeValueDllName = "api-ms-win-security-lsalookup-l2-1-0.dll";      /*59*/
        internal const string AdjustTokenPrivilegesDllName = "api-ms-win-security-base-l1-1-0.dll";          /*60*/
        internal const string GetStdHandleDllName = "api-ms-win-core-processenvironment-l1-1-0.dll";         /*61*/
        internal const string CreateProcessWithLogonWDllName = "api-ms-win-security-cpwl-l1-1-0.dll";        /*62*/
        internal const string CreateProcessDllName = "api-ms-win-core-processthreads-l1-1-0.dll";            /*63*/
        internal const string ResumeThreadDllName = "api-ms-win-core-processthreads-l1-1-0.dll";             /*64*/
        internal const string OpenSCManagerWDllName = "api-ms-win-service-management-l1-1-0.dll";            /*65*/
        internal const string OpenServiceWDllName = "api-ms-win-service-management-l1-1-0.dll";              /*66*/
        internal const string CloseServiceHandleDllName = "api-ms-win-service-management-l1-1-0.dll";        /*67*/
        internal const string ChangeServiceConfigWDllName = "api-ms-win-service-management-l2-1-0.dll";      /*68*/
        internal const string ChangeServiceConfig2WDllName = "api-ms-win-service-management-l2-1-0.dll";     /*69*/
        internal const string CreateServiceWDllName = "api-ms-win-service-management-l1-1-0.dll";            /*70*/
        internal const string CreateJobObjectDllName = "api-ms-win-core-job-l2-1-0.dll";                     /*71*/
        internal const string AssignProcessToJobObjectDllName = "api-ms-win-core-job-l2-1-0.dll";            /*72*/
        internal const string QueryInformationJobObjectDllName = "api-ms-win-core-job-l2-1-0.dll";           /*73*/
        internal const string CreateNamedPipeDllName = "api-ms-win-core-namedpipe-l1-1-0.dll";               /*74*/
        internal const string WaitNamedPipeDllName = "api-ms-win-core-namedpipe-l1-1-0.dll";                 /*75*/
        internal const string PrivilegeCheckDllName = "api-ms-win-security-base-l1-1-0.dll";                 /*76*/
        internal const string ImpersonateNamedPipeClientDllName = "api-ms-win-core-namedpipe-l1-1-0.dll";    /*77*/
        internal const string RevertToSelfDllName = "api-ms-win-security-base-l1-1-0.dll";                   /*78*/
        internal const string CreateProcessInComputeSystemDllName = "vmcompute.dll";                         /*79*/
        internal const string CLSIDFromProgIDDllName = "api-ms-win-core-com-l1-1-0.dll";                     /*80*/
        internal const string LoadLibraryEx = "api-ms-win-core-libraryloader-l1-1-0.dll";                    /*81*/
        internal const string FreeLibrary = "api-ms-win-core-libraryloader-l1-1-0.dll";                      /*82*/
        internal const string EventActivityIdControlDllName = "api-ms-win-eventing-provider-l1-1-0.dll";     /*83*/
        internal const string GetConsoleCPDllName = "api-ms-win-core-console-l1-1-0.dll";                    /*84*/
        internal const string GetConsoleOutputCPDllName = "api-ms-win-core-console-l1-1-0.dll";              /*85*/
        internal const string GetConsoleWindowDllName = "api-ms-win-core-kernel32-legacy-l1-1-0.dll";        /*86*/
        internal const string GetDCDllName = "ext-ms-win-ntuser-dc-access-ext-l1-1-0.dll";                   /*87*/
        internal const string ReleaseDCDllName = "ext-ms-win-ntuser-dc-access-ext-l1-1-0.dll";               /*88*/
        internal const string TranslateCharsetInfoDllName = "ext-ms-win-gdi-font-l1-1-1.dll";                /*89*/
        internal const string GetTextMetricsDllName = "ext-ms-win-gdi-font-l1-1-1.dll";                      /*90*/
        internal const string GetCharWidth32DllName = "ext-ms-win-gdi-font-l1-1-1.dll";                      /*91*/
        internal const string FlushConsoleInputBufferDllName = "api-ms-win-core-console-l2-1-0.dll";         /*92*/
        internal const string FillConsoleOutputAttributeDllName = "api-ms-win-core-console-l2-1-0.dll";      /*93*/
        internal const string FillConsoleOutputCharacterDllName = "api-ms-win-core-console-l2-1-0.dll";      /*94*/
        internal const string WriteConsoleDllName = "api-ms-win-core-console-l1-1-0.dll";                    /*95*/
        internal const string GetConsoleTitleDllName = "api-ms-win-core-console-l2-1-0.dll";                 /*96*/
        internal const string SetConsoleTitleDllName = "api-ms-win-core-console-l2-1-0.dll";                 /*97*/
        internal const string GetConsoleModeDllName = "api-ms-win-core-console-l1-1-0.dll";                  /*98*/
        internal const string GetConsoleScreenBufferInfoDllName = "api-ms-win-core-console-l2-1-0.dll";      /*99*/
        internal const string GetFileTypeDllName = "api-ms-win-core-file-l1-1-0.dll";                        /*100*/
        internal const string GetLargestConsoleWindowSizeDllName = "api-ms-win-core-console-l2-1-0.dll";     /*101*/
        internal const string ReadConsoleDllName = "api-ms-win-core-console-l1-1-0.dll";                     /*102*/
        internal const string PeekConsoleInputDllName = "api-ms-win-core-console-l2-1-0.dll";                /*103*/
        internal const string GetNumberOfConsoleInputEventsDllName = "api-ms-win-core-console-l1-1-0.dll";   /*104*/
        internal const string SetConsoleCtrlHandlerDllName = "api-ms-win-core-console-l1-1-0.dll";           /*105*/
        internal const string SetConsoleModeDllName = "api-ms-win-core-console-l1-1-0.dll";                  /*106*/
        internal const string SetConsoleScreenBufferSizeDllName = "api-ms-win-core-console-l2-1-0.dll";      /*107*/
        internal const string SetConsoleTextAttributeDllName = "api-ms-win-core-console-l2-1-0.dll";         /*108*/
        internal const string SetConsoleWindowInfoDllName = "api-ms-win-core-console-l2-1-0.dll";            /*109*/
        internal const string WriteConsoleOutputDllName = "api-ms-win-core-console-l2-1-0.dll";              /*110*/
        internal const string ReadConsoleOutputDllName = "api-ms-win-core-console-l2-1-0.dll";               /*111*/
        internal const string ScrollConsoleScreenBufferDllName = "api-ms-win-core-console-l2-1-0.dll";       /*112*/
        internal const string SendInputDllName = "ext-ms-win-ntuser-keyboard-l1-2-1.dll";                    /*113*/
        internal const string GetConsoleCursorInfoDllName = "api-ms-win-core-console-l2-1-0.dll";            /*114*/
        internal const string SetConsoleCursorInfoDllName = "api-ms-win-core-console-l2-1-0.dll";            /*115*/
        internal const string ReadConsoleInputDllName = "api-ms-win-core-console-l1-1-0.dll";                /*116*/
        internal const string GetVersionExDllName = "api-ms-win-core-sysinfo-l1-1-0.dll";                    /*117*/
        internal const string FormatMessageDllName = "api-ms-win-core-localization-l1-2-0.dll";              /*118*/
        internal const string CreateToolhelp32SnapshotDllName = "api-ms-win-core-toolhelp-l1-1-0";           /*119*/
        internal const string Process32FirstDllName = "api-ms-win-core-toolhelp-l1-1-0";                     /*120*/
        internal const string Process32NextDllName = "api-ms-win-core-toolhelp-l1-1-0";                      /*121*/
        internal const string GetACPDllName = "api-ms-win-core-localization-l1-2-0.dll";                     /*122*/
        internal const string DeleteServiceDllName = "api-ms-win-service-management-l1-1-0.dll";             /*123*/
        internal const string QueryServiceConfigDllName = "api-ms-win-service-management-l2-1-0.dll";        /*124*/
        internal const string QueryServiceConfig2DllName = "api-ms-win-service-management-l2-1-0.dll";       /*125*/
        internal const string SetServiceObjectSecurityDllName = "api-ms-win-service-management-l2-1-0.dll";  /*126*/
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\PowerShell\System.Management.Automation\utils\StringUtil.cs
/github.com/PowerShell/PowerShell/blob/v7.2.4/src/System.Management.Automation/utils/StringUtil.cs

using System.Globalization;

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Client.Tools.Publish\PowerShell\System.Management.Automation\utils\StructuredTraceSource.cs
/github.com/PowerShell/PowerShell/blob/v7.2.4/src/System.Management.Automation/utils/StructuredTraceSource.cs

#define TRACE

using System.Collections.Generic;
using System.Collections.Specialized;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Reflection;
using System.Text;
using System.Threading;

namespace System.Management.Automation
{
    #region PSTraceSourceOptions

    
/ </summary>
    [Flags]
    public enum PSTraceSourceOptions
    {
        
/ </summary>
        
/ </summary>
        
/ </summary>
        
/ </summary>
        
/ </summary>
        
/ </summary>
        
/ </summary>
        
/ </summary>
        
/ </summary>
        
/ </summary>
        
/ </summary>
        
/ </summary>
        
/ </summary>
        Verbose = 0x00000800,

        
/ </summary>
        
/ </summary>
        Scope = 0x00002000,

        
/ </summary>
        Assert = 0x00004000,

        
/ </summary>
        
/ </remarks>
        ExecutionFlow =
            Constructor |
            Dispose |
            Finalizer |
            Method |
            Delegates |
            Events |
            Scope,

        
/ </summary>
        
/ </remarks>
        Data =
            Constructor |
            Dispose |
            Finalizer |
            Property |
            Verbose |
            WriteLine,

        
/ </summary>
        
/ </remarks>
        Errors =
            Error |
            Exception,

        
/ </summary>
        
/ </remarks>
        All =
            Constructor |
            Dispose |
            Finalizer |
            Method |
            Property |
            Delegates |
            Events |
            Exception |
            Error |
            Warning |
            Verbose |
            Lock |
            WriteLine |
            Scope |
            Assert
    }

    #endregion PSTraceSourceOptions

    
/ </summary>
    
/ </summary>
    
/ </code>
    
/ </example>
    
/ </summary>
        
/ </param>
        
/ </param>
        
/ </param>
        
/ </param>
#pragma warning disable CS8618 
/ 2005/04/13-JonN In theory this should be ArgumentException,
                
/ </summary>
        internal void TraceGlobalAppDomainHeader()
        {
            
/ </summary>
        
/ </param>
        
/ </remarks>
        internal void TracerObjectHeader(
            Assembly callingAssembly)
        {
            if (_flags == PSTraceSourceOptions.None)
            {
                return;
            }

            
/ Write out the flags

            OutputLine(PSTraceSourceOptions.All, flagBuilder.ToString());
        }
        #endregion StructuredTraceSource constructor methods

        #region PSTraceSourceOptions.Scope

        internal IDisposable TraceScope(string msg)
        {
            if ((_flags & PSTraceSourceOptions.Scope) != PSTraceSourceOptions.None)
            {
                try
                {
                    return new ScopeTracer(this, PSTraceSourceOptions.Scope, null, null, string.Empty, msg);
                }
                catch { }
            }

            return null;
        }

        internal IDisposable TraceScope(string format, object arg1)
        {
            if ((_flags & PSTraceSourceOptions.Scope) != PSTraceSourceOptions.None)
            {
                try
                {
                    return new ScopeTracer(this, PSTraceSourceOptions.Scope, null, null, string.Empty, format, arg1);
                }
                catch { }
            }

            return null;
        }

        internal IDisposable TraceScope(string format, object arg1, object arg2)
        {
            if ((_flags & PSTraceSourceOptions.Scope) != PSTraceSourceOptions.None)
            {
                try
                {
                    return new ScopeTracer(this, PSTraceSourceOptions.Scope, null, null, string.Empty, format, arg1, arg2);
                }
                catch { }
            }

            return null;
        }

        #endregion PSTraceSourceOptions.Scope

        #region PSTraceSourceOptions.Method methods/helpers

        
/ </summary>
        
/ </param>
        
/ </param>
        
/ </returns>
        
/ <newpara/>
        
/ </code>
        
/ </example>
        
/ <newpara/>
        
/ <newpara/>
        
/ </remarks>
        internal IDisposable TraceMethod(
            string format,
            params object[] args)
        {
            if ((_flags & PSTraceSourceOptions.Method) != PSTraceSourceOptions.None)
            {
                try
                {
                    
/ normal operation.
                }
            }

            return null;
        }

        #endregion PSTraceSourceOptions.Method methods/helpers

        #region PSTraceSourceOptions.Events methods/helpers

        
/ </summary>
        
/ </returns>
        internal IDisposable TraceEventHandlers()
        {
            if ((_flags & PSTraceSourceOptions.Events) != PSTraceSourceOptions.None)
            {
                try
                {
                    
/ </summary>
        
/ </param>
        
/ </param>
        
/ </returns>
        internal IDisposable TraceEventHandlers(
            string format,
            params object[] args)
        {
            if ((_flags & PSTraceSourceOptions.Events) != PSTraceSourceOptions.None)
            {
                try
                {
                    
/ normal operation.
                }
            }

            return null;
        }
        #endregion PSTraceSourceOptions.Events methods/helpers

        #region PSTraceSourceOptions.Lock methods/helpers

        
/ </summary>
        
/ </returns>
        
/ <newpara/>
        
/ </code>
        
/ </example>
        
/ <newpara/>
        
/ <newpara/>
        
/ </remarks>
        internal IDisposable TraceLock(string lockName)
        {
            if ((_flags & PSTraceSourceOptions.Lock) != PSTraceSourceOptions.None)
            {
                try
                {
                    return (IDisposable)new ScopeTracer(
                        this,
                        PSTraceSourceOptions.Lock,
                        lockEnterFormatter,
                        lockLeavingFormatter,
                        lockName);
                }
                catch
                {
                    
/ </summary>
        
/ </param>
        internal void TraceLockAcquiring(string lockName)
        {
            if ((_flags & PSTraceSourceOptions.Lock) != PSTraceSourceOptions.None)
            {
                TraceLockHelper(
                    lockAcquiringFormatter,
                    lockName);
            }
        }

        
/ </summary>
        
/ </param>
        
/ </remarks>
        internal void TraceLockAcquired(string lockName)
        {
            if ((_flags & PSTraceSourceOptions.Lock) != PSTraceSourceOptions.None)
            {
                TraceLockHelper(
                    lockEnterFormatter,
                    lockName);
            }
        }

        
/ </summary>
        
/ </param>
        internal void TraceLockReleased(string lockName)
        {
            if ((_flags & PSTraceSourceOptions.Lock) != PSTraceSourceOptions.None)
            {
                TraceLockHelper(
                    lockLeavingFormatter,
                    lockName);
            }
        }

        
/ </summary>
        
/ </param>
        
/ </param>
        private void TraceLockHelper(
            string formatter,
            string lockName)
        {
            try
            {
                OutputLine(
                    PSTraceSourceOptions.Lock,
                    formatter,
                    lockName);
            }
            catch
            {
                
/ normal operation.
            }
        }
        #endregion PSTraceSourceOptions.Lock methods/helpers

        #region PSTraceSourceOptions.Error,Warning,Normal methods/helpers

        
/ </summary>
        
/ </param>
        
/ </param>
        internal void TraceError(
            string errorMessageFormat,
            params object[] args)
        {
            if ((_flags & PSTraceSourceOptions.Error) != PSTraceSourceOptions.None)
            {
                FormatOutputLine(
                    PSTraceSourceOptions.Error,
                    errorFormatter,
                    errorMessageFormat,
                    args);
            }
        }

        
/ </summary>
        
/ </param>
        
/ </param>
        internal void TraceWarning(
            string warningMessageFormat,
            params object[] args)
        {
            if ((_flags & PSTraceSourceOptions.Warning) != PSTraceSourceOptions.None)
            {
                FormatOutputLine(
                    PSTraceSourceOptions.Warning,
                    warningFormatter,
                    warningMessageFormat,
                    args);
            }
        }

        
/ </summary>
        
/ </param>
        
/ </param>
        internal void TraceVerbose(
            string verboseMessageFormat,
            params object[] args)
        {
            if ((_flags & PSTraceSourceOptions.Verbose) != PSTraceSourceOptions.None)
            {
                FormatOutputLine(
                    PSTraceSourceOptions.Verbose,
                    verboseFormatter,
                    verboseMessageFormat,
                    args);
            }
        }

        
/ </summary>
        
/ </param>
        internal void WriteLine(string format)
        {
            if ((_flags & PSTraceSourceOptions.WriteLine) != PSTraceSourceOptions.None)
            {
                FormatOutputLine(
                    PSTraceSourceOptions.WriteLine,
                    writeLineFormatter,
                    format,
                    Array.Empty<object>());
            }
        }

        
/ </summary>
        
/ <param name="format">The format string.</param>
        
/ <param name="arg1"></param>
        internal void WriteLine(string format, object arg1)
        {
            if ((_flags & PSTraceSourceOptions.WriteLine) != PSTraceSourceOptions.None)
            {
                FormatOutputLine(
                    PSTraceSourceOptions.WriteLine,
                    writeLineFormatter,
                    format,
                    new object[] { arg1 });
            }
        }

        internal void WriteLine(string format, bool arg1)
        {
            WriteLine(format, (object)arg1.ToString());
        }

        internal void WriteLine(string format, byte arg1)
        {
            WriteLine(format, (object)arg1.ToString());
        }

        internal void WriteLine(string format, char arg1)
        {
            WriteLine(format, (object)arg1.ToString());
        }

        internal void WriteLine(string format, decimal arg1)
        {
            WriteLine(format, (object)arg1.ToString());
        }

        internal void WriteLine(string format, double arg1)
        {
            WriteLine(format, (object)arg1.ToString());
        }

        internal void WriteLine(string format, float arg1)
        {
            WriteLine(format, (object)arg1.ToString());
        }

        internal void WriteLine(string format, int arg1)
        {
            WriteLine(format, (object)arg1.ToString());
        }

        internal void WriteLine(string format, long arg1)
        {
            WriteLine(format, (object)arg1.ToString());
        }

        internal void WriteLine(string format, uint arg1)
        {
            WriteLine(format, (object)arg1.ToString());
        }

        internal void WriteLine(string format, ulong arg1)
        {
            WriteLine(format, (object)arg1.ToString());
        }

        
/ </summary>
        
/ <param name="format">The format string.</param>
        
/ <param name="arg1"></param>
        
/ <param name="arg2"></param>
        internal void WriteLine(string format, object arg1, object arg2)
        {
            if ((_flags & PSTraceSourceOptions.WriteLine) != PSTraceSourceOptions.None)
            {
                FormatOutputLine(
                    PSTraceSourceOptions.WriteLine,
                    writeLineFormatter,
                    format,
                    new object[] { arg1, arg2 });
            }
        }

        
/ </summary>
        
/ <param name="format">The format string.</param>
        
/ <param name="arg1"></param>
        
/ <param name="arg2"></param>
        
/ <param name="arg3"></param>
        internal void WriteLine(string format, object arg1, object arg2, object arg3)
        {
            if ((_flags & PSTraceSourceOptions.WriteLine) != PSTraceSourceOptions.None)
            {
                FormatOutputLine(
                    PSTraceSourceOptions.WriteLine,
                    writeLineFormatter,
                    format,
                    new object[] { arg1, arg2, arg3 });
            }
        }

        
/ </summary>
        
/ <param name="format">The format string.</param>
        
/ <param name="arg1"></param>
        
/ <param name="arg2"></param>
        
/ <param name="arg3"></param>
        
/ <param name="arg4"></param>
        internal void WriteLine(string format, object arg1, object arg2, object arg3, object arg4)
        {
            if ((_flags & PSTraceSourceOptions.WriteLine) != PSTraceSourceOptions.None)
            {
                FormatOutputLine(
                    PSTraceSourceOptions.WriteLine,
                    writeLineFormatter,
                    format,
                    new object[] { arg1, arg2, arg3, arg4 });
            }
        }

        
/ </summary>
        
/ <param name="format">The format string.</param>
        
/ <param name="arg1"></param>
        
/ <param name="arg2"></param>
        
/ <param name="arg3"></param>
        
/ <param name="arg4"></param>
        
/ <param name="arg5"></param>
        internal void WriteLine(string format, object arg1, object arg2, object arg3, object arg4, object arg5)
        {
            if ((_flags & PSTraceSourceOptions.WriteLine) != PSTraceSourceOptions.None)
            {
                FormatOutputLine(
                    PSTraceSourceOptions.WriteLine,
                    writeLineFormatter,
                    format,
                    new object[] { arg1, arg2, arg3, arg4, arg5 });
            }
        }

        
/ </summary>
        
/ <param name="format">The format string.</param>
        
/ <param name="arg1"></param>
        
/ <param name="arg2"></param>
        
/ <param name="arg3"></param>
        
/ <param name="arg4"></param>
        
/ <param name="arg5"></param>
        
/ <param name="arg6"></param>
        internal void WriteLine(string format, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6)
        {
            if ((_flags & PSTraceSourceOptions.WriteLine) != PSTraceSourceOptions.None)
            {
                FormatOutputLine(
                    PSTraceSourceOptions.WriteLine,
                    writeLineFormatter,
                    format,
                    new object[] { arg1, arg2, arg3, arg4, arg5, arg6 });
            }
        }

        
/ </summary>
        
/ </param>
        internal void WriteLine(object arg)
        {
            if ((_flags & PSTraceSourceOptions.WriteLine) != PSTraceSourceOptions.None)
            {
#pragma warning disable CS8604 
/ </summary>
        
/ </param>
        
/ </param>
        
/ </param>
        
/ </param>
        private void FormatOutputLine(
            PSTraceSourceOptions flag,
            string classFormatter,
            string format,
            params object[] args)
        {
            try
            {
                
/ normal operation.
            }
        }

        #endregion PSTraceSourceOptions.Error methods/helpers

        #region Class helper methods and properties

        
/ </summary>
        
/ </remarks>
        
/ </param>
        
/ </returns>
        private static string GetCallingMethodNameAndParameters(int skipFrames)
        {
            StringBuilder methodAndParameters = null;

            try
            {
                
/ </summary>
        
/ </param>
        
/ </param>
        
/ </param>
        
/ </remarks>
        internal void OutputLine(
            PSTraceSourceOptions flag,
            string format,
            string arg = null)
        {
            
/ </summary>
        internal static int ThreadIndentLevel
        {
            get
            {
                
/ </summary>
        private static readonly ThreadLocal<int> s_localIndentLevel = new ThreadLocal<int>();

        
/ </summary>
        private PSTraceSourceOptions _flags = PSTraceSourceOptions.None;

        
/ </summary>
        public string Description { get; set; } = string.Empty;

        
/ </summary>
        
/ <value></value>
        internal bool ShowHeaders { get; set; } = true;

        
/ </summary>
        internal string FullName { get; } = string.Empty;

        private readonly string _name;

        
/ </summary>
        internal TraceSource TraceSource
        {
            get { return _traceSource ??= new MonadTraceSource(_name); }
        }

        private TraceSource _traceSource;

        #endregion Class helper methods and properties

        #region Public members

        
/ </summary>
        public PSTraceSourceOptions Options
        {
            get
            {
                return _flags;
            }

            set
            {
                _flags = value;
                this.TraceSource.Switch.Level = (SourceLevels)_flags;
            }
        }

        internal bool IsEnabled
        {
            get { return _flags != PSTraceSourceOptions.None; }
        }

        
/ </summary>
        public StringDictionary Attributes
        {
            get
            {
                return TraceSource.Attributes;
            }
        }

        
/ </summary>
        public TraceListenerCollection Listeners
        {
            get
            {
                return TraceSource.Listeners;
            }
        }

        
/ </summary>
        
/ </remarks>
        public string Name
        {
            get
            {
                return _name;
            }
        }

        
/ </summary>
        public SourceSwitch Switch
        {
            get
            {
                return TraceSource.Switch;
            }

            set
            {
                TraceSource.Switch = value;
            }
        }
        #endregion Public members

        #region TraceCatalog

        
/ </summary>
        
/ <value></value>
        internal static Dictionary<string, PSTraceSource> TraceCatalog { get; } = new Dictionary<string, PSTraceSource>(StringComparer.OrdinalIgnoreCase);

        
/ </summary>
        internal static Dictionary<string, PSTraceSource> PreConfiguredTraceSource { get; } = new Dictionary<string, PSTraceSource>(StringComparer.OrdinalIgnoreCase);

        #endregion TraceCatalog
    }

    #region ScopeTracer object/helpers

    
/ </summary>
    
/ </remarks>
    internal class ScopeTracer : IDisposable
    {
        
/ </summary>
        
/ </param>
        
/ </param>
        
/ </param>
        
/ </param>
        
/ </param>
#pragma warning disable CS8618 
/ </summary>
        
/ </param>
        
/ </param>
        
/ </param>
        
/ </param>
        
/ </param>
        
/ </param>
        
/ </param>
#pragma warning disable CS8618 
/ </summary>
        
/ </param>
        
/ </param>
        
/ </param>
        
/ </param>
        
/ </param>
        
/ </param>
        internal void ScopeTracerHelper(
            PSTraceSourceOptions flag,
            string scopeOutputFormatter,
            string leavingScopeFormatter,
            string scopeName,
            string format,
            params object[] args)
        {
            
/ </summary>
        public void Dispose()
        {
            
/ </summary>
        private readonly PSTraceSource _tracer;

        
/ </summary>
        private PSTraceSourceOptions _flag;

        
/ </summary>
        private string _scopeName;

        
/ </summary>
        private string _leavingScopeFormatter;
    }
    #endregion ScopeTracer object/helpers

    #region PSTraceSourceAttribute

    
/ </summary>
    
/ </remarks>
    [AttributeUsage(
         AttributeTargets.Field,
         AllowMultiple = false)]
    internal class TraceSourceAttribute : Attribute
    {
        
/ </summary>
        
/ </param>
        
/ </param>
        internal TraceSourceAttribute(
            string category,
            string description)
        {
            Category = category;
            Description = description;
        }

        
/ </summary>
        internal string Category { get; }

        
/ </summary>
        internal string Description { get; set; }
    }
    #endregion TraceSourceAttribute

    #region MonadTraceSource

    
/ </summary>
    internal class MonadTraceSource : TraceSource
    {
        internal MonadTraceSource(string name)
            : base(name)
        {
        }

        
/ </summary>
        
/ </returns>
        protected override string[] GetSupportedAttributes()
        {
            return new string[] { "Options" };
        }
    }
    #endregion MonadTraceSource
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Generators\AttributeGenerator.cs
/ <auto-generated/>
namespace BD.WTTS.Settings;

[AttributeUsage(AttributeTargets.Class, Inherited = false)]
public class {SettingsGenerationReceiver.AttributeName} : Attribute
{{
}}
        ";
        context.AddSource($"{SettingsGenerationReceiver.AttributeName}.g.cs", source);
    }

    public void Initialize(GeneratorInitializationContext context)
    {

    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.Generators\SettingsGenerator.cs
/ <auto-generated/>

            
/ <auto-generated/>
        
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.UnitTest\CertificateUnitTest.cs
/github.com/dotnet/runtime/issues/82693")]
    public void TestGenerateByCa()
    {
        var domains = new[] { "steampp.net", "www.steampp.net", };
        var subjectName = new X500DistinguishedName($"CN={domains.First()}");
        var x509Certificate2 = new X509Certificate2("ca.pfx");
        using var certificate2 = CertGenerator.CreateEndCertificate(x509Certificate2, subjectName, domains, default, DateTimeOffset.UtcNow.AddYears(1));
        byte[] exported = certificate2.Export(X509ContentType.Cert);
        File.WriteAllBytes("steampp.net.cer", exported);
    }
}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.UnitTest\HttpReverseProxyMiddlewareUnitTest.cs
/ </summary>
    [Test]
    public void TestFindScriptInjectInsertPosition()
    {
        var buffer = """
            <!DOCTYPE html>
            <html>
            <head>
            <meta charset="utf-8">
            <title></title>
            </head>
            <body>
            <h1>xxxx</h1>
            <p>yyyy</p>
            </body>
            </html>
            """u8;

        var encoding = Encoding.UTF8;
        HttpReverseProxyMiddleware.FindScriptInjectInsertPosition(buffer.ToArray(), encoding, out var _, out var position);
        Assert.That(position, Is.GreaterThan(0));

        var html_start = buffer[..position];
        var script_xml_start = "<script type=\"text/javascript\" src=\"https:
/local.steampp.net/"u8.ToArray();
        var script_xml_end = "\"></script>"u8.ToArray();

        using var s = new MemoryStream();
        s.Write(html_start);
        s.Write(script_xml_start);
        s.Write(encoding.GetBytes("1"));
        s.Write(script_xml_end);
        var html_end = buffer[position..];
        s.Write(html_end);

        var new_html = encoding.GetString(s.ToArray());
        TestContext.WriteLine(new_html);
    }
}
发现 Unix 特定路径：../SteamTools\src\BD.WTTS.UnitTest\IcoTest.cs
/ </summary>
public sealed class IcoTest
{
    static readonly string assemblyDir;

    static IcoTest()
    {
        var assemblyLocation = typeof(IcoTest).Assembly.Location;
        assemblyLocation.ThrowIsNull();
        assemblyDir = Path.GetDirectoryName(assemblyLocation)!;
        assemblyDir.ThrowIsNull();
    }

    
/ </summary>
    
/ 创建 ico 文件内存流
            using var fs = new FileStream(
                savePath,
                FileMode.Create,
                FileAccess.ReadWrite,
                FileShare.ReadWrite | FileShare.Delete);
            IcoEncoder.Encode(fs, bitmaps);
            TestContext.WriteLine(savePath);

            if (bitmaps != null)
                bitmaps.ForEach(x => x.Dispose());
        }
    }

    static SKBitmap ResizeImage(SKBitmap image, SKBitmap icoIcon, int size)
    {
        int icoWidth = size / 4;
        int icoHeight = size / 4;

        int watermarkLeft = size - icoWidth;
        int watermarkTop = size - icoHeight;

        SKBitmap scaledImage = new(size, size);
        image.ScalePixels(scaledImage, SKFilterQuality.High);

        using SKCanvas canvas = new(scaledImage);
        canvas.DrawBitmap(icoIcon, new SKRect(watermarkLeft, watermarkTop, watermarkLeft + icoWidth, watermarkTop + icoHeight));
        return scaledImage;
    }

    static IEnumerable<int> GetImgResolutionPower(int size, int[] rp)
    {
        foreach (var item in rp)
        {
            if (item <= size) yield return item;
        }
    }

}

发现 Unix 特定路径：../SteamTools\src\BD.WTTS.UnitTest\IpcSerializableTest.cs
/ </summary>
    [Test]
    [Ignore("因覆盖不到所有的类型检测而暂时弃用")]
    public void TestSerializable()
    {
        var ignoreTypes = new[]
        {
            "System.Void",
            typeof(Task).FullName,
            typeof(ValueTask).FullName,
        };
        var queryType = from t in typeof(IPCPlatformService).Assembly.GetTypes()
                        where t.IsInterface
                        let attr = t.GetCustomAttribute<IpcPublicAttribute>()
                        where attr != null
                        select t;
        var queryMethods = from t in queryType
                           let m = t.GetMethods()
                           where m.Any_Nullable()
                           select m;
        var queryArgs = (from m in queryMethods.SelectMany(static x => x)
                         let returnType = m.ReturnType
                         let parameters = m.GetParameters().Select(p => p.ParameterType)
                         select (new[] { GetEmbeddedType(returnType) }.Concat(parameters.Select(GetEmbeddedType)), m)).ToArray();
        var args = queryArgs
            .SelectMany(static x => x.Item1)
            .Where(x => !ignoreTypes.Contains(x.FullName))
            .ToHashSet();

        var dict = args.ToDictionary(static x => x,
            y => queryArgs.Where(x => x.Item1.Contains(y)).Select(x => x.m).ToHashSet());

        foreach (var item in dict)
        {
            bool error = false;
            if (item.Key == typeof(object))
            {
                error = true;
            }
            else
            {
                if (item.Key.IsSerializable) continue;
                switch (item.Key.GetTypeCode())
                {
                    case TypeCode.Object:
                        var ctor = item.Key.GetConstructor(BindingFlags.Public, Array.Empty<Type>());
                        error = ctor == null;
                        break;
                    case TypeCode.Empty:
                    case TypeCode.DBNull:
                    case TypeCode.Boolean:
                    case TypeCode.Char:
                    case TypeCode.SByte:
                    case TypeCode.Byte:
                    case TypeCode.Int16:
                    case TypeCode.UInt16:
                    case TypeCode.Int32:
                    case TypeCode.UInt32:
                    case TypeCode.Int64:
                    case TypeCode.UInt64:
                    case TypeCode.Single:
                    case TypeCode.Double:
                    case TypeCode.Decimal:
                    case TypeCode.DateTime:
                    case TypeCode.String:
                        break;
                    default:
                        error = true;
                        break;
                }
            }
            if (error)
            {
                foreach (var m in item.Value)
                {
                    TestContext.WriteLine(m.ToString());
                }
                Assert.Fail(item.Key.FullName);
            }
        }
    }
}

发现 Unix 特定路径：../SteamTools\src\XunYouSDK\XunYouSDK.AppId.cs
/ </summary>
    const int appId = 0;

    
/ </summary>
    const int userType = 0;

    
/ </summary>
    const string channel_no = "";

    const string webapi_host = "";

    const string webapi_vip_endtime = "";

    static string CalcWebApiSign(XunYouBaseRequest body)
    {
        return "";
    }
}
发现 Unix 特定路径：../SteamTools\src\XunYouSDK\XunYouSDK.cs
/ </summary>
    
/ <param name="libraryName"></param>
    
/ <param name="assembly"></param>
    
/ <param name="searchPath"></param>
    
/ <returns></returns>
    
/ 初始化 <see cref="XunYouSDK"/>
    
/ </summary>
    public static void Initialize()
    {
        
/ </summary>
    public static bool IsSupported { get; private set; }

#if WINDOWS
    static XunYouSDK()
    {
        if (appId != 0)
        {
            switch (RuntimeInformation.OSArchitecture)
            {
                case Architecture.X86:
                case Architecture.X64:
                    IsSupported = true;
                    switch (RuntimeInformation.ProcessArchitecture)
                    {
                        case Architecture.X86:
                            libraryPath = Path.GetFullPath(Path.Combine(typeof(XunYouSDK).Assembly.Location, "..", libraryFileNameX86));
                            break;
                        case Architecture.X64:
                            libraryPath = Path.GetFullPath(Path.Combine(typeof(XunYouSDK).Assembly.Location, "..", libraryFileNameX64));
                            break;
                    }
                    break;
            }
        }
    }
#endif
}

发现条件编译指令：../SteamTools\src\XunYouSDK\XunYouSDK.cs
WINDOWS
WINDOWS
